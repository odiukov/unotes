{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>My personal knowledge base built over a decade of game development </p> <p>Here you\u2019ll find: - \ud83d\udee0 Practical DOTS tips - \u26a1 Optimization guides - \ud83e\udde9 Performance hacks - \u2705 Proven solutions from real projects </p> <p>My goal is to help Unity developers save time, avoid common pitfalls, and build better games.</p>"},{"location":"DOTS/","title":"Unity DOTS Cheat Sheet","text":"<p>Complete reference for Unity's Data-Oriented Technology Stack (DOTS) - covering Entity Component System (ECS), Jobs, Burst, and performance optimization.</p>"},{"location":"DOTS/#quick-navigation","title":"Quick Navigation","text":""},{"location":"DOTS/#components","title":"\ud83d\udce6 Components","text":"<p>Data containers - what entities \"have\" - IComponentData - General-purpose components - IBufferElementData (dynamic buffers) - Dynamic arrays - BlobAsset (immutable data) - Immutable shared data - ISharedComponentData - Shared component values - IEnableableComponent (toggleable components) - Toggle on/off - UnityObjectRef (UnityEngine.Object references) - Unity asset references - IAspect (component grouping) - Component grouping (deprecated 6.5+)</p>"},{"location":"DOTS/#systems","title":"\u2699\ufe0f Systems","text":"<p>Logic processors - where behavior lives - ISystem - Modern struct-based systems (recommended) - SystemBase - Legacy class-based systems - EntityCommandBuffer - Deferred structural changes - ComponentLookup and BufferLookup - Random entity access - RefRO and RefRW - Component access wrappers</p>"},{"location":"DOTS/#jobs","title":"\u26a1 Jobs","text":"<p>Parallel processing - maximize CPU utilization - IJobEntity - Entity iteration jobs - ITriggerEventsJob - Physics trigger events - More job types in documentation</p>"},{"location":"DOTS/#baking","title":"\ud83d\udd28 Baking","text":"<p>Authoring workflow - GameObject to Entity conversion - Baker (authoring conversion) - Conversion code - TransformUsageFlags - Transform component control - Baking Workflow and SubScenes - Complete baking guide</p>"},{"location":"DOTS/#attributes","title":"\ud83c\udff7\ufe0f Attributes","text":"<p>System control - ordering, compilation, access - BurstCompile - Native code compilation - UpdateInGroup, UpdateBefore, UpdateAfter - System ordering - ChunkIndexInQuery - Parallel ECB determinism - RequireMatchingQueriesForUpdate - Conditional updates - ReadOnly and Optional - Access control</p>"},{"location":"DOTS/#patterns","title":"\ud83d\udcd0 Patterns","text":"<p>Common DOTS patterns and best practices - SystemAPI.Query - Entity iteration pattern - WithChangeFilter (reactive updates) - Reactive systems - Singleton entities and components - Global data</p>"},{"location":"DOTS/#advanced","title":"\ud83c\udf93 Advanced","text":"<p>Deep dives - internals and optimization - Job Safety System - Race condition prevention - System Dependencies - Automatic dependency management - Sync points - Performance killers - API Gotchas - Non-obvious API behaviors</p>"},{"location":"DOTS/#testing","title":"\ud83e\uddea Testing","text":"<p>Testing strategies - validation and performance - Unit Testing - System logic validation with test worlds - Performance Testing - Automated benchmarking and optimization</p>"},{"location":"DOTS/#glossary","title":"\ud83d\udcda Glossary","text":"<p>Core concepts and terminology - Entity - Unique identifier - Component - Data container - Archetype - Component type combination - Chunk - 16KB memory block - Burst - High-performance compiler - Job - Parallel work unit - Baking - Authoring conversion process</p>"},{"location":"DOTS/#unity-entities-65-updates","title":"Unity Entities 6.5+ Updates","text":"<ul> <li>\u26a0\ufe0f IAspect deprecated - use direct component access</li> <li>\u26a0\ufe0f Entities.ForEach deprecated - use IJobEntity</li> <li>\u2728 UnityObjectRef - new blittable Unity object wrapper</li> <li>\u2728 TryGetRefRW/TryGetRefRO - safer ComponentLookup access</li> </ul>"},{"location":"DOTS/Advanced/","title":"Advanced DOTS Concepts","text":"<p>Deep dives into Unity DOTS internals, performance optimization, and advanced patterns. These topics assume familiarity with basic DOTS concepts.</p>"},{"location":"DOTS/Advanced/#core-advanced-topics","title":"Core Advanced Topics","text":""},{"location":"DOTS/Advanced/#job-safety-system","title":"Job Safety System","text":"<p>Understanding how Unity prevents race conditions in parallel code through atomic safety handles and dependency tracking.</p> <p>Key concepts: - AtomicSafetyHandle for read/write validation - Job scheduling safety checks - Container access safety during execution - Common safety errors and solutions</p>"},{"location":"DOTS/Advanced/#system-dependencies","title":"System Dependencies","text":"<p>How Unity ECS automatically manages job dependencies across systems to prevent race conditions while enabling parallelization.</p> <p>Key concepts: - Component dependency registry per World - SystemState.Dependency lifecycle (BeforeUpdate \u2192 OnUpdate \u2192 AfterUpdate) - Automatic dependency chaining based on component access - Read-only vs read-write dependency separation</p>"},{"location":"DOTS/Advanced/#sync-points","title":"Sync points","text":"<p>When and why jobs are forced to complete, killing parallel performance. Critical for optimization.</p> <p>Key concepts: - Three types: ReadOnly, ReadWrite, Structural Change - Common sync point causes (EntityManager access, ECB playback, queries) - Performance impact and how to avoid - Organizing systems to minimize sync points</p>"},{"location":"DOTS/Advanced/#api-gotchas","title":"API Gotchas","text":"<p>Non-obvious behaviors of EntityManager methods that can cause performance problems or bugs.</p> <p>Key gotchas: - <code>AddComponent(EntityQuery)</code> vs <code>AddComponent(Entity)</code> - chunk modification vs entity movement - <code>Instantiate(Entity, NativeArray)</code> - doesn't instantiate LinkedEntityGroup - When to use bulk operations vs individual operations</p>"},{"location":"DOTS/Advanced/#advanced-workflow-topics","title":"Advanced Workflow Topics","text":""},{"location":"DOTS/Advanced/#baking-workflow-and-subscenes","title":"Baking Workflow and SubScenes","text":"<p>Complete guide to the baking process, SubScene streaming, and content management.</p> <p>Key concepts: - Editor vs Build baking workflows - Live-baking for iteration - SubScene streaming and async loading - Content archives and dependency tracking</p>"},{"location":"DOTS/Advanced/#performance-optimization","title":"Performance Optimization","text":"<p>To maximize DOTS performance: 1. Minimize Sync points - avoid EntityManager.Get/SetComponentData, batch structural changes 2. Maximize parallelization - understand System Dependencies to run jobs in parallel 3. Use Job Safety System knowledge - mark lookups <code>[ReadOnly]</code> for parallel access 4. Avoid API Gotchas - use correct overloads to prevent chunk fragmentation</p>"},{"location":"DOTS/Advanced/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"DOTS/Advanced/#job-scheduling","title":"Job Scheduling","text":"<pre><code>// \u2705 GOOD: Jobs chain dependencies, run in parallel\nJobHandle jobA = new JobA().Schedule(state.Dependency);\nJobHandle jobB = new JobB().Schedule(state.Dependency);  // Parallel with A\nstate.Dependency = JobHandle.CombineDependencies(jobA, jobB);\n</code></pre>"},{"location":"DOTS/Advanced/#sync-point-avoidance","title":"Sync Point Avoidance","text":"<pre><code>// \u274c BAD: Main thread access = sync point\nHealth h = EntityManager.GetComponentData&lt;Health&gt;(entity);\n\n// \u2705 GOOD: Job access = no sync point\nnew ProcessHealthJob().ScheduleParallel();\n</code></pre>"},{"location":"DOTS/Advanced/#system-organization","title":"System Organization","text":"<pre><code>Frame Structure:\n\u251c\u2500 Input/UI Systems (main thread, unavoidable sync points)\n\u251c\u2500 Job Scheduling Systems (all jobs scheduled here)\n\u2514\u2500 Final sync at frame end (jobs complete naturally while rendering)\n</code></pre>"},{"location":"DOTS/Advanced/#structural-changes","title":"Structural Changes","text":"<pre><code>// \u274c BAD: Immediate structural change = sync ALL jobs\nEntityManager.AddComponent&lt;Dead&gt;(entity);\n\n// \u2705 GOOD: Deferred via ECB = no sync until playback\necb.AddComponent&lt;Dead&gt;(entity);\n</code></pre>"},{"location":"DOTS/Advanced/#common-optimization-mistakes","title":"Common Optimization Mistakes","text":"<ol> <li>Excessive sync points - calling EntityManager.GetComponent every frame</li> <li>Poor system ordering - systems with conflicting access not grouped efficiently</li> <li>Bulk API misuse - using EntityQuery overloads for small entity counts</li> <li>Ignoring LinkedEntityGroup - using NativeArray Instantiate on prefabs with children</li> <li>Live-baking assumptions - assuming Editor behavior matches builds</li> </ol>"},{"location":"DOTS/Advanced/#debugging-tools","title":"Debugging Tools","text":"<ul> <li>Unity Profiler - Look for \"Sync Point\" markers</li> <li>Entity Debugger - Inspect chunk utilization (check for sparse chunks)</li> <li>Burst Inspector - Verify job compilation and optimizations</li> <li>Build Report - Check content archive sizes</li> </ul>"},{"location":"DOTS/Advanced/#advanced-reading","title":"Advanced Reading","text":"<p>For more information, see: - Unity Job System Manual - Unity.Entities Manual - Unity.Burst Manual</p>"},{"location":"DOTS/Advanced/API%20Gotchas/","title":"API Gotchas","text":"","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/API%20Gotchas/#description","title":"Description","text":"<ul> <li> <p>Non-obvious API behaviors and common pitfalls in Unity DOTS that can cause performance issues, memory problems, or unexpected behavior</p> </li> <li> <p>Understanding these gotchas prevents subtle bugs and helps choose the right API overload for your use case</p> </li> <li> <p>Focus on EntityManager methods with multiple overloads that behave very differently</p> </li> </ul>","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/API%20Gotchas/#entitymanageraddcomponententityquery-and-removecomponententityquery","title":"EntityManager.AddComponent(EntityQuery) and RemoveComponent(EntityQuery)","text":"<p>The Problem: The <code>EntityQuery</code> overload modifies chunks themselves to match target Archetype, rather than moving entities between chunks. This is extremely efficient for large entity counts but creates empty chunks when used frequently on small entity counts.</p> <p>How It Works: <pre><code>// EntityQuery overload: Modifies source chunk archetype\nEntityManager.AddComponent&lt;NewComponent&gt;(entityQuery);\n// Result: Original chunk now has NewComponent archetype\n// Entities stay in same chunk, chunk archetype changed\n\n// Entity overload: Moves entity to different chunk\nEntityManager.AddComponent&lt;NewComponent&gt;(singleEntity);\n// Result: Entity moves to chunk with NewComponent archetype\n// Original chunk unchanged\n</code></pre></p> <p>The Gotcha: <pre><code>// Adding component to 1 entity per frame using EntityQuery\nvar query = SystemAPI.QueryBuilder().WithAll&lt;Enemy&gt;().Build();\n\n// Frame 1: 1 enemy matches, Chunk A archetype changed to [Enemy, Dead]\nEntityManager.AddComponent&lt;Dead&gt;(query);\n\n// Frame 2: New enemy in Chunk B, archetype changed to [Enemy, Dead]\nEntityManager.AddComponent&lt;Dead&gt;(query);\n\n// Problem: 2 chunks with 1 entity each! (normal capacity: 128 entities)\n// After 100 frames: 100 chunks with 1 entity each = disaster\n</code></pre></p> <p>When to Use:</p> <p>\u2705 Good: One-time bulk operations on 100+ entities (SubScene post-processing) \u274c Bad: Incremental per-frame additions (use EntityCommandBuffer instead)</p> <p>Better Alternatives:</p> <p>Use EntityCommandBuffer for incremental changes: <pre><code>var ecb = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;()\n    .CreateCommandBuffer(state.WorldUnmanaged);\n\nforeach (var (health, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;().WithEntityAccess())\n{\n    if (health.ValueRO.Current &lt;= 0)\n    {\n        ecb.AddComponent&lt;Dead&gt;(entity);  // Moves entity properly\n    }\n}\n</code></pre></p> <p>Use Entity overload for single entities: <pre><code>EntityManager.AddComponent&lt;Dead&gt;(singleEntity);\n// Properly moves entity to correct chunk\n</code></pre></p>","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/API%20Gotchas/#entitymanagerinstantiateentity-nativearray","title":"EntityManager.Instantiate(Entity, NativeArray) <p>The Problem: The <code>NativeArray</code> overload does NOT instantiate the <code>LinkedEntityGroup</code> (child entities), while the normal <code>Entity</code> overload does. This breaks prefabs with hierarchies.</p> <p>How It Works: <pre><code>// Normal overload: Instantiates entity AND all linked entities\nEntity instance = EntityManager.Instantiate(prefabEntity);\n// Result: If prefab has children, all are instantiated\n\n// NativeArray overload: Only instantiates PRIMARY entity\nvar instances = new NativeArray&lt;Entity&gt;(10, Allocator.Temp);\nEntityManager.Instantiate(prefabEntity, instances);\n// Result: Children NOT instantiated! Only root entity cloned 10 times\n</code></pre></p> <p>The Gotcha: <pre><code>// Prefab with LinkedEntityGroup: [Character, Weapon, Shield, HealthBar]\n\nvar characters = new NativeArray&lt;Entity&gt;(5, Allocator.Temp);\nEntityManager.Instantiate(characterPrefab, characters);\n\n// Result: 5 character root entities, NO weapons/shields/healthbars!\n</code></pre></p> <p>When to Use:</p> <p>\u2705 Good: Simple entities without children (bullets, particles) \u274c Bad: Baked prefabs or prefabs with hierarchy (use normal overload)</p> <p>Better Alternatives:</p> <p>Use normal overload for prefabs with children: <pre><code>for (int i = 0; i &lt; count; i++)\n{\n    Entity instance = EntityManager.Instantiate(prefabEntity);\n    // Correctly instantiates all linked entities\n}\n</code></pre></p> <p>Use EntityCommandBuffer for deferred instantiation: <pre><code>var ecb = SystemAPI.GetSingleton&lt;BeginSimulationEntityCommandBufferSystem.Singleton&gt;()\n    .CreateCommandBuffer(state.WorldUnmanaged);\n\nfor (int i = 0; i &lt; count; i++)\n{\n    Entity instance = ecb.Instantiate(prefabEntity);\n    // Correctly handles LinkedEntityGroup\n}\n</code></pre></p> <p>Check for LinkedEntityGroup before using NativeArray overload: <pre><code>if (EntityManager.HasComponent&lt;LinkedEntityGroup&gt;(prefabEntity))\n{\n    // Use normal overload\n    for (int i = 0; i &lt; count; i++)\n        instances[i] = EntityManager.Instantiate(prefabEntity);\n}\nelse\n{\n    // Safe to use bulk overload\n    EntityManager.Instantiate(prefabEntity, instances);\n}\n</code></pre></p>","text":"","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/API%20Gotchas/#summary-table","title":"Summary Table","text":"API Appropriate Use Inappropriate Use Alternative <code>AddComponent(EntityQuery)</code> Bulk one-time operations on 100+ entities Incremental per-frame additions <code>ECB.AddComponent(entity)</code> <code>RemoveComponent(EntityQuery)</code> Bulk scene post-processing Processing spawned entities <code>ECB.RemoveComponent(entity)</code> <code>Instantiate(Entity, NativeArray)</code> Simple entities without children Baked prefabs or hierarchies <code>Instantiate(entity)</code> in loop","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/API%20Gotchas/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Default to Entity overloads - use <code>AddComponent(entity)</code>, <code>Instantiate(entity)</code> unless you have verified reason to use bulk overloads</p> </li> <li> <p>Check LinkedEntityGroup - before using <code>Instantiate(entity, array)</code>, verify prefab has no children:    <pre><code>if (!EntityManager.HasComponent&lt;LinkedEntityGroup&gt;(prefab))\n    // Safe to use bulk instantiate\n</code></pre></p> </li> <li> <p>Use EntityCommandBuffer for incremental changes - avoids chunk fragmentation from EntityQuery overloads</p> </li> <li> <p>Profile chunk utilization - use Entity Debugger to check for sparse chunks (many chunks with few entities)</p> </li> <li> <p>Bulk operations = manual entities only - EntityQuery overloads are safe for manually created entities, risky for baked prefabs</p> </li> </ol>","tags":["advanced","pitfalls"]},{"location":"DOTS/Advanced/Job%20Safety%20System/","title":"Job Safety System","text":"","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#description","title":"Description","text":"<ul> <li> <p>Compile-time race condition prevention system that validates job scheduling to ensure no two jobs can access the same data unsafely</p> </li> <li> <p>Implemented through AtomicSafetyHandle tracking on native containers (NativeArray, NativeList, etc.) - every container has a safety handle that tracks read/write access</p> </li> <li> <p>Prevents two types of race conditions: one job writes while another reads the same container, or both jobs write to the same container</p> </li> <li> <p>Safety checks happen both during scheduling (prevents unsafe job combinations) and during execution (prevents unsafe container access on current thread)</p> </li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#how-it-works","title":"How It Works","text":"<p>During Job Scheduling: 1. Job is scanned recursively for all fields that are native containers 2. Each container's safety handle is \"reserved\" under this job 3. When another job schedules, Unity checks if its containers conflict with already-scheduled jobs 4. If unsafe behavior detected (write-read or write-write conflict), Unity throws exception and prevents scheduling</p> <p>Reserved State Release: - Safety handles remain reserved until <code>JobHandle.Complete()</code> is called (a sync point) - This ensures jobs complete before conflicting access is allowed</p> <p>During Container Access: - Every read/write to native container calls <code>AtomicSafetyHandle.CheckReadAndThrow()</code> or <code>CheckWriteAndThrow()</code> - Ensures container access is allowed on current thread - Throws if job is scheduled but you try to access container on main thread - Throws if trying to write to read-only container in job</p>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct SafetyExampleSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        var positions = new NativeArray&lt;float3&gt;(100, Allocator.TempJob);\n\n        // Schedule write job\n        JobHandle writeJob = new WriteJob { Positions = positions }.Schedule(state.Dependency);\n\n        // \u274c ERROR: Cannot schedule - write-read conflict\n        JobHandle readJob = new ReadJob { Positions = positions }.Schedule(state.Dependency);\n\n        // \u2705 CORRECT: Chain dependency\n        JobHandle readJob = new ReadJob { Positions = positions }.Schedule(writeJob);\n\n        state.Dependency = readJob;\n        positions.Dispose(state.Dependency);\n    }\n}\n\n// \u274c ERROR: Main thread access during job\nvar array = new NativeArray&lt;int&gt;(10, Allocator.TempJob);\nJobHandle job = new WriteJob { Array = array }.Schedule();\nint value = array[0];  // Throws AtomicSafetyHandle exception\n\n// \u2705 CORRECT: Complete job first\njob.Complete();  // Sync point\nint value = array[0];  // Now safe\n</code></pre>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#common-safety-errors","title":"Common Safety Errors","text":"<p>Error: Write-Read Conflict <pre><code>InvalidOperationException: The previously scheduled job `WriteJob` writes to\nthe NativeArray `Positions`. You must call JobHandle.Complete() on the job\n`WriteJob`, before you can read from the NativeArray safely.\n</code></pre> Solution: Use job dependencies - pass write job's JobHandle as dependency to read job</p> <p>Error: Write-Write Conflict <pre><code>InvalidOperationException: The previously scheduled job `JobA` writes to the\nNativeArray `Data`. The job `JobB` also writes to the same NativeArray. You\ncannot schedule two jobs that write to the same data simultaneously.\n</code></pre> Solution: Chain jobs with dependencies or use different containers</p> <p>Error: Main Thread Access During Job <pre><code>InvalidOperationException: The NativeArray Positions is being written to by a\njob. You are trying to read from it on the main thread. This is not allowed.\n</code></pre> Solution: Call <code>jobHandle.Complete()</code> before accessing on main thread</p>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#pros","title":"Pros","text":"<ul> <li> <p>Prevents race conditions - compile-time and runtime checking catches threading bugs</p> </li> <li> <p>Deterministic validation - safety errors are reproducible and caught early in Editor</p> </li> <li> <p>Thread safety guarantees - if code compiles and runs without errors, it's thread-safe</p> </li> <li> <p>Clear error messages - exceptions explain exactly what conflict occurred</p> </li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#cons","title":"Cons","text":"<ul> <li> <p>Performance overhead in Editor - safety checks add overhead (disabled in builds for performance)</p> </li> <li> <p>Requires understanding - developers must learn job dependencies and [ReadOnly] attributes</p> </li> <li> <p>Can be restrictive - prevents some valid patterns that are technically safe but complex to validate</p> </li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#best-use","title":"Best use","text":"<ul> <li> <p>All job scheduling - safety system is always active, ensuring all jobs are scheduled correctly</p> </li> <li> <p>Debugging race conditions - safety errors pinpoint exact source of threading issues</p> </li> <li> <p>Learning DOTS - safety system teaches correct job dependency patterns</p> </li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#avoid-if","title":"Avoid if","text":"<ul> <li>N/A - safety system is fundamental to Unity jobs, cannot be avoided</li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Job%20Safety%20System/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>[ReadOnly] attribute - only fields marked <code>[ReadOnly]</code> are considered read-only for safety checks</p> </li> <li> <p>Job dependencies solve conflicts - chain dependencies to prevent race conditions:   <pre><code>JobHandle jobB = jobB.Schedule(jobA);  // jobB waits for jobA\n</code></pre></p> </li> <li> <p>Unity ECS auto-manages dependencies - <code>SystemState.Dependency</code> automatically tracks component access across systems</p> </li> <li> <p>Parallel reads - multiple jobs can read same container if all marked <code>[ReadOnly]</code>, but only one can write</p> </li> <li> <p>Safety in builds - safety checks are Editor-only by default, disabled in builds (enable with <code>ENABLE_UNITY_COLLECTIONS_CHECKS</code>)</p> </li> <li> <p>Complete() is a sync point - avoid calling <code>JobHandle.Complete()</code> when possible</p> </li> </ul>","tags":["advanced","safety"]},{"location":"DOTS/Advanced/Rate%20Managers/","title":"Rate Managers","text":"","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#description","title":"Description","text":"<ul> <li> <p>Control how often a system group updates - rate managers determine if a system group should run this frame, how many times, and what time values it reports</p> </li> <li> <p>Manage time perception - each rate manager pushes its own delta time and elapsed time to systems via <code>SystemAPI.Time</code>, independent of actual framerate</p> </li> <li> <p>Enable fixed timestep logic - essential for deterministic physics simulation and framerate-independent gameplay logic</p> </li> <li> <p>System groups can run 0, 1, or multiple times per frame depending on their rate manager configuration</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#rate-manager-types","title":"Rate Manager Types","text":"","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#no-rate-manager-default","title":"No Rate Manager (Default)","text":"<p>System group updates every frame with parent group's time.</p> <pre><code>// Default behavior - runs every frame\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic partial struct MyGameplaySystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Runs once per frame\n        // DeltaTime = parent group's delta time\n    }\n}\n</code></pre>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#fixed-rate-simple-manager","title":"Fixed Rate Simple Manager","text":"<p>Updates every frame but reports fixed delta time, unaffected by <code>Time.timeScale</code>.</p> <pre><code>[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic class FixedRateSimpleGroup : ComponentSystemGroup\n{\n    public FixedRateSimpleGroup()\n    {\n        SetRateManagerCreateAllocator(new RateUtils.FixedRateSimpleManager(50f));\n    }\n}\n\n[UpdateInGroup(typeof(FixedRateSimpleGroup))]\npublic partial struct OldSchoolGameSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // SystemAPI.Time.DeltaTime always 0.02 (50 FPS), runs every frame\n    }\n}\n</code></pre> <p>Characteristics: Runs every frame, reports constant delta time, ignores timeScale, good for legacy porting</p>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#fixed-rate-catch-up-manager","title":"Fixed Rate Catch-Up Manager","text":"<p>Like Unity's <code>FixedUpdate</code> - runs at fixed timestep, may update 0, 1, or N times per frame.</p> <pre><code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]  // Default 60 Hz\npublic partial struct PhysicsSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // At 120 FPS: runs every other frame\n        // At 30 FPS: runs twice per frame\n        float fixedDelta = SystemAPI.Time.DeltaTime; // Always 0.0166f (1/60)\n    }\n}\n</code></pre> <p>Characteristics: Runs 0-N times per frame, fixed delta time, respects timeScale, has MaximumDeltaTime cap</p>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#variable-rate-manager","title":"Variable Rate Manager","text":"<p>Updates at target framerate using real time (unscaled), good for low-frequency operations.</p> <pre><code>[UpdateInGroup(typeof(VariableRateSimulationSystemGroup))]  // Default 15 FPS\npublic partial struct CleanupSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Runs ~15x per second using real time (unaffected by timeScale)\n        // At 60 FPS: runs ~every 4th frame\n    }\n}\n</code></pre> <p>Characteristics: Uses real time stopwatch, ignores timeScale, good for cleanup/background tasks</p>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#internal-mechanism","title":"Internal Mechanism","text":"<p>Rate managers control <code>ComponentSystemGroup.OnUpdate</code>: - <code>ShouldGroupUpdate()</code> returns true/false based on rate logic - Time is \"pushed\" - child systems see rate manager's time via <code>SystemAPI.Time</code> - World Update Allocator is set per-group (automatic deallocation) - Can loop multiple times (catch-up) or skip frames entirely</p>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#default-system-groups-rate-managers","title":"Default System Groups &amp; Rate Managers","text":"<p>Unity's built-in system groups and their rate managers:</p> System Group Rate Manager Frequency Purpose InitializationSystemGroup None Every frame Runs first - initialization, setup SimulationSystemGroup None Every frame Main gameplay logic (default group) FixedStepSimulationSystemGroup Fixed Rate Catch-Up (60 Hz) Fixed 60 Hz Physics, deterministic simulation VariableRateSimulationSystemGroup Variable Rate (15 FPS) ~15 FPS real time Low-frequency tasks, cleanup LateSimulationSystemGroup None Every frame After [[TransformSystemGroup]] PresentationSystemGroup None Every frame Rendering, presentation - runs last <p>Nested structure: <pre><code>InitializationSystemGroup (every frame)\nSimulationSystemGroup (every frame)\n  \u251c\u2500 FixedStepSimulationSystemGroup (fixed 60 Hz)\n  \u251c\u2500 VariableRateSimulationSystemGroup (variable ~15 FPS)\n  \u251c\u2500 [Your systems here] (every frame, default location)\n  \u2514\u2500 LateSimulationSystemGroup (every frame, after transforms)\nPresentationSystemGroup (every frame)\n</code></pre></p>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#pros","title":"Pros","text":"<ul> <li> <p>Deterministic simulation - fixed timestep ensures consistent physics regardless of framerate</p> </li> <li> <p>Performance optimization - variable rate allows expensive systems to run less frequently</p> </li> <li> <p>Framerate independence - gameplay logic decoupled from rendering framerate</p> </li> <li> <p>Time control - each system group has independent time perception and scaling</p> </li> <li> <p>Automatic allocator management - World Update Allocator lifetime tied to group update</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#cons","title":"Cons","text":"<ul> <li> <p>Complexity - multiple time contexts can be confusing (system sees different DeltaTime than game framerate)</p> </li> <li> <p>Catch-up spiral - if fixed rate system takes &gt;1 frame, can spiral (mitigated by MaximumDeltaTime cap)</p> </li> <li> <p>Debugging difficulty - systems running 0 or multiple times per frame harder to reason about</p> </li> <li> <p>Unity bug - Fixed Rate Catch-Up doesn't respect timeScale for MaximumDeltaTime (can copy/fix code)</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#best-use","title":"Best use","text":"<ul> <li> <p>Physics simulation - use Fixed Rate Catch-Up Manager (FixedStepSimulationSystemGroup) for deterministic physics</p> </li> <li> <p>Low-priority tasks - use Variable Rate Manager for cleanup, analytics, non-critical background work</p> </li> <li> <p>Legacy porting - use Fixed Rate Simple Manager when porting old code that assumed fixed framerate</p> </li> <li> <p>Custom update schedules - create custom system groups with specific rate managers for domain-specific timing needs</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Default timing is sufficient - don't add rate managers unnecessarily, most gameplay systems work fine in SimulationSystemGroup</p> </li> <li> <p>Need frame-synchronized logic - if system must run exactly once per rendered frame, avoid rate managers</p> </li> <li> <p>Simple prototypes - rate managers add complexity, use default groups for rapid prototyping</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/Rate%20Managers/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>World Update Allocator - use <code>state.WorldUpdateAllocator</code> for temporary allocations that auto-dispose:   <pre><code>var tempArray = CollectionHelper.CreateNativeArray&lt;int&gt;(100, state.WorldUpdateAllocator);\n</code></pre></p> </li> <li> <p>Configure fixed rate: <pre><code>var fixedGroup = world.GetExistingSystemManaged&lt;FixedStepSimulationSystemGroup&gt;();\nfixedGroup.Timestep = 1f / 50f; // Change to 50 Hz\n</code></pre></p> </li> <li> <p>Custom rate manager - implement <code>IRateManager</code> interface for custom update logic</p> </li> <li> <p>Default placement - systems without <code>[UpdateInGroup]</code> go to SimulationSystemGroup</p> </li> </ul>","tags":["system","advanced"]},{"location":"DOTS/Advanced/System%20Dependencies/","title":"System Dependencies","text":"","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#description","title":"Description","text":"<ul> <li> <p>Automatic job dependency management across systems - Unity ECS ensures jobs in different systems that access the same components are properly ordered to prevent race conditions</p> </li> <li> <p>Based on component dependency registry in <code>Unity.Entities.World</code> - tracks which jobs are reading/writing each component type</p> </li> <li> <p>Systems register component types they access (via EntityQuery, <code>GetComponentTypeHandle</code>, <code>GetComponentLookup</code>) and Unity automatically chains job dependencies</p> </li> <li> <p>SystemState.Dependency is the key mechanism - before OnUpdate gets dependencies for accessed components, after OnUpdate writes back final dependency</p> </li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#how-it-works","title":"How It Works","text":"<p>Component Dependency Registry: - Each <code>World</code> maintains a registry mapping component types to <code>JobHandle</code> - Initially all component dependencies are <code>default(JobHandle)</code> - Registry tracks both read-only (RO) and read-write (RW) access separately</p> <p>System Update Lifecycle:</p> <p>Before OnUpdate (BeforeUpdate): 1. System has registered component types it accesses (gathered in OnCreate or OnUpdate) 2. Unity gets <code>JobHandle</code> for each component type from registry 3. Combines all handles into one <code>JobHandle</code> 4. Assigns combined handle to <code>SystemState.Dependency</code></p> <p>During OnUpdate: 1. User schedules jobs using <code>SystemState.Dependency</code> as input dependency 2. Jobs return <code>JobHandle</code> which gets assigned back to <code>SystemState.Dependency</code> 3. All jobs implicitly depend on all previous systems that accessed same components</p> <p>After OnUpdate (AfterUpdate): 1. Final <code>SystemState.Dependency</code> is written back to component dependency registry 2. Now registry contains dependency on all jobs this system scheduled</p>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#example","title":"Example","text":"<pre><code>// System X reads components A and B\n[BurstCompile]\npublic partial struct SystemX : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // BeforeUpdate: state.Dependency = default (no prior dependencies)\n\n        state.Dependency = new ReadJob\n        {\n            ComponentA = SystemAPI.GetComponentTypeHandle&lt;ComponentA&gt;(true),\n            ComponentB = SystemAPI.GetComponentTypeHandle&lt;ComponentB&gt;(true)\n        }.ScheduleParallel(query, state.Dependency);\n\n        // AfterUpdate: Registry updated: A -&gt; SystemX.Dependency, B -&gt; SystemX.Dependency\n    }\n}\n\n// System Y writes component B - automatically waits for SystemX\n[UpdateAfter(typeof(SystemX))]\n[BurstCompile]\npublic partial struct SystemY : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // BeforeUpdate: state.Dependency = SystemX.Dependency\n        // (Unity automatically chains dependency because B was accessed)\n\n        state.Dependency = new WriteJob\n        {\n            ComponentB = SystemAPI.GetComponentTypeHandle&lt;ComponentB&gt;(false)\n        }.ScheduleParallel(query, state.Dependency);\n\n        // AfterUpdate: Registry updated: B -&gt; SystemY.Dependency\n    }\n}\n\n// System Z accesses different component - runs in parallel\n[BurstCompile]\npublic partial struct SystemZ : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // No dependency on SystemX or SystemY - different component\n        // Runs in PARALLEL with other systems!\n        foreach (var c in SystemAPI.Query&lt;RefRW&lt;ComponentC&gt;&gt;())\n            c.ValueRW.Value += 1;\n    }\n}\n</code></pre>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#component-registration","title":"Component Registration","text":"<p>Components are registered when system calls: - <code>SystemAPI.QueryBuilder().WithAll&lt;Health&gt;().Build()</code> - <code>SystemAPI.GetComponentTypeHandle&lt;Health&gt;()</code> - <code>SystemAPI.GetComponentLookup&lt;Health&gt;()</code> - <code>SystemAPI.Query&lt;RefRW&lt;Health&gt;&gt;()</code></p>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#pros","title":"Pros","text":"<ul> <li> <p>Automatic safety - no manual dependency tracking across systems, Unity handles it</p> </li> <li> <p>Prevents race conditions - jobs accessing same components are automatically ordered correctly</p> </li> <li> <p>Enables parallelization - systems accessing different components run jobs in parallel</p> </li> <li> <p>Simple API - just use <code>SystemState.Dependency</code>, Unity does the rest</p> </li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#cons","title":"Cons","text":"<ul> <li> <p>Hidden dependencies - not obvious from code what dependencies exist</p> </li> <li> <p>Can be confusing - requires understanding of how component registry works</p> </li> <li> <p>Over-conservative sometimes - may create dependencies that aren't strictly necessary</p> </li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#best-use","title":"Best use","text":"<ul> <li> <p>All ISystem implementations - dependency system is fundamental to ECS, always active</p> </li> <li> <p>Cross-system job coordination - ensures jobs in different systems don't conflict</p> </li> <li> <p>Performance optimization - enables parallel execution of independent systems</p> </li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#avoid-if","title":"Avoid if","text":"<ul> <li>N/A - system dependencies are built into Unity ECS, cannot be avoided</li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Always use state.Dependency - schedule jobs with it as input and assign result back:   <pre><code>state.Dependency = job.Schedule(state.Dependency);\n</code></pre></p> </li> <li> <p>Dependency combining - if scheduling multiple independent jobs:   <pre><code>JobHandle jobA = jobA.Schedule(state.Dependency);\nJobHandle jobB = jobB.Schedule(state.Dependency);\nstate.Dependency = JobHandle.CombineDependencies(jobA, jobB);\n</code></pre></p> </li> <li> <p>Read-only vs Read-write - registry separates RO and RW dependencies, allowing multiple readers in parallel but exclusive writers</p> </li> <li> <p>SystemAPI.Query auto-registers - using <code>SystemAPI.Query&lt;T&gt;()</code> automatically registers component T</p> </li> <li> <p>Per-component-type tracking - systems accessing different component types have no dependency relationship</p> </li> <li> <p>World-specific - each World has its own registry, dependencies don't cross worlds</p> </li> </ul>","tags":["advanced","systems"]},{"location":"DOTS/Advanced/System%20Dependencies/#practical-example-parallel-systems","title":"Practical Example: Parallel Systems","text":"<pre><code>// These three systems can run jobs in PARALLEL\n// because they access different components\n\n[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem  // Accesses: Health\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var health in SystemAPI.Query&lt;RefRW&lt;Health&gt;&gt;())\n            health.ValueRW.Current += 1;\n    }\n}\n\n[BurstCompile]\npublic partial struct MovementSystem : ISystem  // Accesses: Position, Velocity\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (pos, vel) in SystemAPI.Query&lt;RefRW&lt;Position&gt;, RefRO&lt;Velocity&gt;&gt;())\n            pos.ValueRW.Value += vel.ValueRO.Value;\n    }\n}\n\n[BurstCompile]\npublic partial struct DamageSystem : ISystem  // Accesses: Damage\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var damage in SystemAPI.Query&lt;RefRW&lt;Damage&gt;&gt;())\n            damage.ValueRW.Amount = 0;\n    }\n}\n\n// All three run in parallel - maximum CPU utilization!\n</code></pre>","tags":["advanced","systems"]},{"location":"DOTS/Attributes/","title":"Attributes","text":"<p>Attributes control system behavior, compilation, execution order, and access patterns in Unity DOTS. They're essential for performance optimization and correctness.</p>"},{"location":"DOTS/Attributes/#compilation-performance","title":"Compilation &amp; Performance","text":"<ul> <li>BurstCompile - Compiles systems and jobs to highly optimized native code (10-100x speedup)</li> </ul>"},{"location":"DOTS/Attributes/#system-ordering","title":"System Ordering","text":"<ul> <li>UpdateInGroup, UpdateBefore, UpdateAfter - Control when systems execute in the frame</li> <li><code>[UpdateInGroup(typeof(Group))]</code> - Place system in specific system group</li> <li><code>[UpdateBefore(typeof(System))]</code> - Run before another system</li> <li><code>[UpdateAfter(typeof(System))]</code> - Run after another system</li> </ul>"},{"location":"DOTS/Attributes/#system-optimization","title":"System Optimization","text":"<ul> <li>RequireMatchingQueriesForUpdate - Skip system execution when no entities match queries</li> <li>ChunkIndexInQuery - Provides sort key for deterministic EntityCommandBuffer.ParallelWriter</li> </ul>"},{"location":"DOTS/Attributes/#access-control","title":"Access Control","text":"<ul> <li>ReadOnly and Optional - Control component and lookup access patterns</li> <li><code>[ReadOnly]</code> - Mark lookups/buffers as read-only for parallel job safety</li> <li><code>[Optional]</code> - Mark aspect components as optional in queries</li> </ul>"},{"location":"DOTS/Attributes/#usage-patterns","title":"Usage Patterns","text":""},{"location":"DOTS/Attributes/#system-with-burst-and-ordering","title":"System with Burst and Ordering","text":"<pre><code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\n[UpdateAfter(typeof(PhysicsSystemGroup))]\n[BurstCompile]\npublic partial struct MySystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state) { }\n}\n</code></pre>"},{"location":"DOTS/Attributes/#job-with-parallel-entitycommandbuffer","title":"Job with Parallel EntityCommandBuffer","text":"<pre><code>public partial struct MyJob : IJobEntity\n{\n    public EntityCommandBuffer.ParallelWriter Ecb;\n\n    private void Execute(Entity entity, [ChunkIndexInQuery] int sortKey)\n    {\n        Ecb.DestroyEntity(sortKey, entity);\n    }\n}\n</code></pre>"},{"location":"DOTS/Attributes/#aspect-with-optional-component","title":"Aspect with Optional Component","text":"<pre><code>public readonly partial struct MyAspect : IAspect\n{\n    readonly RefRW&lt;Health&gt; _health;\n    [Optional] readonly RefRW&lt;Shield&gt; _shield;\n}\n</code></pre>"},{"location":"DOTS/Attributes/#best-practices","title":"Best Practices","text":"<ol> <li>Always use BurstCompile on systems and jobs for performance</li> <li>Use system ordering attributes to ensure correct execution order</li> <li>Mark read-only lookups with <code>[ReadOnly]</code> to enable parallelization</li> <li>Use ChunkIndexInQuery with ParallelWriter for determinism</li> <li>Add RequireMatchingQueriesForUpdate for systems that may have no work</li> </ol>"},{"location":"DOTS/Attributes/BurstCompile/","title":"BurstCompile","text":"","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#description","title":"Description","text":"<ul> <li> <p>Performance compilation attribute that compiles systems and jobs to highly optimized native code using the Burst compiler</p> </li> <li> <p>Applied to ISystem structs, job structs (IJobEntity, IJobChunk, etc.), and their methods for maximum performance</p> </li> <li> <p>Provides 10-100x performance improvement over standard C# through SIMD vectorization, optimizations, and removal of managed code overhead</p> </li> <li> <p>Requires code to be safe C# subset - no managed objects, garbage collection, or exceptions in Burst-compiled code</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#example","title":"Example","text":"<pre><code>// System with BurstCompile\n[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem\n{\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Burst-compiled initialization\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Burst-compiled update - runs at maximum performance\n        foreach (var (health, regen) in\n            SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;HealthRegen&gt;&gt;())\n        {\n            health.ValueRW.Current += regen.ValueRO.PointPerSec * SystemAPI.Time.DeltaTime;\n        }\n    }\n}\n\n// IJobEntity with BurstCompile\n[BurstCompile]\npublic partial struct ProjectileMoveJob : IJobEntity\n{\n    public float DeltaTime;\n    [ReadOnly] public ComponentLookup&lt;LocalToWorld&gt; Positions;\n\n    // Execute is automatically Burst-compiled when job struct has [BurstCompile]\n    private void Execute(ProjectileAspect projectile)\n    {\n        projectile.Move(DeltaTime, Positions);\n    }\n}\n\n// Burst options for fine-tuning\n[BurstCompile(CompileSynchronously = true)]  // Compile immediately (Editor only, for testing)\npublic partial struct DebugSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state) { }\n}\n\n[BurstCompile(FloatMode = FloatMode.Fast)]  // Faster but less precise math\npublic partial struct FastMathJob : IJobEntity\n{\n    private void Execute(ref Position pos, in Velocity vel) { }\n}\n</code></pre>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#pros","title":"Pros","text":"<ul> <li> <p>Massive performance gains - 10-100x faster than equivalent C# code for data processing</p> </li> <li> <p>SIMD auto-vectorization - compiler automatically uses CPU vector instructions (SSE, AVX, NEON)</p> </li> <li> <p>Zero garbage collection - no GC allocations or pauses, perfect for real-time gameplay</p> </li> <li> <p>Multi-platform optimization - generates optimal code for each target platform automatically</p> </li> <li> <p>Compile-time safety - errors if you use unsupported features (managed objects, exceptions)</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#cons","title":"Cons","text":"<ul> <li> <p>Restricted C# subset - can't use managed objects, strings, LINQ, exceptions, virtual calls</p> </li> <li> <p>Longer compile times - Burst compilation adds time to builds and domain reloads</p> </li> <li> <p>Debugging complexity - can be harder to debug than regular C#, though Unity provides Burst Inspector</p> </li> <li> <p>Learning curve - need to understand what's allowed/disallowed in Burst-compiled code</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#best-use","title":"Best use","text":"<ul> <li> <p>All ISystem systems - nearly always use <code>[BurstCompile]</code> on systems for maximum performance</p> </li> <li> <p>All jobs - IJobEntity, IJobChunk, ITriggerEventsJob should be Burst-compiled</p> </li> <li> <p>Performance-critical code - math-heavy, data transformation, AI pathfinding, physics queries</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Managed component access - systems using managed components with <code>SystemAPI.ManagedAPI</code> can't be fully Burst-compiled</p> </li> <li> <p>Debug logging in jobs - Burst doesn't support <code>Debug.Log</code> or exceptions, use in non-Burst code only</p> </li> <li> <p>Prototyping phase - during early prototyping, you might skip Burst for faster iteration, add later for performance</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/BurstCompile/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Required for ISystem - <code>ISystem</code> is designed for Burst, always use <code>[BurstCompile]</code> on the struct and all lifecycle methods (OnCreate, OnUpdate, OnDestroy)</p> </li> <li> <p>CompileSynchronously option - use <code>[BurstCompile(CompileSynchronously = true)]</code> in Editor for immediate compilation to test performance (build times increase, only for testing)</p> </li> <li> <p>Burst Inspector - use Window &gt; Burst &gt; Burst Inspector to see generated assembly code and verify optimizations</p> </li> <li> <p>Safety checks - Burst enables safety checks (bounds checking, null checks) by default in Editor, disabled in builds for maximum performance</p> </li> <li> <p>FloatMode options:</p> </li> <li><code>FloatMode.Default</code> - precise IEEE 754 compliance</li> <li><code>FloatMode.Fast</code> - faster math, less precise (allows optimizations like reciprocal approximations)</li> <li> <p><code>FloatMode.Strict</code> - strictest IEEE compliance</p> </li> <li> <p>OptimizeFor option - use <code>OptimizeFor.FastCompilation</code> to speed up iteration in Editor, <code>OptimizeFor.Performance</code> for final builds (default)</p> </li> <li> <p>Allowed in Burst:</p> </li> <li>Blittable types (primitives, structs with primitives)</li> <li>IComponentData, DynamicBuffer, BlobAsset</li> <li>Math operations (Unity.Mathematics)</li> <li>NativeArray, NativeList, and other native collections</li> <li> <p>ComponentLookup/BufferLookup</p> </li> <li> <p>Not allowed in Burst:</p> </li> <li>Managed objects (class instances, strings)</li> <li>Garbage collection allocations</li> <li>Exceptions (try/catch/throw)</li> <li>Virtual method calls</li> <li><code>Debug.Log</code> (use Burst-compatible logging alternatives)</li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/","title":"ChunkIndexInQuery","text":"","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#description","title":"Description","text":"<ul> <li> <p>Job parameter attribute that provides the current chunk's index in the query, used as a sort key for EntityCommandBuffer.ParallelWriter</p> </li> <li> <p>Applied to an <code>int</code> parameter in IJobEntity.Execute or IJobChunk jobs to receive the unique chunk index (0, 1, 2, ...)</p> </li> <li> <p>Critical for deterministic parallel command buffer playback - ensures commands from parallel jobs execute in consistent order</p> </li> <li> <p>Without this attribute, parallel EntityCommandBuffer commands may execute in random order, causing non-deterministic behavior</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct KillSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        var ecbSingleton = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;();\n        EntityCommandBuffer ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);\n\n        new KillJob\n        {\n            Ecb = ecb.AsParallelWriter()  // ParallelWriter for parallel jobs\n        }.ScheduleParallel();\n    }\n}\n\n[BurstCompile]\npublic partial struct KillJob : IJobEntity\n{\n    public EntityCommandBuffer.ParallelWriter Ecb;\n\n    // [ChunkIndexInQuery] provides the sort key for deterministic ordering\n    private void Execute(Entity entity, [ChunkIndexInQuery] int sortKey, in Health health)\n    {\n        if (health.Current &lt;= 0)\n        {\n            // sortKey ensures commands execute in consistent chunk order\n            Ecb.DestroyEntity(sortKey, entity);\n        }\n    }\n}\n\n// IJobChunk example\n[BurstCompile]\npublic partial struct LimitedLifeTimeJob : IJobChunk\n{\n    public EntityCommandBuffer.ParallelWriter Ecb;\n    public EntityTypeHandle EntityType;\n    public ComponentTypeHandle&lt;LimitedLifeTime&gt; LifeTimeType;\n\n    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)\n    {\n        // unfilteredChunkIndex is the equivalent of [ChunkIndexInQuery]\n        NativeArray&lt;Entity&gt; entities = chunk.GetNativeArray(EntityType);\n        NativeArray&lt;LimitedLifeTime&gt; lifeTimes = chunk.GetNativeArray(ref LifeTimeType);\n\n        for (int i = 0; i &lt; chunk.Count; i++)\n        {\n            if (lifeTimes[i].TimeLeft &lt;= 0)\n            {\n                // Use unfilteredChunkIndex as sort key\n                Ecb.DestroyEntity(unfilteredChunkIndex, entities[i]);\n            }\n        }\n    }\n}\n</code></pre>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#pros","title":"Pros","text":"<ul> <li> <p>Deterministic execution - commands execute in same order every frame, preventing randomness bugs</p> </li> <li> <p>Thread-safe parallel writes - enables safe parallel command buffer writes from multiple threads</p> </li> <li> <p>No performance cost - chunk index is already known during iteration, no extra computation</p> </li> <li> <p>Required for parallel ECB - without it, ParallelWriter commands are non-deterministic</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#cons","title":"Cons","text":"<ul> <li> <p>Easy to forget - forgetting this attribute on parallel ECB jobs causes subtle non-determinism bugs</p> </li> <li> <p>Must pass to ECB methods - requires passing sortKey to every ParallelWriter method call</p> </li> <li> <p>Not needed for single-threaded - if using <code>.Schedule()</code> instead of <code>.ScheduleParallel()</code>, attribute is unnecessary</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#best-use","title":"Best use","text":"<ul> <li> <p>Parallel EntityCommandBuffer - always use with ParallelWriter when scheduling jobs with <code>.ScheduleParallel()</code></p> </li> <li> <p>Deterministic spawning/destruction - ensuring enemies spawn or die in consistent order</p> </li> <li> <p>Multiplayer/replay systems - critical for determinism in networked games or replay systems</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Single-threaded jobs - if using <code>.Schedule()</code> instead of <code>.ScheduleParallel()</code>, regular EntityCommandBuffer doesn't need sort keys</p> </li> <li> <p>Main thread ECB - when using ECB directly in system OnUpdate (not in a job), no sort key needed</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ChunkIndexInQuery/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ParallelWriter requirement - <code>EntityCommandBuffer.ParallelWriter</code> methods require <code>int sortKey</code> as first parameter - this is what [ChunkIndexInQuery] provides</p> </li> <li> <p>Unique per chunk - sort key is unique per chunk being processed, not per entity - multiple entities in same chunk get same sort key</p> </li> <li> <p>Playback order - ECB plays back commands sorted by sort key first, then by order within that key</p> </li> <li> <p>IJobEntity vs IJobChunk - in IJobEntity use <code>[ChunkIndexInQuery] int sortKey</code> parameter, in IJobChunk use the <code>unfilteredChunkIndex</code> parameter (it's the same thing)</p> </li> <li> <p>Multiple ECB fields - if job has multiple ParallelWriters, same sort key is used for all of them</p> </li> <li> <p>Name doesn't matter - can name the parameter anything (<code>sortKey</code>, <code>chunkIndex</code>, <code>key</code>), attribute determines its value</p> </li> <li> <p>Why determinism matters - without deterministic ordering, entity creation/destruction order changes, IDs change, iteration order changes, causing different results each run</p> </li> <li> <p>Testing determinism - run game multiple times with same inputs - results should be identical if you use [ChunkIndexInQuery] correctly</p> </li> <li> <p>Combine with entity ID - for even finer sorting, can combine sort key with entity index: <code>(sortKey &lt;&lt; 32) | entityIndexInQuery</code></p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/","title":"ReadOnly and Optional","text":"","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#description","title":"Description","text":"<ul> <li> <p>Access control attributes used in jobs and aspects to specify component access patterns</p> </li> <li> <p><code>[ReadOnly]</code> marks ComponentLookup/BufferLookup, <code>DynamicBuffer</code>, or native collections as read-only, enabling parallel job execution without race conditions</p> </li> <li> <p><code>[Optional]</code> marks aspect component fields as optional - query matches entities even if optional component is missing</p> </li> <li> <p>Both attributes improve job scheduling efficiency and provide flexibility in component queries</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#example","title":"Example","text":"<pre><code>// [ReadOnly] on lookups - enables parallel job execution\n[BurstCompile]\npublic partial struct ProjectileMoveJob : IJobEntity\n{\n    [ReadOnly] public ComponentLookup&lt;LocalToWorld&gt; Positions;  // Multiple threads can read\n\n    private void Execute(ref LocalTransform transform, in Target target)\n    {\n        if (Positions.HasComponent(target.Entity))\n        {\n            float3 targetPos = Positions[target.Entity].Position;\n            // ... use target position\n        }\n    }\n}\n\n// [Optional] in aspects - component not required for query match\npublic readonly partial struct CharacterAspect : IAspect\n{\n    readonly RefRW&lt;LocalTransform&gt; _transform;  // Required\n    readonly RefRW&lt;Health&gt; _health;             // Required\n    [Optional] readonly RefRW&lt;Shield&gt; _shield;  // Optional\n\n    public void TakeDamage(float damage)\n    {\n        if (_shield.IsValid)  // Check before accessing optional component\n        {\n            _shield.ValueRW.Amount -= damage;\n            if (_shield.ValueRO.Amount &gt; 0)\n                return;  // Shield absorbed damage\n            damage = -_shield.ValueRO.Amount;  // Overflow damage\n        }\n        _health.ValueRW.Current -= damage;\n    }\n}\n</code></pre>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#pros","title":"Pros","text":"<ul> <li> <p>[ReadOnly] enables parallelization - multiple threads can safely read same data, improving performance</p> </li> <li> <p>[ReadOnly] prevents bugs - compile-time error if you try to write to read-only data</p> </li> <li> <p>[Optional] increases query flexibility - one aspect/query can match entities with or without optional components</p> </li> <li> <p>[Optional] reduces code duplication - don't need separate systems/aspects for entities with/without optional components</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#cons","title":"Cons","text":"<ul> <li> <p>[ReadOnly] prevents writes - can't modify data marked as read-only, need separate read-write access if needed</p> </li> <li> <p>[Optional] requires null checks - must check <code>.IsValid</code> before accessing optional fields, easy to forget</p> </li> <li> <p>[Optional] limited to aspects - can't use on regular query parameters, only in IAspect fields</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#best-use","title":"Best use","text":"<ul> <li> <p>[ReadOnly] on lookups - always mark read-only lookups with <code>[ReadOnly]</code> for parallel job safety</p> </li> <li> <p>[ReadOnly] on shared data - when multiple jobs need to read same reference data (configuration, target positions, etc.)</p> </li> <li> <p>[Optional] for optional gameplay features - shields, buffs, special abilities that not all characters have</p> </li> <li> <p>[Optional] for progressive upgrades - components added over time (armor, weapons, perks)</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Need to write data - don't use <code>[ReadOnly]</code> if you need to modify the data (use read-write access)</p> </li> <li> <p>Component is required - don't use <code>[Optional]</code> if component must always be present (defeats type safety)</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/ReadOnly%20and%20Optional/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ComponentLookup creation - <code>SystemAPI.GetComponentLookup&lt;T&gt;(true)</code> creates read-only lookup, <code>(false)</code> creates read-write</p> </li> <li> <p>[Optional] with RefRO/RefRW - can use on either <code>RefRO&lt;T&gt;</code> or <code>RefRW&lt;T&gt;</code>, check <code>.IsValid</code> property before accessing</p> </li> <li> <p>[Optional] DynamicBuffer - can mark DynamicBuffer as optional in aspects, check <code>.IsValid</code> before accessing</p> </li> <li> <p>Job dependency tracking - Unity's job system uses <code>[ReadOnly]</code> to automatically track dependencies and schedule jobs efficiently</p> </li> <li> <p>Multiple [ReadOnly] fields - can have unlimited <code>[ReadOnly]</code> lookups in a job, all can be accessed in parallel safely</p> </li> <li> <p>Native collections - <code>[ReadOnly]</code> also works on NativeArray, NativeList, NativeHashMap when passed to jobs</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/","title":"RequireMatchingQueriesForUpdate","text":"","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#description","title":"Description","text":"<ul> <li> <p>System optimization attribute that prevents system <code>OnUpdate</code> from running unless the system's queries match at least one Entity</p> </li> <li> <p>Applied to ISystem to automatically disable the system when no entities exist matching its queries</p> </li> <li> <p>Replaces manual <code>RequireForUpdate&lt;ComponentType&gt;()</code> calls for simple cases - Unity analyzes all queries in OnUpdate and only runs system if matches exist</p> </li> <li> <p>Improves performance by skipping systems that have no work to do, avoiding unnecessary overhead</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#example","title":"Example","text":"<pre><code>// Without RequireMatchingQueriesForUpdate - runs every frame even if no entities\n[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // This runs every frame, even if no entities have Velocity\n        foreach (var (transform, velocity) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;())\n        {\n            transform.ValueRW.Position += velocity.ValueRO.Value * SystemAPI.Time.DeltaTime;\n        }\n        // If no entities match query, loop body never executes but system still ran\n    }\n}\n\n// With RequireMatchingQueriesForUpdate - skips OnUpdate if no matching entities\n[RequireMatchingQueriesForUpdate]\n[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // This only runs if at least one entity has Velocity + LocalTransform\n        foreach (var (transform, velocity) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;())\n        {\n            transform.ValueRW.Position += velocity.ValueRO.Value * SystemAPI.Time.DeltaTime;\n        }\n    }\n}\n\n// Example with initialization query - system with companion GameObjects\n[RequireMatchingQueriesForUpdate]\n[BurstCompile]\npublic partial struct PresentationGoInitialisationSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Only runs when new entities with PresentationGo + no PresentationGoCleanup exist\n        foreach (var (presentationGo, entity) in\n            SystemAPI.Query&lt;PresentationGo&gt;()\n            .WithNone&lt;PresentationGoCleanup&gt;()\n            .WithEntityAccess())\n        {\n            // Instantiate GameObject companion\n            GameObject instance = Object.Instantiate(presentationGo.Prefab);\n            state.EntityManager.AddComponentObject(entity, new PresentationGoCleanup\n            {\n                Instance = instance\n            });\n        }\n    }\n}\n</code></pre>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#pros","title":"Pros","text":"<ul> <li> <p>Automatic optimization - no manual <code>RequireForUpdate</code> calls needed for simple cases</p> </li> <li> <p>Performance improvement - systems skip entirely when no matching entities, saving CPU time</p> </li> <li> <p>Clean code - one attribute instead of multiple <code>RequireForUpdate</code> calls in OnCreate</p> </li> <li> <p>Query-based - automatically analyzes all queries in OnUpdate, no need to manually specify components</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#cons","title":"Cons","text":"<ul> <li> <p>All queries must match - if you have multiple queries, system only runs if ALL have matches (AND condition, not OR)</p> </li> <li> <p>Doesn't work with manual queries - only works with queries created in OnUpdate, not queries stored as system fields</p> </li> <li> <p>Less flexible - for complex conditions (OR logic, singleton checks), manual <code>RequireForUpdate</code> is better</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#best-use","title":"Best use","text":"<ul> <li> <p>Simple entity processing systems - when system has one or two queries and should skip if no entities match</p> </li> <li> <p>Initialization systems - systems that only run when new entities with specific components appear</p> </li> <li> <p>Performance optimization - when you have many systems that may have no work some frames (enemy AI when no enemies, projectile systems when no projectiles)</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Complex update conditions - if system should run based on singleton existence, OR conditions, or multiple independent queries</p> </li> <li> <p>Manual EntityQuery fields - if storing queries as system fields and using them across multiple methods</p> </li> <li> <p>Needs to run every frame - if system must always run (input processing, time tracking, etc.) don't use this attribute</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/RequireMatchingQueriesForUpdate/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Combines with manual RequireForUpdate - you can use both <code>[RequireMatchingQueriesForUpdate]</code> AND manual <code>state.RequireForUpdate&lt;T&gt;()</code> calls - system runs only if both conditions are satisfied</p> </li> <li> <p>Singleton requirements - common pattern: <code>[RequireMatchingQueriesForUpdate]</code> for entity queries + manual <code>state.RequireForUpdate&lt;SingletonComponent&gt;()</code> for singleton checks in OnCreate</p> </li> <li> <p>SystemAPI.Query only - attribute analyzes <code>SystemAPI.Query&lt;T&gt;()</code> calls in OnUpdate, doesn't analyze manual EntityQuery fields or queries created in OnCreate</p> </li> <li> <p>Multiple queries = AND logic - if OnUpdate has multiple different queries, system runs only if ALL queries have at least one match</p> </li> <li> <p>Performance measurement - use Unity Profiler to verify systems are being skipped - look for systems not appearing in frame when no entities match</p> </li> <li> <p>WithNone/WithAll patterns - attribute respects query filters like <code>.WithNone&lt;T&gt;()</code> and <code>.WithAll&lt;T&gt;()</code> when determining if queries match</p> </li> <li> <p>ISystemStartStop alternative - if you need more complex enable/disable logic, implement <code>ISystemStartStop</code> interface (OnStartRunning/OnStopRunning callbacks)</p> </li> <li> <p>Default behavior - without this attribute, systems run every frame regardless of whether queries match, only the query loop body is skipped</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/","title":"UpdateInGroup, UpdateBefore, UpdateAfter","text":"","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#description","title":"Description","text":"<ul> <li> <p>System ordering attributes that control when systems execute relative to other systems in the frame update loop</p> </li> <li> <p><code>[UpdateInGroup(typeof(GroupType))]</code> places a system inside a specific system group (InitializationSystemGroup, SimulationSystemGroup, PresentationSystemGroup, etc.)</p> </li> <li> <p><code>[UpdateBefore(typeof(SystemType))]</code> and <code>[UpdateAfter(typeof(SystemType))]</code> create execution order constraints relative to other systems</p> </li> <li> <p>Essential for deterministic execution order - physics before movement, movement before rendering, spawning before AI processing, etc.</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#example","title":"Example","text":"<pre><code>// Fixed timestep physics\n[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\n[BurstCompile]\npublic partial struct SpawnerSystem : ISystem { }\n\n// After transforms computed\n[UpdateAfter(typeof(TransformSystemGroup))]\n[BurstCompile]\npublic partial struct ProjectileMoveSystem : ISystem { }\n\n// Before another system\n[UpdateBefore(typeof(TowerPlacementSystem))]\n[BurstCompile]\npublic partial struct InputSystem : ISystem { }\n\n// After physics simulation\n[UpdateInGroup(typeof(AfterPhysicsSystemGroup))]\n[BurstCompile]\npublic partial struct EnemyPlayerCollisionSystem : ISystem { }\n\n// Combining multiple ordering attributes\n[UpdateInGroup(typeof(SimulationSystemGroup))]\n[UpdateAfter(typeof(MovementSystem))]\n[UpdateBefore(typeof(AnimationSystem))]\n[BurstCompile]\npublic partial struct CombatSystem : ISystem { }\n</code></pre>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#pros","title":"Pros","text":"<ul> <li> <p>Deterministic order - guarantees consistent execution order across frames and builds</p> </li> <li> <p>Explicit dependencies - code clearly shows which systems depend on others</p> </li> <li> <p>Frame structure control - organize systems into logical phases (input \u2192 simulation \u2192 rendering)</p> </li> <li> <p>Fixed timestep support - <code>FixedStepSimulationSystemGroup</code> enables physics-style fixed update rate</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#cons","title":"Cons","text":"<ul> <li> <p>Circular dependencies - can create circular ordering constraints that cause errors</p> </li> <li> <p>Maintenance overhead - adding new systems requires thinking about ordering</p> </li> <li> <p>Group hierarchy complexity - nested system groups can be hard to reason about</p> </li> <li> <p>Implicit dependencies - easy to forget to add ordering attributes and get subtle bugs</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#best-use","title":"Best use","text":"<ul> <li> <p>Physics integration - use <code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]</code> for physics, <code>[UpdateInGroup(typeof(AfterPhysicsSystemGroup))]</code> for collision response</p> </li> <li> <p>Transform dependencies - use <code>[UpdateAfter(typeof(TransformSystemGroup))]</code> when you need final world positions</p> </li> <li> <p>Spawner/destroyer ordering - spawners UpdateBefore systems that use spawned entities, destroyers UpdateAfter systems that reference entities</p> </li> <li> <p>Input \u2192 Logic \u2192 Rendering - input systems UpdateBefore gameplay logic, gameplay UpdateBefore presentation/rendering</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>No dependencies - if execution order doesn't matter, don't add attributes (reduces coupling)</p> </li> <li> <p>Default ordering is sufficient - systems within a group run in creation order by default, sometimes that's enough</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Attributes/UpdateInGroup%2C%20UpdateBefore%2C%20UpdateAfter/#extra-tip","title":"Extra tip","text":"<ul> <li>Common system groups:</li> <li><code>InitializationSystemGroup</code> - runs first, initialization and setup</li> <li><code>SimulationSystemGroup</code> - main gameplay logic (default if no [UpdateInGroup])</li> <li><code>FixedStepSimulationSystemGroup</code> - fixed timestep updates (physics, deterministic simulation) - uses Fixed Rate Catch-Up Manager at 60 Hz</li> <li><code>VariableRateSimulationSystemGroup</code> - low-frequency updates using real time - uses Variable Rate Manager at 15 FPS (good for cleanup, non-critical background tasks)</li> <li><code>LateSimulationSystemGroup</code> - runs after [[TransformSystemGroup]], use when you need final world positions</li> <li><code>PresentationSystemGroup</code> - rendering and presentation, runs last</li> <li><code>AfterPhysicsSystemGroup</code> - runs after physics simulation (trigger/collision processing)</li> <li><code>TransformSystemGroup</code> - computes LocalToWorld from LocalTransform + Parent hierarchy</li> <li> <p><code>BeginSimulationEntityCommandBufferSystem</code>, <code>EndSimulationEntityCommandBufferSystem</code> - EntityCommandBuffer playback points</p> </li> <li> <p>Default group - systems without <code>[UpdateInGroup]</code> default to <code>SimulationSystemGroup</code></p> </li> <li> <p>Nested groups - SimulationSystemGroup structure:   <pre><code>SimulationSystemGroup (every frame)\n  \u251c\u2500 FixedStepSimulationSystemGroup (fixed 60 Hz)\n  \u251c\u2500 VariableRateSimulationSystemGroup (variable ~15 FPS)\n  \u2514\u2500 LateSimulationSystemGroup (after transforms)\n</code></pre></p> </li> <li> <p>OrderFirst/OrderLast - <code>[UpdateInGroup(typeof(Group), OrderFirst = true)]</code> or <code>OrderLast = true</code> runs at start/end of group</p> </li> <li>Never set both to true - creates undefined behavior</li> <li>Creates three priority brackets: OrderFirst \u2192 default \u2192 OrderLast</li> <li> <p><code>[UpdateBefore]</code>/<code>[UpdateAfter]</code> only work within same priority bracket</p> </li> <li> <p>Creation order - within a group without explicit ordering, systems update in file/class creation order</p> </li> <li> <p>Rate managers - see Rate Managers for how system groups control update frequency and SystemAPI.Time for time perception</p> </li> <li> <p>Debugging - enable \"DOTS &gt; Preferences &gt; Show System Execution Order\" to visualize update sequence</p> </li> <li> <p>Fixed timestep config - <code>FixedStepSimulationSystemGroup.Timestep</code> controls fixed update rate (default 0.0166f = ~60 Hz)</p> </li> </ul>","tags":["attribute"]},{"location":"DOTS/Baking/","title":"Baking","text":"<p>Baking is Unity DOTS' authoring workflow that converts GameObject-based scene data into optimized ECS runtime data. It happens automatically in Edit mode and provides instant feedback when you modify GameObjects.</p>"},{"location":"DOTS/Baking/#core-concepts","title":"Core Concepts","text":"<ul> <li>Baker - Conversion class that transforms authoring data to runtime components <li>TransformUsageFlags - Controls which transform components are added during baking</li> <li>Baking (Glossary) - Overview of the baking process</li>"},{"location":"DOTS/Baking/#how-baking-works","title":"How Baking Works","text":"<ol> <li>You create a MonoBehaviour authoring component on a GameObject in the Editor</li> <li>You define a Baker class that specifies the conversion logic <li>Unity runs the baker in a separate baking world during Edit mode</li> <li>Changes to GameObjects trigger automatic incremental rebaking</li> <li>The result is optimized Entity + Components in the runtime world</li>"},{"location":"DOTS/Baking/#key-features","title":"Key Features","text":"<ul> <li>Automatic - Runs whenever you modify GameObjects in Edit mode</li> <li>Incremental - Only rebakes affected entities, not the entire scene</li> <li>Dependency tracking - Tracks asset references and rebakes when they change</li> <li>Efficient - Converts Unity-friendly authoring data to cache-friendly runtime format</li> </ul>"},{"location":"DOTS/Baking/#common-patterns","title":"Common Patterns","text":"<pre><code>public class MyAuthoring : MonoBehaviour\n{\n    public float Speed;\n\n    public class Baker : Baker&lt;MyAuthoring&gt;\n    {\n        public override void Bake(MyAuthoring authoring)\n        {\n            Entity entity = GetEntity(TransformUsageFlags.Dynamic);\n            AddComponent(entity, new Speed { Value = authoring.Speed });\n        }\n    }\n}\n</code></pre>"},{"location":"DOTS/Baking/#best-practices","title":"Best Practices","text":"<ol> <li>Use correct TransformUsageFlags to minimize components</li> <li>Use BlobAssets for shared read-only configuration</li> <li>Track dependencies with DependsOn() for assets</li> <li>Separate authoring data from runtime data for optimal performance</li> </ol>"},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/","title":"Baker (authoring conversion)","text":"","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#description","title":"Description","text":"<ul> <li> <p>Conversion system that transforms GameObject authoring data into ECS entities and components during the baking process</p> </li> <li> <p>Defined as nested class <code>Baker&lt;T&gt;</code> inside a MonoBehaviour authoring component, with <code>Bake(T authoring)</code> method performing the conversion</p> </li> <li> <p>Runs in a separate baking world, not the runtime world - changes to GameObject trigger automatic rebaking in Edit mode</p> </li> <li> <p>Provides methods like <code>GetEntity()</code>, <code>AddComponent()</code>, <code>AddBuffer()</code>, and <code>DependsOn()</code> for entity creation and dependency tracking</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#example","title":"Example","text":"<pre><code>public class DamageableAuthoring : MonoBehaviour\n{\n    public float MaxHealth;\n    public float HealthRegenPerSec;\n\n    public class Baker : Baker&lt;DamageableAuthoring&gt;\n    {\n        public override void Bake(DamageableAuthoring authoring)\n        {\n            // Get or create entity for this GameObject\n            // TransformUsageFlags determines what transform components to add\n            Entity entity = GetEntity(TransformUsageFlags.None);\n\n            // Add components with authoring data\n            AddComponent(entity, new Health\n            {\n                Max = authoring.MaxHealth,\n                Current = authoring.MaxHealth / 2f\n            });\n\n            AddComponent(entity, new HealthRegen\n            {\n                PointPerSec = authoring.HealthRegenPerSec\n            });\n        }\n    }\n}\n\n// Advanced example with prefabs and buffers\npublic class SpawnerAuthoring : MonoBehaviour\n{\n    public GameObject EnemyPrefab;\n    public float SpawnRate;\n\n    public class Baker : Baker&lt;SpawnerAuthoring&gt;\n    {\n        public override void Bake(SpawnerAuthoring authoring)\n        {\n            Entity entity = GetEntity(TransformUsageFlags.Dynamic);\n\n            // Convert prefab GameObject to Entity\n            Entity prefabEntity = GetEntity(authoring.EnemyPrefab, TransformUsageFlags.Dynamic);\n\n            AddComponent(entity, new SpawnerData\n            {\n                Prefab = prefabEntity,\n                SpawnRate = authoring.SpawnRate\n            });\n\n            // Add dynamic buffer\n            DynamicBuffer&lt;SpawnPoint&gt; buffer = AddBuffer&lt;SpawnPoint&gt;(entity);\n            buffer.Add(new SpawnPoint { Position = float3.zero });\n        }\n    }\n}\n</code></pre>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#pros","title":"Pros","text":"<ul> <li> <p>Automatic rebaking - changes to GameObject in Edit mode trigger rebake, instant feedback</p> </li> <li> <p>Incremental baking - only affected entities rebake when changes occur, not the entire scene</p> </li> <li> <p>Dependency tracking - <code>DependsOn(asset)</code> ensures rebake when referenced assets change</p> </li> <li> <p>Clean separation - authoring data (GameObjects) stays separate from runtime data (Entities)</p> </li> <li> <p>Type safety - compile-time checks ensure components are properly configured</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#cons","title":"Cons","text":"<ul> <li> <p>Separate world - baking happens in baking world, can't access runtime world data</p> </li> <li> <p>No runtime conversion - baking is edit-time only, runtime GameObject spawning requires different approach</p> </li> <li> <p>Learning curve - requires understanding TransformUsageFlags and baking workflow</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#best-use","title":"Best use","text":"<ul> <li> <p>Scene authoring - converting GameObjects placed in scenes to ECS entities</p> </li> <li> <p>Prefab conversion - baking GameObject prefabs into Entity prefabs for runtime spawning</p> </li> <li> <p>Complex data transformation - converting Unity-friendly authoring format to performance-optimized runtime format (e.g., BlobAssets)</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Runtime GameObject conversion - for converting spawned GameObjects at runtime, use different approach (managed components or direct entity creation)</p> </li> <li> <p>Simple data - if data is already in optimal format and doesn't need transformation, direct entity creation may be simpler</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baker%20%28authoring%20conversion%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>TransformUsageFlags - choose correct flags: <code>None</code> (no transform), <code>Renderable</code> (LocalToWorld), <code>Dynamic</code> (LocalToWorld + LocalTransform), <code>WorldSpace</code> (static, no parent)</p> </li> <li> <p>GetEntity variants - <code>GetEntity(TransformUsageFlags)</code> for self, <code>GetEntity(GameObject, TransformUsageFlags)</code> for other GameObjects (prefabs, references)</p> </li> <li> <p>Multiple bakers - multiple Baker classes can bake the same GameObject, each adding different components</p> </li> <li> <p>BlobAsset pattern - use <code>BlobBuilder</code> in Baker to create BlobAssets, then <code>AddBlobAsset(ref bar, out hash)</code> to store efficiently</p> </li> <li> <p>DependsOn - call <code>DependsOn(asset)</code> to track asset dependencies, ensuring rebake when Texture, Material, ScriptableObject, etc. changes</p> </li> <li> <p>AddComponentObject - use for adding managed components during baking</p> </li> <li> <p>Primary entity - <code>GetEntity()</code> gets the \"primary\" entity for the GameObject, additional entities can be created with <code>CreateAdditionalEntity()</code></p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/","title":"Baking Workflow and SubScenes","text":"","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#description","title":"Description","text":"<ul> <li> <p>Editor-time conversion process that transforms GameObject scenes and prefabs into optimized binary entity data files</p> </li> <li> <p>Runs in separate worker Unity instances for builds, or in main Editor instance for live-baking (instant preview)</p> </li> <li> <p>Incremental and automatic - only rebakes when changes detected to scene, prefabs, code assemblies, or dependent assets</p> </li> <li> <p>SubScene is the primary way to organize baked content - binary asset loaded at runtime via streaming system</p> </li> </ul>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#how-baking-works","title":"How Baking Works","text":"<p>Key Facts: - Editor-only - baking happens during authoring, not at runtime - Worker instances - builds use separate Unity processes for parallel baking - Live-baking - opening SubScene checkbox in Hierarchy triggers instant preview in Editor - Binary output - creates optimized entity data file (not human-readable) - Streaming-based loading - SubScenes load asynchronously at runtime (requires at least 1 frame)</p> <p>What Triggers Rebaking: 1. SubScene content changes - modifying GameObjects, components, or hierarchy 2. Code changes - modifying Baker code or component definitions 3. Assembly changes - recompiling assemblies with baking or component code 4. Asset dependencies - changes to assets referenced via <code>DependsOn(UnityEngine.Object)</code></p> <p>What DOESN'T Trigger Rebaking: - Runtime changes to entities (entities are runtime copies, not linked to baked data) - Changes to unrelated assets - Domain reloads without code changes affecting baking</p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#workflow-diagrams","title":"Workflow Diagrams","text":"","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#editor-startup-workflow","title":"Editor Startup Workflow","text":"<pre><code>1. User opens project\n   \u2193\n2. Domain reload dirties all SubScenes\n   \u2193\n3. SubSceneImporter runs in SEPARATE worker Unity Editor instance\n   \u251c\u2500 Creates baking world\n   \u251c\u2500 Runs all Bakers\n   \u2514\u2500 Generates binary asset file\n   \u2193\n4. Streaming system asynchronously loads binary asset\n   \u2193\n5. Deserializes entities into Editor world\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#live-baking-workflow","title":"Live-Baking Workflow","text":"<pre><code>1. User checks \"Open\" on SubScene in Hierarchy\n   \u2193\n2. Baking runs in MAIN Editor instance (not worker)\n   \u251c\u2500 Creates temporary baking world\n   \u251c\u2500 Runs all Bakers immediately\n   \u2514\u2500 Injects baked entities into Editor world\n   \u2193\n3. User modifies GameObject \u2192 Incremental rebaking instantly updates entities\n</code></pre> <p>Live-Baking Limitations: - \u274c Behavior cannot be reproduced in builds without custom code - \u274c Entities injected before systems created - may cause initialization issues - \u2705 Best for authoring and quick iteration</p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#play-mode-workflow","title":"Play Mode Workflow","text":"<pre><code>1. User enters Play Mode\n   \u2193\n2. Streaming system scans scenes for SubScene MonoBehaviours\n   \u2193\n3. Locates existing SubScene binary assets\n   \u2193\n4. Asynchronously loads binary (takes 1+ frames)\n   \u2193\n5. Deserializes entities into play mode world\n</code></pre> <p>Important: SubScene streaming is asynchronous, entities won't appear immediately</p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#build-workflow","title":"Build Workflow","text":"","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#build-process","title":"Build Process","text":"<pre><code>1. Build starts\n   \u2193\n2. Unity scans scenes for SubScene MonoBehaviours\n   \u2193\n3. Collects list of referenced SubScenes\n   \u2193\n4. Bakes all SubScenes in parallel (worker instances)\n   \u2193\n5. Scans for weak references (EntitySceneReference, EntityPrefabReference)\n   \u2193\n6. Repeats until no new references\n   \u2193\n7. Generates content archives (asset bundling)\n   \u251c\u2500 Groups assets to minimize duplication\n   \u2514\u2500 Ensures SubScenes only load what they need\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#runtime-loading-build","title":"Runtime Loading (Build)","text":"<pre><code>1. Game starts \u2192 Scene with SubScene loads\n   \u2193\n2. Streaming system detects SubScene request\n   \u2193\n3. Loads SubScene binary + required content archives (async, 1+ frames)\n   \u2193\n4. Entities appear in world\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#content-archives","title":"Content Archives","text":"<p>Automatic Archive Generation: Unity creates content archives during build, optimized for ECS.</p> <p>Archive Layout Example: <pre><code>SubScene A: Mesh1, Mesh2, Texture1\nSubScene B: Mesh2, Texture1, Texture2\n\nGenerated Archives:\n\u251c\u2500 Archive 1: [Mesh1] - only A\n\u251c\u2500 Archive 2: [Mesh2, Texture1] - shared by A and B\n\u2514\u2500 Archive 3: [Texture2] - only B\n\nBenefits: No duplicates, SubScenes only load dependencies, shared assets loaded once\n</code></pre></p> <p>Weak References: <pre><code>public struct LevelData : IComponentData\n{\n    public EntitySceneReference NextLevel;  // Weak reference\n}\n\npublic struct Spawner : IComponentData\n{\n    public EntityPrefabReference EnemyPrefab;  // Weak reference\n}\n</code></pre> Build system scans for these and includes referenced content automatically.</p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#baker-dependency-tracking","title":"Baker Dependency Tracking","text":"<pre><code>public class CharacterAuthoring : MonoBehaviour\n{\n    public Texture2D CharacterTexture;\n\n    public class Baker : Baker&lt;CharacterAuthoring&gt;\n    {\n        public override void Bake(CharacterAuthoring authoring)\n        {\n            // Track dependency - rebake if texture changes\n            DependsOn(authoring.CharacterTexture);\n\n            // If CharacterTexture modified:\n            // 1. AssetDatabase detects change\n            // 2. SubScene marked dirty\n            // 3. Rebaking triggered on next load/play\n        }\n    }\n}\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#subscene-loading-patterns","title":"SubScene Loading Patterns","text":"","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#auto-load-default","title":"Auto-Load (Default)","text":"<pre><code>SubScene with \"Auto Load\" enabled\n\u2514\u2500 Loads when scene loads (async, 1+ frames)\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#manual-loading","title":"Manual Loading","text":"<pre><code>[BurstCompile]\npublic partial struct SubSceneLoaderSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        var sceneSystem = World.GetExistingSystemManaged&lt;SceneSystem&gt;();\n\n        // Request load\n        sceneSystem.LoadSceneAsync(sceneGuid);\n\n        // Check if loaded\n        if (sceneSystem.IsSceneLoaded(sceneGuid))\n        {\n            // SubScene entities now in world\n        }\n    }\n}\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#unloading","title":"Unloading","text":"<pre><code>sceneSystem.UnloadScene(sceneGuid);  // Destroy entities\n</code></pre>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#best-practices","title":"Best Practices","text":"<p>Authoring: - Use live-baking for iteration - check \"Open\" on SubScene for instant feedback - Test with streaming - ensure game works with async SubScene loading - Organize by usage - group related content (Level1, Level2, SharedAssets)</p> <p>Performance: - Avoid large SubScenes - split into smaller SubScenes for streaming flexibility - Share common assets - weak references enable efficient asset sharing - Profile baking time - complex baking can slow iteration, optimize Bakers</p> <p>Builds: - Implement IEntitySceneBuildAdditions - programmatically include SubScenes - Verify weak references work - test referenced content loads correctly - Check archive size - use Build Report to verify content archives are efficient</p> <p>Runtime: - Never assume immediate loading - SubScenes take 1+ frames to load - Use SceneSystem.IsSceneLoaded - check before accessing SubScene entities - Unload unused SubScenes - free memory by unloading SubScenes not in use</p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/Baking%20Workflow%20and%20SubScenes/#common-pitfalls","title":"Common Pitfalls","text":"<p>\u274c Assuming synchronous loading <pre><code>sceneSystem.LoadSceneAsync(guid);\nvar entities = query.ToEntityArray(Allocator.Temp);  // Empty!\n</code></pre></p> <p>\u2705 Correct async pattern <pre><code>if (!sceneSystem.IsSceneLoaded(guid))\n{\n    sceneSystem.LoadSceneAsync(guid);\n    return;  // Wait for next frame\n}\n// Now entities are available\n</code></pre></p> <p>\u274c Live-baking in builds <pre><code>// This ONLY works in Editor with \"Open\" SubScene\n// Will NOT work in builds!\n</code></pre></p> <p>\u2705 Use SubScene streaming for builds <pre><code>// SubScene with \"Auto Load\" or manual SceneSystem.LoadSceneAsync\n// Works in both Editor and builds\n</code></pre></p>","tags":["baking","workflow"]},{"location":"DOTS/Baking/TransformUsageFlags/","title":"TransformUsageFlags","text":"","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#description","title":"Description","text":"<ul> <li> <p>Flags enum passed to <code>GetEntity()</code> during baking to control what transform-related components are added to the baked entity</p> </li> <li> <p>Determines the transform capabilities of the entity: static position, movable, renderable, uniform/non-uniform scale, etc.</p> </li> <li> <p>Unity automatically sets flags based on GameObject setup (MeshRenderer adds Renderable, Collider adds Dynamic, static checkbox adds WorldSpace)</p> </li> <li> <p>Choosing correct flags optimizes memory and performance by only adding required transform components</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#example","title":"Example","text":"<pre><code>public class ExampleAuthoring : MonoBehaviour\n{\n    public class Baker : Baker&lt;ExampleAuthoring&gt;\n    {\n        public override void Bake(ExampleAuthoring authoring)\n        {\n            // None - no transform components added\n            // Use for pure data entities (game manager, singleton configs)\n            Entity noneEntity = GetEntity(TransformUsageFlags.None);\n\n            // Renderable - adds LocalToWorld (read-only world position)\n            // Use for static visible objects that don't move\n            Entity renderableEntity = GetEntity(TransformUsageFlags.Renderable);\n\n            // Dynamic - adds LocalToWorld + LocalTransform\n            // Use for movable objects (characters, projectiles, enemies)\n            Entity dynamicEntity = GetEntity(TransformUsageFlags.Dynamic);\n\n            // WorldSpace - adds LocalToWorld, removes Parent\n            // Use for static objects, prevents hierarchy processing\n            Entity worldSpaceEntity = GetEntity(TransformUsageFlags.WorldSpace);\n\n            // NonUniformScale - adds PostTransformMatrix\n            // Automatically set for GameObjects with non-uniform scale\n            Entity nonUniformEntity = GetEntity(TransformUsageFlags.NonUniformScale);\n\n            // Combine flags with bitwise OR\n            Entity combined = GetEntity(\n                TransformUsageFlags.Dynamic | TransformUsageFlags.Renderable);\n        }\n    }\n}\n\n// Practical examples\npublic class TowerAuthoring : MonoBehaviour\n{\n    public class Baker : Baker&lt;TowerAuthoring&gt;\n    {\n        public override void Bake(TowerAuthoring authoring)\n        {\n            // Tower is visible but doesn't move - Renderable only\n            Entity entity = GetEntity(TransformUsageFlags.Renderable);\n            AddComponent&lt;TowerData&gt;(entity);\n        }\n    }\n}\n\npublic class ProjectileAuthoring : MonoBehaviour\n{\n    public class Baker : Baker&lt;ProjectileAuthoring&gt;\n    {\n        public override void Bake(ProjectileAuthoring authoring)\n        {\n            // Projectile moves and is visible - Dynamic\n            Entity entity = GetEntity(TransformUsageFlags.Dynamic);\n            AddComponent&lt;Projectile&gt;(entity);\n        }\n    }\n}\n</code></pre>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#pros","title":"Pros","text":"<ul> <li> <p>Memory optimization - only adds transform components that are actually needed</p> </li> <li> <p>Performance optimization - fewer components means better Cache-friendly iteration</p> </li> <li> <p>Explicit control - you decide exact transform capabilities rather than automatic \"everything\"</p> </li> <li> <p>Prevents bugs - can't accidentally move entities that shouldn't move if they lack LocalTransform</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#cons","title":"Cons","text":"<ul> <li> <p>Requires knowledge - must understand what each flag does and which components it adds</p> </li> <li> <p>Combination complexity - combining flags with bitwise OR can be confusing</p> </li> <li> <p>Auto-overrides - Unity may override your flags based on other components (MeshRenderer, Collider, etc.)</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#best-use","title":"Best use","text":"<ul> <li> <p>Pure data entities - use <code>None</code> for managers, configs, singletons that don't need position</p> </li> <li> <p>Static rendered objects - use <code>Renderable</code> for decorations, static environment that's visible but never moves</p> </li> <li> <p>Dynamic gameplay entities - use <code>Dynamic</code> for anything that moves (characters, projectiles, enemies, pickups)</p> </li> <li> <p>Static optimizations - use <code>WorldSpace</code> for static objects to bypass hierarchy transform system</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#avoid-if","title":"Avoid if","text":"<ul> <li>Prefab conversion - when converting prefabs with <code>GetEntity(prefabGameObject, flags)</code>, usually want <code>Dynamic</code> for runtime spawning flexibility</li> </ul>","tags":["baking"]},{"location":"DOTS/Baking/TransformUsageFlags/#extra-tip","title":"Extra tip","text":"<ul> <li>Component mapping:</li> <li><code>None</code> \u2192 no transform components</li> <li><code>Renderable</code> \u2192 <code>LocalToWorld</code></li> <li><code>Dynamic</code> \u2192 <code>LocalToWorld</code> + <code>LocalTransform</code></li> <li><code>WorldSpace</code> \u2192 <code>LocalToWorld</code>, removes <code>Parent</code> component</li> <li> <p><code>NonUniformScale</code> \u2192 adds <code>PostTransformMatrix</code></p> </li> <li> <p>Automatic flags - Unity adds flags automatically:</p> </li> <li><code>Renderable</code> if MeshRenderer present</li> <li><code>Dynamic</code> if Collider present or GameObject is a prefab</li> <li><code>WorldSpace</code> if GameObject marked static in Inspector</li> <li> <p><code>NonUniformScale</code> if scale is non-uniform (e.g., (1, 2, 1))</p> </li> <li> <p>LocalTransform vs LocalToWorld - <code>LocalTransform</code> is writable local transform (position/rotation/scale), <code>LocalToWorld</code> is computed world transform matrix (read-only result)</p> </li> <li> <p>Prefab pattern - for prefabs intended for spawning: <code>GetEntity(prefabGameObject, TransformUsageFlags.Dynamic)</code> ensures spawned instances can move</p> </li> <li> <p>ManualOverride - use <code>ManualOverride</code> to bypass automatic flag detection, giving you full control (advanced use only)</p> </li> </ul>","tags":["baking"]},{"location":"DOTS/Components/","title":"Components","text":"<p>Components are pure data containers attached to entities - they define what an entity \"has\" or \"is\" without containing behavior logic.</p>"},{"location":"DOTS/Components/#component-types","title":"Component Types","text":""},{"location":"DOTS/Components/#core-component-types","title":"Core Component Types","text":"<ul> <li>IComponentData - General-purpose component (blittable struct)</li> <li>IBufferElementData (dynamic buffers) - Dynamic array of elements</li> <li>BlobAsset (immutable data) - Immutable shared configuration data</li> <li>ISharedComponentData - Value shared across multiple entities</li> <li>IEnableableComponent (toggleable components) - Component that can be enabled/disabled</li> <li>ICleanupComponentData - Persists after entity destroyed for cleanup</li> <li>Tag Component - Empty struct for filtering (no data)</li> </ul>"},{"location":"DOTS/Components/#hybridadvanced-types","title":"Hybrid/Advanced Types","text":"<ul> <li>UnityObjectRef (UnityEngine.Object references) - Blittable wrapper for Unity objects (Unity Entities 6.5+)</li> <li>Managed IComponentData (class components) - Class-based components (not recommended)</li> <li>IAspect (component grouping) - Component grouping (deprecated in Unity Entities 6.5+)</li> </ul>"},{"location":"DOTS/Components/#component-features","title":"Component Features","text":"<ul> <li>InternalBufferCapacity (IBC) - Optimize buffer memory allocation</li> </ul>"},{"location":"DOTS/Components/#quick-reference","title":"Quick Reference","text":"Component Type Blittable Burst Best For IComponentData \u2705 \u2705 General gameplay data [[IBufferElementData (dynamic buffers)|IBufferElementData]] \u2705 \u2705 Dynamic arrays [[BlobAsset (immutable data)|BlobAsset]] \u2705 \u2705 Shared config data ISharedComponentData \u2705 \u274c Shared values (LOD, teams) [[IEnableableComponent (toggleable components)|IEnableableComponent]] \u2705 \u2705 Toggle without structural change [[UnityObjectRef (UnityEngine.Object references)|UnityObjectRef]] \u2705 \u26a0\ufe0f Unity asset references [[Managed IComponentData (class components)|Managed IComponentData]] \u274c \u274c GameObject companions"},{"location":"DOTS/Components/#best-practices","title":"Best Practices","text":"<ol> <li>Prefer IComponentData - use blittable structs whenever possible</li> <li>Avoid Managed Components - they break cache performance</li> <li>Use IEnableableComponent - for toggles instead of add/remove</li> <li>Share with BlobAssets - for read-only configuration data</li> <li>Tag Components - for cheap filtering (zero memory per entity)</li> </ol>"},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/","title":"BlobAsset (immutable data)","text":"","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#description","title":"Description","text":"<ul> <li> <p>Large, immutable, and shared data structures in contiguous native memory</p> </li> <li> <p>Read-only at runtime \u2014 built once (usually at initialization) and shared across many entities without duplicating memory</p> </li> <li> <p>Stored outside of chunks \u2014 referenced by components as <code>BlobAssetReference&lt;T&gt;</code></p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#example","title":"Example","text":"<pre><code>public struct WeaponData\n{\n    public BlobString Name;\n    public int Damage;\n    public BlobArray&lt;float&gt; AttackPattern;\n}\n\n// Building a blob asset\nvar builder = new BlobBuilder(Allocator.Persistent);\nref var root = ref builder.ConstructRoot&lt;WeaponData&gt;();\n\nbuilder.AllocateString(ref root.Name, \"Laser Gun\");\nroot.Damage = 42;\n\nvar array = builder.Allocate(ref root.AttackPattern, 3);\narray[0] = 0.1f;\narray[1] = 0.3f;\narray[2] = 0.6f;\n\n// This ref will be persistent, you need to clear it manually\nvar blobRef = builder.CreateBlobAssetReference&lt;WeaponData&gt;(Allocator.Persistent);\n\n// Don't forget to dispose!\nbuilder.Dispose();\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#pros","title":"Pros","text":"<ul> <li> <p>Saves memory by avoiding per-entity duplication of large static data</p> </li> <li> <p>Highly cache-friendly for read-only lookups</p> </li> <li> <p>Thread-safe access without locks</p> </li> <li> <p>No structural changes needed to modify \"configuration\" \u2014 just build new blob and swap references</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#cons","title":"Cons","text":"<ul> <li> <p>Read-only \u2014 if you need to change data, must build new blob asset</p> </li> <li> <p>Building blobs more verbose than creating normal structs</p> </li> <li> <p>Stored outside chunk memory \u2192 requires one pointer indirection to access</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#best-use","title":"Best use","text":"<ul> <li>Large, shared, immutable configuration data:<ul> <li>Level layouts, weapon stats, animation curves, dialogue scripts</li> </ul> </li> <li>Precomputed lookup tables</li> </ul>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Data changes frequently (better use IComponentData or IBufferElementData)</p> </li> <li> <p>Data is small and unique per entity (just use normal component)</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/BlobAsset%20%28immutable%20data%29/#extra-tip","title":"Extra tip","text":"<ul> <li><code>BlobAsset</code> often paired with ICleanupComponentData to free it at right time, especially if built dynamically at runtime</li> </ul>","tags":["component"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/","title":"IAspect (component grouping)","text":"<p>\u26a0\ufe0f DEPRECATION WARNING (Unity Entities 6.5+)</p> <p><code>IAspect</code> is deprecated as of Unity Entities 6.5. Unity recommends using direct <code>Component</code> and <code>EntityQuery</code> APIs instead for clearer, more maintainable code patterns.</p> <p>Alternative approaches: - Use SystemAPI.Query with multiple component parameters - Create helper methods that accept component parameters instead of aspects - Use IJobEntity with component parameters</p> <p>Existing aspect code will continue to work but is not recommended for new projects.</p>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#description","title":"Description","text":"<ul> <li> <p>Wrapper for a set of components providing specific behavior, allowing code organization and reusability across systems and jobs</p> </li> <li> <p>Defined as <code>readonly partial struct</code> implementing <code>IAspect</code>, containing RefRO/RefRW fields for component access and methods operating on those components</p> </li> <li> <p>Circumvents query limitations - useful when a single query would exceed maximum component types</p> </li> <li> <p>Automatically generates query code - when you query for an aspect, Unity generates underlying entity query for all required components</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#example","title":"Example","text":"<pre><code>// Define an aspect grouping projectile-related components\npublic readonly partial struct ProjectileAspect : IAspect\n{\n    // Read-only access to components\n    readonly RefRO&lt;Guided&gt; _guided;\n    readonly RefRO&lt;Speed&gt; _speed;\n    readonly RefRO&lt;Target&gt; _target;\n\n    // Read-write access to transform\n    readonly RefRW&lt;LocalTransform&gt; _transform;\n\n    // Methods operating on the grouped components\n    public void Move(float time, ComponentLookup&lt;LocalToWorld&gt; positions)\n    {\n        if (_guided.ValueRO.Enabled &amp;&amp; positions.HasComponent(_target.ValueRO.Value))\n        {\n            _transform.ValueRW.Rotation = TransformHelpers.LookAtRotation(\n                _transform.ValueRW.Position,\n                positions[_target.ValueRO.Value].Position,\n                _transform.ValueRW.Up());\n        }\n\n        _transform.ValueRW.Position +=\n            _speed.ValueRO.value * time * _transform.ValueRW.Forward();\n    }\n}\n\n// Use in IJobEntity\npublic partial struct ProjectileMoveJob : IJobEntity\n{\n    public float DeltaTime;\n    [ReadOnly] public ComponentLookup&lt;LocalToWorld&gt; Positions;\n\n    // Aspect as parameter - Unity generates query automatically\n    private void Execute(ProjectileAspect projectile)\n    {\n        projectile.Move(DeltaTime, Positions);\n    }\n}\n\n// Use in SystemAPI.Query\nforeach (var projectile in SystemAPI.Query&lt;ProjectileAspect&gt;())\n{\n    projectile.Move(deltaTime, positions);\n}\n</code></pre>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#pros","title":"Pros","text":"<ul> <li> <p>Code reusability - behavior defined once in aspect, used across multiple systems and jobs</p> </li> <li> <p>Better organization - groups related components together with their behavior logic</p> </li> <li> <p>Cleaner queries - <code>SystemAPI.Query&lt;ProjectileAspect&gt;()</code> instead of multi-component tuples</p> </li> <li> <p>Bypasses query limits - aspects don't count toward maximum component types per query</p> </li> <li> <p>Compile-time safety - ensures all required components are present in queries</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#cons","title":"Cons","text":"<ul> <li> <p>Additional abstraction layer - adds complexity compared to direct component access</p> </li> <li> <p>Cannot include tag components - only works with data-containing components</p> </li> <li> <p>Learning curve - requires understanding RefRO/RefRW access patterns</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#best-use","title":"Best use","text":"<ul> <li> <p>Complex entity behaviors - when entity's behavior requires 4+ components working together (movement, combat, AI)</p> </li> <li> <p>Reusable logic - when same component combination and behavior used in multiple systems</p> </li> <li> <p>Large queries - when direct component queries would exceed Unity's per-query component limit</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Simple single-component operations - use direct IComponentData access with <code>SystemAPI.Query&lt;MyComponent&gt;()</code></p> </li> <li> <p>Tag components involved - aspects don't support tags, use regular queries with <code>WithAll&lt;TagComponent&gt;()</code></p> </li> <li> <p>One-off behavior - if logic only used in one place, direct component access is simpler</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Nested aspects - aspects can contain other aspects as fields for hierarchical component grouping</p> </li> <li> <p>Optional components - use <code>[Optional]</code> attribute on RefRO/RefRW fields for components that may not be present</p> </li> <li> <p>DynamicBuffer support - aspects can contain <code>DynamicBuffer&lt;T&gt;</code> fields (use <code>[ReadOnly]</code> attribute for read-only buffers)</p> </li> <li> <p>Access patterns - use <code>.ValueRO</code> for read-only access, <code>.ValueRW</code> for read-write access</p> </li> <li> <p>IEnableableComponent support - use <code>EnabledRefRO</code> and <code>EnabledRefRW</code> fields to access enabled state of enableable components</p> </li> </ul>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#modern-alternatives-unity-entities-65","title":"Modern Alternatives (Unity Entities 6.5+)","text":"<p>Since <code>IAspect</code> is deprecated, here are recommended alternatives:</p>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#alternative-1-helper-methods-with-component-parameters","title":"Alternative 1: Helper Methods with Component Parameters","text":"<pre><code>// Instead of aspect, use static helper methods\npublic static class ProjectileHelpers\n{\n    public static void Move(\n        ref LocalTransform transform,\n        in Speed speed,\n        in Guided guided,\n        in Target target,\n        float deltaTime,\n        ComponentLookup&lt;LocalToWorld&gt; positions)\n    {\n        if (guided.Enabled &amp;&amp; positions.HasComponent(target.Value))\n        {\n            transform.Rotation = TransformHelpers.LookAtRotation(\n                transform.Position,\n                positions[target.Value].Position,\n                transform.Up());\n        }\n        transform.Position += speed.value * deltaTime * transform.Forward();\n    }\n}\n\n// Use in IJobEntity\nprivate void Execute(\n    ref LocalTransform transform,\n    in Speed speed,\n    in Guided guided,\n    in Target target)\n{\n    ProjectileHelpers.Move(ref transform, speed, guided, target, DeltaTime, Positions);\n}\n</code></pre>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#alternative-2-direct-component-access-in-systemapiquery","title":"Alternative 2: Direct Component Access in SystemAPI.Query","text":"<pre><code>// Direct multi-component query instead of aspect\nforeach (var (transform, speed, guided, target) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Speed&gt;, RefRO&lt;Guided&gt;, RefRO&lt;Target&gt;&gt;())\n{\n    if (guided.ValueRO.Enabled &amp;&amp; positions.HasComponent(target.ValueRO.Value))\n    {\n        transform.ValueRW.Rotation = TransformHelpers.LookAtRotation(\n            transform.ValueRO.Position,\n            positions[target.ValueRO.Value].Position,\n            transform.ValueRO.Up());\n    }\n    transform.ValueRW.Position += speed.ValueRO.value * dt * transform.ValueRO.Forward();\n}\n</code></pre>","tags":["component","deprecated"]},{"location":"DOTS/Components/IAspect%20%28component%20grouping%29/#alternative-3-component-based-extension-methods","title":"Alternative 3: Component-Based Extension Methods","text":"<pre><code>// Extension methods on components\npublic static class LocalTransformExtensions\n{\n    public static void MoveTowards(\n        this ref LocalTransform transform,\n        float3 target,\n        float speed,\n        float deltaTime)\n    {\n        float3 direction = math.normalize(target - transform.Position);\n        transform.Position += direction * speed * deltaTime;\n        transform.Rotation = quaternion.LookRotation(direction, math.up());\n    }\n}\n\n// Usage in job\nprivate void Execute(\n    ref LocalTransform transform,\n    in Speed speed,\n    in Target target,\n    ComponentLookup&lt;LocalToWorld&gt; positions)\n{\n    if (positions.TryGetComponent(target.Value, out LocalToWorld targetPos))\n    {\n        transform.MoveTowards(targetPos.Position, speed.value, deltaTime);\n    }\n}\n</code></pre>","tags":["component","deprecated"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/","title":"IBufferElementData (dynamic buffers)","text":"","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#description","title":"Description","text":"<ul> <li> <p>A flexible array of one element type per entity.</p> </li> <li> <p>Can be stored inside the chunk(in-place) or outside in heap memory if too large.</p> </li> <li> <p>Uses Internal Buffer Capacity to determine how many elements fit in-chunk before spilling to heap.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#example","title":"Example","text":"<pre><code>[InternalBufferCapacity(4)] // optional attribute\npublic struct InventoryItem : IBufferElementData\n{\n    public Entity Item;\n}\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#pros","title":"Pros","text":"<ul> <li> <p>Variable length.</p> </li> <li> <p>Great for collections (inventory, waypoints, per-frame events).</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#cons","title":"Cons","text":"<ul> <li> <p>Changing length is slower than IComponentData.</p> </li> <li> <p>Can reduce cache locality if buffers are large.</p> </li> <li> <p>Spill to heap if exceeding IBC \u2192 slower + extra memory ops.</p> </li> <li> <p>Large IBC wastes memory if most buffers stay small.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#best-use","title":"Best use","text":"<ul> <li>Arrays of points, inventory, event history.</li> </ul>","tags":["component"]},{"location":"DOTS/Components/IBufferElementData%20%28dynamic%20buffers%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Small fixed-size data sets (better store in IComponentData fields).</p> </li> <li> <p>Buffers that frequently exceed IBC unless absolutely necessary.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IChunkComponent/","title":"IChunkComponent","text":"","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#description","title":"Description","text":"<ul> <li> <p>Single value per Chunk component type belonging to chunk itself rather than individual entities - all entities in chunk share access to same value</p> </li> <li> <p>Different from ISharedComponentData - shared components logically belong to entities (changing value moves entity), chunk components belong to chunk itself</p> </li> <li> <p>Stored in chunk - unmanaged chunk components stored directly in 16KiB chunk block, managed chunk components stored separately</p> </li> <li> <p>Defined as struct or class implementing <code>IComponentData</code>, but added/accessed through special EntityManager chunk methods</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#example","title":"Example","text":"<pre><code>// Define chunk component (same as regular IComponentData)\npublic struct ChunkWorldBounds : IComponentData\n{\n    public AABB WorldBounds;  // Bounding box for all entities in chunk\n}\n\n// System using chunk components\nforeach (var (transform, chunk) in\n    SystemAPI.Query&lt;RefRO&lt;LocalTransform&gt;&gt;()\n        .WithEntityAccess())\n{\n    // Get the chunk this entity belongs to\n    ArchetypeChunk archetypeChunk = em.GetChunk(entity);\n\n    // Check if chunk has chunk component\n    if (em.HasChunkComponent&lt;ChunkWorldBounds&gt;(archetypeChunk))\n    {\n        // Get chunk component value\n        ChunkWorldBounds bounds = em.GetChunkComponentData&lt;ChunkWorldBounds&gt;(archetypeChunk);\n\n        if (bounds.WorldBounds.Contains(transform.ValueRO.Position))\n        {\n            // Process entity...\n        }\n    }\n}\n\n// Adding chunk component when creating archetype\nEntity entity = em.CreateEntity(typeof(LocalTransform), typeof(Health));\nArchetypeChunk chunk = em.GetChunk(entity);\n\n// Add chunk component to the chunk\nem.AddChunkComponentData&lt;ChunkWorldBounds&gt;(chunk);\n\n// Set chunk component value\nem.SetChunkComponentData(chunk, new ChunkWorldBounds\n{\n    WorldBounds = new AABB\n    {\n        Center = float3.zero,\n        Extents = new float3(10, 10, 10)\n    }\n});\n\n// Accessing in IJobChunk\n[BurstCompile]\npublic struct MyChunkJob : IJobChunk\n{\n    public ComponentTypeHandle&lt;ChunkWorldBounds&gt; ChunkBoundsHandle;\n\n    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,\n                       bool useEnabledMask, in v128 chunkEnabledMask)\n    {\n        // Access chunk component\n        if (chunk.Has(ChunkBoundsHandle))\n        {\n            ChunkWorldBounds bounds = chunk.GetChunkComponentData(ref ChunkBoundsHandle);\n            // Process using bounds...\n        }\n    }\n}\n</code></pre>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#pros","title":"Pros","text":"<ul> <li> <p>Efficient shared data - one value per chunk rather than duplicating per entity, saves memory</p> </li> <li> <p>Direct chunk storage - unmanaged chunk components stored in chunk's 16KiB block, no indirection</p> </li> <li> <p>Useful for metadata - perfect for storing chunk-level information like bounding boxes, timestamps, or processing flags</p> </li> <li> <p>No entity movement - unlike ISharedComponentData, setting chunk component value doesn't move entities between chunks</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#cons","title":"Cons","text":"<ul> <li> <p>Limited use cases - most data belongs to entities or is global, chunk-level data relatively rare</p> </li> <li> <p>Awkward API - requires obtaining ArchetypeChunk first, then using special EntityManager methods</p> </li> <li> <p>Not query-friendly - cannot query for entities based on chunk component values like regular components</p> </li> <li> <p>Chunk lifetime - chunk component exists only while chunk exists, destroyed when chunk destroyed</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#best-use","title":"Best use","text":"<ul> <li> <p>Chunk-level metadata - bounding boxes, spatial hashing keys, processing timestamps for entire chunk</p> </li> <li> <p>Batch processing flags - marking chunks as \"needs update\", \"dirty\", \"processed\" for optimization</p> </li> <li> <p>Chunk-wide constants - data that applies uniformly to all entities in chunk</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Entity-specific data - use regular IComponentData for per-entity values</p> </li> <li> <p>Shared entity data - use ISharedComponentData when multiple entities share value and should be grouped</p> </li> <li> <p>Global data - use singleton components for world-wide configuration or state</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IChunkComponent/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>EntityManager chunk component methods: <pre><code>em.AddChunkComponentData&lt;T&gt;(ArchetypeChunk chunk);\nem.RemoveChunkComponentData&lt;T&gt;(ArchetypeChunk chunk);\nbool has = em.HasChunkComponent&lt;T&gt;(ArchetypeChunk chunk);\nT value = em.GetChunkComponentData&lt;T&gt;(ArchetypeChunk chunk);\nem.SetChunkComponentData&lt;T&gt;(ArchetypeChunk chunk, T value);\n</code></pre></p> </li> <li> <p>Getting entity's chunk: <pre><code>ArchetypeChunk chunk = entityManager.GetChunk(entity);\n</code></pre></p> </li> <li> <p>Chunk component vs Shared component:</p> </li> <li>Chunk component: Belongs to chunk, changing value doesn't move entities</li> <li>Shared component: Belongs to entities, changing value moves entity to different chunk</li> <li>Use shared components when value determines chunk grouping</li> <li> <p>Use chunk components when value is consequence of chunk's contents</p> </li> <li> <p>Managed chunk components - can create from classes (managed IComponentData), stored separately with GC overhead</p> </li> <li> <p>Chunk creation and destruction:</p> </li> <li>Chunk components created when chunk created (entity added to full archetype)</li> <li>Chunk components destroyed when chunk destroyed (last entity removed)</li> <li>Don't persist independently of chunks</li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/ICleanupComponentData/","title":"ICleanupComponentData","text":"","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#description","title":"Description","text":"<ul> <li> <p>Components that remain on an entity after <code>EntityManager.DestroyEntity</code> is called.</p> </li> <li> <p>Removed only manually or during world cleanup.</p> </li> <li> <p>Used for \u201cfinal actions\u201d after entity destruction.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#example","title":"Example","text":"<pre><code>public struct NetworkDisconnectTag : ICleanupComponentData {}\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#pros","title":"Pros","text":"<ul> <li> <p>Great for finalisation logic.</p> </li> <li> <p>Allows systems to process \u201centity death\u201d in the next frame.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#cons","title":"Cons","text":"<ul> <li> <p>Not automatically removed (must be handled).</p> </li> <li> <p>Consumes memory until cleared.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#best-use","title":"Best use","text":"<ul> <li> <p>Freeing GPU/network resources after entity deletion.</p> </li> <li> <p>Post-processing logic (death effects, final events).</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ICleanupComponentData/#avoid-if","title":"Avoid if","text":"<ul> <li>Data must disappear instantly on deletion.</li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/","title":"IComponentData","text":"","tags":["component"]},{"location":"DOTS/Components/IComponentData/#description","title":"Description","text":"<ul> <li> <p>Structs holding data only (value types, no references to objects).</p> </li> <li> <p>Stored in chunks, cache-friendly.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#example","title":"Example","text":"<pre><code>public struct Health : IComponentData { public int Value; }\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#pros","title":"Pros","text":"<ul> <li> <p>Very high performance for bulk processing.</p> </li> <li> <p>Easy to serialize.</p> </li> <li> <p>Minimal memory overhead.</p> </li> <li> <p>Perfect for frequently accessed data.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#cons","title":"Cons","text":"<ul> <li> <p>Cannot contain managed types (<code>string</code>, <code>class</code>, etc.).</p> </li> <li> <p>Structural changes are expensive (adding/removing component).</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#best-use","title":"Best use","text":"<ul> <li> <p>Frequently updated game loop data: position, velocity, health.</p> </li> <li> <p>Can be used as Tag Component</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#avoid-if","title":"Avoid if","text":"<ul> <li>Large or rarely used data (wastes Chunk memory).</li> </ul>","tags":["component"]},{"location":"DOTS/Components/IComponentData/#see-also","title":"See also","text":"<ul> <li>Component Memory Alignment - Optimize struct field ordering to minimize memory waste</li> <li>ECS Design Decisions - Component design patterns and when to split/combine components</li> </ul>","tags":["component"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/","title":"IEnableableComponent (toggleable components)","text":"","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#description","title":"Description","text":"<ul> <li> <p>Toggleable components implementing both IComponentData and IEnableableComponent - can be enabled/disabled at runtime without Structural changes</p> </li> <li> <p>Per-entity bitmask stored in Chunk tracks enabled/disabled state - component memory always allocated but logically \"turned off\"</p> </li> <li> <p>Query filtering supports special filters (WithAll, WithNone, WithDisabled, WithPresent) to process enabled/disabled entities differently</p> </li> <li> <p>Zero-size optimization - empty enableable components are ideal for boolean flags without memory overhead beyond the enable bit</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#example","title":"Example","text":"<pre><code>// Define enableable component (usually zero-size for flags)\npublic struct Stunned : IComponentData, IEnableableComponent {}\n\npublic struct Shield : IComponentData, IEnableableComponent\n{\n    public float Strength;  // Can have data like regular IComponentData\n}\n\n// Toggling enabled state\nforeach (var entity in SystemAPI.Query&lt;RefRO&lt;Entity&gt;&gt;().WithEntityAccess())\n{\n    // Check and toggle enabled state\n    if (SystemAPI.IsComponentEnabled&lt;Stunned&gt;(entity))\n    {\n        SystemAPI.SetComponentEnabled&lt;Stunned&gt;(entity, false);\n    }\n}\n\n// Query filtering by enabled/disabled state\n// Process only entities with ENABLED Stunned component\nforeach (var transform in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;()\n        .WithAll&lt;Stunned&gt;())  // Only enabled Stunned\n{\n    // These entities are stunned - don't move\n}\n\n// Process entities WITHOUT enabled Stunned component\nforeach (var (transform, velocity) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;()\n        .WithNone&lt;Stunned&gt;())  // Excludes enabled Stunned\n{\n    transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;\n}\n\n// Process entities with DISABLED Stunned component\nforeach (var entity in\n    SystemAPI.Query&lt;RefRO&lt;Entity&gt;&gt;()\n        .WithDisabled&lt;Stunned&gt;())  // Only disabled\n{\n    // Entity was stunned but recovered\n}\n\n// ComponentLookup with enableable components\nvar stunnedLookup = SystemAPI.GetComponentLookup&lt;Stunned&gt;(isReadOnly: false);\nif (stunnedLookup.IsComponentEnabled(targetEntity))\n{\n    stunnedLookup.SetComponentEnabled(targetEntity, false);\n}\n\n// EntityCommandBuffer support\necb.SetComponentEnabled&lt;Stunned&gt;(entity, true);\n</code></pre>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#pros","title":"Pros","text":"<ul> <li> <p>No structural changes - toggling doesn't move entity between chunks, avoiding expensive archetype changes</p> </li> <li> <p>Query filtering - efficiently filter enabled vs disabled entities with WithAll, WithNone, WithDisabled, WithPresent</p> </li> <li> <p>Zero-size flags - empty enableable components use minimal memory (just enable bit), perfect for boolean state</p> </li> <li> <p>Component data preserved - disabling keeps data intact, re-enabling doesn't require setting data again</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#cons","title":"Cons","text":"<ul> <li> <p>Memory always allocated - disabled components still consume chunk memory, not removed until component removed</p> </li> <li> <p>Mixed-state overhead - chunks with both enabled and disabled entities slower to filter than homogeneous chunks</p> </li> <li> <p>Bitmask storage - additional bitmask per enableable component type reduces available entity capacity</p> </li> <li> <p>Not a replacement for tags - if component never has data, consider zero-size IComponentData instead</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#best-use","title":"Best use","text":"<ul> <li> <p>Temporary state flags - stunned, frozen, invulnerable, invisible states that toggle frequently</p> </li> <li> <p>Conditional processing - enable/disable to include/exclude entities from systems without removing component</p> </li> <li> <p>Activity toggles - AI active/inactive, physics enabled/disabled, rendering visible/invisible</p> </li> <li> <p>State machines - current state enabled, other states disabled on same entity</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Permanent states - if state doesn't toggle often, use regular components with add/remove</p> </li> <li> <p>Large data components - memory stays allocated when disabled, wasteful for big components</p> </li> <li> <p>All-or-nothing per chunk - if all entities in chunk always have same enabled state, regular components work better</p> </li> <li> <p>Simple boolean flag - for rare checks, storing bool in regular component may be simpler</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/IEnableableComponent%20%28toggleable%20components%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>API methods: <pre><code>// EntityManager\nbool isEnabled = em.IsComponentEnabled&lt;T&gt;(entity);\nem.SetComponentEnabled&lt;T&gt;(entity, true);\n\n// ComponentLookup\nvar lookup = SystemAPI.GetComponentLookup&lt;T&gt;(isReadOnly: false);\nlookup.SetComponentEnabled(entity, true);\n\n// EntityCommandBuffer\necb.SetComponentEnabled&lt;T&gt;(entity, true);\n</code></pre></p> </li> <li> <p>Query filter options:</p> </li> <li><code>WithAll&lt;T&gt;()</code> - only ENABLED components (default)</li> <li><code>WithNone&lt;T&gt;()</code> - excludes ENABLED components</li> <li><code>WithDisabled&lt;T&gt;()</code> - only DISABLED components</li> <li> <p><code>WithPresent&lt;T&gt;()</code> - both enabled AND disabled</p> </li> <li> <p>Default enabled state - adding component starts ENABLED, set disabled after adding if needed</p> </li> <li> <p>Performance characteristics - all enabled or all disabled in chunk is fast, mixed state slower</p> </li> <li> <p>Zero-size pattern (recommended): <pre><code>public struct Stunned : IComponentData, IEnableableComponent {}\n// Only uses 1 bit per entity, no data memory\n</code></pre></p> </li> <li> <p>With data: <pre><code>public struct Shield : IComponentData, IEnableableComponent\n{\n    public float Strength;\n}\n// When disabled: data memory still allocated but ignored\n</code></pre></p> </li> <li> <p>State machine pattern: <pre><code>public struct IdleState : IComponentData, IEnableableComponent {}\npublic struct WalkState : IComponentData, IEnableableComponent {}\n// Entity has all states, only one enabled at a time\n</code></pre></p> </li> <li> <p>IJobChunk support - use <code>useEnabledMask</code> and <code>chunkEnabledMask</code> parameters with <code>ChunkEntityEnumerator</code> to iterate only enabled entities</p> </li> </ul>","tags":["component","advanced"]},{"location":"DOTS/Components/ISharedComponentData/","title":"ISharedComponentData","text":"","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#description","title":"Description","text":"<ul> <li> <p>Data Shared by a group of entities.</p> </li> <li> <p>Entities with different values live in different chunks.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#example","title":"Example","text":"<pre><code>public struct RenderMaterial : ISharedComponentData\n{\n    public Material Material;\n}\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#pros","title":"Pros","text":"<ul> <li> <p>Saves memory for repeated values.</p> </li> <li> <p>Useful for grouping and filtering.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#cons","title":"Cons","text":"<ul> <li> <p>Frequent changes cause Chunk rearrangement (expensive).</p> </li> <li> <p>Slower filtering than IComponentData.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#best-use","title":"Best use","text":"<ul> <li>Materials, meshes, constant AI parameters.</li> </ul>","tags":["component"]},{"location":"DOTS/Components/ISharedComponentData/#avoid-if","title":"Avoid if","text":"<ul> <li>Frequently changing values or unique per-entity parameters.</li> </ul>","tags":["component"]},{"location":"DOTS/Components/InternalBufferCapacity%20%28IBC%29/","title":"InternalBufferCapacity (IBC)","text":"<p>Default value: The initial capacity of a dynamic buffer is defined by the type that the buffer stores. By default, the capacity defaults to the number of elements that fit within 128 bytes.</p> <ul> <li> <p>If you exceed IBC: Unity allocates external memory for the buffer (on the heap), which:</p> <ul> <li>Loses cache locality.</li> <li>Adds GC-like memory allocation overhead (though DOTS manages it in native memory).</li> <li>Can hurt performance for frequent access.</li> </ul> </li> <li> <p>If you set IBC too high:</p> <ul> <li>Every entity reserves that many elements worth of space inside the chunk, even if you store fewer items.</li> <li>Wastes chunk memory, reducing how many entities fit per chunk and hurting overall performance.</li> </ul> </li> <li> <p>Rule of thumb:</p> <ul> <li>Small, frequently accessed buffers \u2192 keep IBC high enough so they almost never spill.</li> <li>Large or rarely accessed buffers \u2192 keep IBC small to avoid wasting chunk space.</li> </ul> </li> </ul>"},{"location":"DOTS/Components/LocalToWorld/","title":"LocalToWorld","text":"","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#description","title":"Description","text":"<ul> <li> <p>Read-only 4x4 transformation matrix computed by <code>LocalToWorldSystem</code> from LocalTransform and parent hierarchy - the final world-space transform used by rendering</p> </li> <li> <p>Automatically updated each frame by <code>TransformSystemGroup</code> - combines LocalTransform with Parent hierarchy and PostTransformMatrix if present</p> </li> <li> <p>Required for rendering - Unity's Entities Graphics reads LocalToWorld matrices, not LocalTransform directly</p> </li> <li> <p>Never write directly - systems should modify LocalTransform instead, LocalToWorld is automatically recomputed</p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#example","title":"Example","text":"<pre><code>// Reading LocalToWorld (never write to it)\nforeach (var localToWorld in SystemAPI.Query&lt;RefRO&lt;LocalToWorld&gt;&gt;())\n{\n    // Extract world position from matrix\n    float3 worldPosition = localToWorld.ValueRO.Position;\n    quaternion worldRotation = localToWorld.ValueRO.Rotation;\n    float3 worldForward = localToWorld.ValueRO.Forward;\n    float4x4 matrix = localToWorld.ValueRO.Value;\n}\n\n// Wrong: Don't modify LocalToWorld directly\nforeach (var localToWorld in SystemAPI.Query&lt;RefRW&lt;LocalToWorld&gt;&gt;())\n{\n    // WRONG - changes overwritten next frame\n    localToWorld.ValueRW = float4x4.Translate(new float3(1, 0, 0));\n}\n\n// Correct: Modify LocalTransform instead\nforeach (var transform in SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;())\n{\n    transform.ValueRW.Position += new float3(1, 0, 0);\n    // LocalToWorldSystem will update LocalToWorld automatically\n}\n\n// Static entities with LocalToWorld only (no LocalTransform)\nEntity staticEntity = em.CreateEntity(typeof(LocalToWorld));\nem.SetComponentData(staticEntity, new LocalToWorld\n{\n    Value = float4x4.TRS(\n        new float3(10, 0, 5),\n        quaternion.identity,\n        new float3(1, 1, 1)\n    )\n});\nem.AddComponent&lt;Static&gt;(staticEntity);\n// LocalToWorld won't be updated since no LocalTransform exists\n\n// Using LocalToWorld for world-space queries\nfloat3 targetPosition = new float3(0, 0, 0);\nforeach (var localToWorld in SystemAPI.Query&lt;RefRO&lt;LocalToWorld&gt;&gt;())\n{\n    float3 worldPos = localToWorld.ValueRO.Position;\n    float distance = math.distance(worldPos, targetPosition);\n}\n</code></pre>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#pros","title":"Pros","text":"<ul> <li> <p>Rendering ready - directly usable by Entities Graphics without additional computation</p> </li> <li> <p>World-space access - provides final world position/rotation for queries, raycasts, distance checks</p> </li> <li> <p>Automatic computation - no manual matrix multiplication for hierarchies, system handles it</p> </li> <li> <p>Optimized updates - only recomputed when LocalTransform changes (with change filtering)</p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#cons","title":"Cons","text":"<ul> <li> <p>Read-only semantics - cannot directly set world-space transform, must modify LocalTransform</p> </li> <li> <p>One-frame delay - changes to LocalTransform update LocalToWorld next frame</p> </li> <li> <p>Memory overhead - storing both LocalTransform and LocalToWorld uses more memory</p> </li> <li> <p>Redundant for static - static entities only need LocalToWorld, LocalTransform wasted (use TransformUsageFlags.WorldSpace)</p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#best-use","title":"Best use","text":"<ul> <li> <p>All rendered entities - required component for any entity rendered by Entities Graphics</p> </li> <li> <p>World-space queries - distance checks, raycasting, proximity detection using final world positions</p> </li> <li> <p>Static entities - entities that never move can use LocalToWorld only without LocalTransform</p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>No rendering or spatial queries - entities without world-space position don't need transforms</p> </li> <li> <p>Pure logic entities - UI data, game state, configuration entities typically don't need transforms</p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalToWorld/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>LocalToWorld structure: <pre><code>public struct LocalToWorld : IComponentData\n{\n    public float4x4 Value;  // 4x4 transformation matrix\n\n    // Convenience properties\n    public float3 Position { get; }\n    public quaternion Rotation { get; }\n    public float3 Forward/Up/Right { get; }\n}\n</code></pre></p> </li> <li> <p>How LocalToWorld is computed: <pre><code>// No parent (world-space):\nLocalToWorld = LocalTransform.ToMatrix()\n\n// With parent (hierarchy):\nLocalToWorld = Parent.LocalToWorld \u00d7 LocalTransform.ToMatrix()\n\n// With PostTransformMatrix:\nLocalToWorld = Parent.LocalToWorld \u00d7 LocalTransform \u00d7 PostTransformMatrix\n</code></pre></p> </li> <li> <p>TransformUsageFlags control which components added: <pre><code>GetEntity(TransformUsageFlags.Dynamic)      // \u2192 LocalTransform + LocalToWorld\nGetEntity(TransformUsageFlags.WorldSpace)   // \u2192 LocalToWorld only\nGetEntity(TransformUsageFlags.None)         // \u2192 Nothing\n</code></pre></p> </li> <li> <p>Static entities optimization - don't add LocalTransform to static entities, only LocalToWorld saves memory</p> </li> <li> <p>Transform system update order: <pre><code>1. ParentSystem - Updates Parent/Child relationships\n2. LocalToWorldSystem - Computes LocalToWorld from LocalTransform + hierarchy\n3. Rendering systems read LocalToWorld\n</code></pre></p> </li> <li> <p>Extracting data from matrix: <pre><code>float3 position = localToWorld.Position;  // Use property\nquaternion rotation = localToWorld.Rotation;\n\n// Or manually from matrix columns:\nfloat3 position = localToWorld.Value.c3.xyz;  // 4th column\n</code></pre></p> </li> <li> <p>Change filtering (avoid redundant updates): <pre><code>var query = SystemAPI.QueryBuilder()\n    .WithAll&lt;LocalToWorld&gt;()\n    .Build();\nquery.SetChangedVersionFilter(ComponentType.ReadOnly&lt;LocalToWorld&gt;());\n// Only processes entities with changed LocalToWorld\n</code></pre></p> </li> <li> <p>Hierarchy computation example: <pre><code>Parent LocalToWorld = Translate(10,0,0)\nChild LocalTransform = Translate(0,5,0)  // Relative\n\n// LocalToWorldSystem computes:\nChild LocalToWorld = Parent.LocalToWorld \u00d7 Child.LocalTransform\n                   = Translate(10,5,0)  // Final world position\n</code></pre></p> </li> </ul>","tags":["component","transform","rendering"]},{"location":"DOTS/Components/LocalTransform/","title":"LocalTransform","text":"","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#description","title":"Description","text":"<ul> <li> <p>Primary transform component storing entity's local position, rotation, and uniform scale in 3D space - the writable transform that systems modify directly</p> </li> <li> <p>Represents transform relative to parent if Parent component exists, otherwise relative to world origin</p> </li> <li> <p>Uniform scale only - single float value scales equally in all directions. For non-uniform scale, must add PostTransformMatrix</p> </li> <li> <p>Automatically processed by <code>LocalToWorldSystem</code> each frame to compute read-only LocalToWorld matrix for rendering</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#example","title":"Example","text":"<pre><code>// Basic usage - create entity with transform\nEntity entity = entityManager.CreateEntity(typeof(LocalTransform));\nentityManager.SetComponentData(entity, new LocalTransform\n{\n    Position = new float3(0, 1, 0),\n    Rotation = quaternion.identity,\n    Scale = 1f\n});\n\n// Helper methods for common operations\nLocalTransform transform = LocalTransform.FromPosition(new float3(10, 0, 5));\nLocalTransform transform2 = LocalTransform.FromRotation(quaternion.RotateY(math.radians(90)));\nLocalTransform transform3 = LocalTransform.FromScale(2f);\n\n// Combined initialization\nLocalTransform playerTransform = LocalTransform.FromPositionRotationScale(\n    new float3(0, 0, 0),\n    quaternion.Euler(0, math.radians(45), 0),\n    1.5f\n);\n\n// System modifying transforms\nforeach (var (transform, velocity) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;())\n{\n    // Modify position\n    transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;\n\n    // Rotate entity\n    transform.ValueRW.Rotation = math.mul(\n        transform.ValueRW.Rotation,\n        quaternion.RotateY(deltaTime)\n    );\n\n    // Scale entity\n    transform.ValueRW.Scale *= 1.01f;\n}\n\n// Using helper methods\nforeach (var transform in SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;())\n{\n    // Apply translation\n    transform.ValueRW = transform.ValueRO.Translate(new float3(0, deltaTime, 0));\n\n    // Rotate around axis\n    transform.ValueRW = transform.ValueRO.Rotate(quaternion.RotateY(deltaTime));\n\n    // Look at target\n    float3 targetPos = new float3(10, 0, 0);\n    transform.ValueRW.Rotation = quaternion.LookRotation(\n        math.normalize(targetPos - transform.ValueRO.Position),\n        math.up()\n    );\n}\n</code></pre>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#pros","title":"Pros","text":"<ul> <li> <p>Direct modification - systems can write to this component directly without special APIs, unlike LocalToWorld</p> </li> <li> <p>Hierarchical transforms - automatically combines with Parent component for hierarchies without manual matrix math</p> </li> <li> <p>Uniform scale performance - single float scale cheaper than 3-component scale, better for most use cases</p> </li> <li> <p>Cache-friendly - small size (28 bytes: float3 + quaternion + float) fits efficiently in Chunk memory</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#cons","title":"Cons","text":"<ul> <li> <p>Uniform scale limitation - cannot represent non-uniform scale (stretched box, ellipsoid) without adding PostTransformMatrix</p> </li> <li> <p>Requires transform systems - relies on <code>TransformSystemGroup</code> running to update LocalToWorld, not automatic</p> </li> <li> <p>Not the rendered transform - rendering uses LocalToWorld, not LocalTransform directly</p> </li> <li> <p>Must exist with LocalToWorld - Unity's rendering requires LocalToWorld component, so LocalTransform alone insufficient</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#best-use","title":"Best use","text":"<ul> <li> <p>Dynamic entities - any moving, rotating, or scaling entity (players, enemies, projectiles, cameras)</p> </li> <li> <p>Transform hierarchies - entities with Parent component automatically use LocalTransform for relative positioning</p> </li> <li> <p>Uniform scaling objects - characters, spheres, UI elements, anything that scales equally in all directions</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Static non-moving entities - if entity never moves/rotates/scales, can use only LocalToWorld with [[Static]] tag</p> </li> <li> <p>Non-uniform scale needed - stretched objects, ellipsoids, or different X/Y/Z scales require PostTransformMatrix</p> </li> <li> <p>No rendering needed - if entity doesn't render and doesn't need spatial position, avoid transform components</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/LocalTransform/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Helper methods available: <pre><code>// Creation\nLocalTransform.Identity\nLocalTransform.FromPosition(float3)\nLocalTransform.FromRotation(quaternion)\nLocalTransform.FromScale(float)\nLocalTransform.FromPositionRotationScale(float3, quaternion, float)\n\n// Transformation\ntransform.Translate(float3 offset)\ntransform.Rotate(quaternion rotation)\ntransform.RotateX/Y/Z(float radians)\ntransform.TransformPoint(float3 point)      // Local to world\ntransform.InverseTransformPoint(float3 point) // World to local\n\n// Properties\nfloat3 up = transform.Up()\nfloat3 forward = transform.Forward()\nfloat3 right = transform.Right()\n</code></pre></p> </li> <li> <p>TransformUsageFlags in baking: <pre><code>var entity = GetEntity(TransformUsageFlags.Dynamic);\n// Adds LocalTransform + LocalToWorld\n</code></pre></p> </li> <li><code>TransformUsageFlags.Dynamic</code> \u2192 Adds LocalTransform (for moving entities)</li> <li> <p><code>TransformUsageFlags.WorldSpace</code> \u2192 Adds LocalToWorld only (for static rendering)</p> </li> <li> <p>LocalTransform is computed FROM LocalToWorld during baking - Unity converts <code>UnityEngine.Transform</code> \u2192 <code>LocalToWorld</code> \u2192 <code>LocalTransform</code></p> </li> <li> <p>Hierarchy behavior:</p> </li> <li>No Parent: LocalTransform IS world-space transform</li> <li>Has Parent: LocalTransform relative to parent's LocalToWorld</li> <li> <p><code>LocalToWorldSystem</code> combines parent \u00d7 child \u2192 child's LocalToWorld</p> </li> <li> <p>Quaternion normalization - Unity automatically normalizes rotation quaternions</p> </li> <li> <p>Transform system ordering: <pre><code>1. ParentSystem - Updates Parent/Child relationships\n2. LocalToWorldSystem - Computes LocalToWorld from LocalTransform + parent\n3. Runs in TransformSystemGroup every frame\n</code></pre></p> </li> <li> <p>Performance tip - batch transform changes in jobs with IJobEntity for thousands of entities</p> </li> </ul>","tags":["component","transform"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/","title":"Managed IComponentData (class components)","text":"","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#description","title":"Description","text":"<ul> <li> <p>Class-based IComponentData that can store managed references like <code>GameObject</code>, <code>Texture2D</code>, or other C# objects</p> </li> <li> <p>Stored outside the chunk in separate managed array, breaking SoA layout and Cache-friendly architecture</p> </li> <li> <p>Useful for hybrid workflows bridging between DOTS and traditional Unity systems (GameObjects, MonoBehaviours, Assets)</p> </li> <li> <p>Cannot be used with Burst or in jobs - requires <code>SystemAPI.ManagedAPI</code> for access in systems</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#example","title":"Example","text":"<pre><code>// Managed component storing a GameObject reference\npublic class PresentationGo : IComponentData\n{\n    public GameObject Prefab;\n}\n\n// Another example with texture reference\npublic class MaterialData : IComponentData\n{\n    public Texture2D Texture;\n    public Material Material;\n}\n\n// Accessing in a system (cannot use Burst)\npublic partial struct PresentationSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Must use ManagedAPI for managed components\n        foreach (var presentationGo in\n            SystemAPI.Query&lt;PresentationGo&gt;())\n        {\n            var instance = Object.Instantiate(presentationGo.Prefab);\n        }\n    }\n}\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#pros","title":"Pros","text":"<ul> <li> <p>Allows GameObject references - bridge between ECS and traditional Unity</p> </li> <li> <p>Stores complex managed types - textures, materials, C# objects with references</p> </li> <li> <p>Simplifies hybrid workflows - companion GameObjects for rendering/animation while using ECS for logic</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#cons","title":"Cons","text":"<ul> <li> <p>Breaks cache locality - stored separately from chunk data, causing Cache miss</p> </li> <li> <p>Cannot use Burst - no job compilation, must access on main thread with <code>SystemAPI.ManagedAPI</code></p> </li> <li> <p>Causes Structural changes - adding/removing managed components triggers archetype changes</p> </li> <li> <p>Garbage collection overhead - managed objects create GC pressure and allocations</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#best-use","title":"Best use","text":"<ul> <li> <p>GameObject companions - storing prefab/instance references for rendering while ECS handles logic</p> </li> <li> <p>Asset references - materials, textures, or other Unity assets that can't be baked to pure data</p> </li> <li> <p>Legacy integration - bridging existing MonoBehaviour systems during gradual DOTS conversion</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>You can use BlobAsset - for read-only shared data, use blob assets instead</p> </li> <li> <p>Performance is critical - managed components destroy cache performance, use IComponentData with value types</p> </li> <li> <p>You need parallel jobs - managed data can't be accessed in Burst jobs, use IComponentData with blittable types</p> </li> <li> <p>The data can be baked - if you can convert data during baking to value types, do it instead</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Managed%20IComponentData%20%28class%20components%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Cleanup pattern - use ICleanupComponentData to track when managed component removed and clean up GameObject instances to prevent leaks</p> </li> <li> <p>Minimize usage - use managed components sparingly as last resort - they negate most DOTS performance benefits</p> </li> <li> <p>Companion GameObject pattern - common pattern: managed component stores GameObject reference, separate system syncs transform from Entity to GameObject using <code>UnityEngineComponent&lt;Transform&gt;</code></p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Parent/","title":"Parent","text":"","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#description","title":"Description","text":"<ul> <li> <p>Parent entity reference storing Entity ID of this entity's parent - creates transform hierarchies where child LocalTransform is relative to parent's LocalToWorld</p> </li> <li> <p>Automatically maintained by <code>ParentSystem</code> which also updates reverse [[Child]] buffer on parent entities</p> </li> <li> <p>Structural change - adding/removing Parent moves entity to different Archetype, use EntityCommandBuffer in jobs</p> </li> <li> <p>Combined with LocalTransform by <code>LocalToWorldSystem</code> each frame: child's LocalToWorld = parent's LocalToWorld \u00d7 child's LocalTransform</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#example","title":"Example","text":"<pre><code>// Creating parent-child hierarchy\nEntity parent = em.CreateEntity(typeof(LocalTransform), typeof(LocalToWorld));\nem.SetComponentData(parent, LocalTransform.FromPosition(new float3(10, 0, 0)));\n\nEntity child = em.CreateEntity(typeof(LocalTransform), typeof(LocalToWorld), typeof(Parent));\nem.SetComponentData(child, new Parent { Value = parent });\nem.SetComponentData(child, LocalTransform.FromPosition(new float3(0, 5, 0)));\n// Child's world position will be (10, 5, 0) = parent (10,0,0) + child local (0,5,0)\n\n// Changing parent at runtime (structural change - use ECB in jobs)\nEntityCommandBuffer ecb = new EntityCommandBuffer(Allocator.TempJob);\nforeach (var (parent, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Parent&gt;&gt;()\n        .WithEntityAccess()\n        .WithAll&lt;NeedsReparent&gt;())\n{\n    Entity newParent = /* find new parent */;\n    ecb.SetComponent(entity, new Parent { Value = newParent });\n\n    // Or remove parent entirely (make world-space)\n    ecb.RemoveComponent&lt;Parent&gt;(entity);\n}\necb.Playback(state.EntityManager);\necb.Dispose();\n\n// Querying parent-child relationships\nEntity targetParent = /* ... */;\nforeach (var (parent, transform, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Parent&gt;, RefRW&lt;LocalTransform&gt;&gt;()\n        .WithEntityAccess())\n{\n    if (parent.ValueRO.Value == targetParent)\n    {\n        transform.ValueRW.Position += new float3(0, 1, 0);\n    }\n}\n\n// Access children through parent's Child buffer (reverse lookup)\nvar childBufferLookup = SystemAPI.GetBufferLookup&lt;Child&gt;(isReadOnly: true);\nif (childBufferLookup.TryGetBuffer(targetParent, out DynamicBuffer&lt;Child&gt; children))\n{\n    for (int i = 0; i &lt; children.Length; i++)\n    {\n        Entity childEntity = children[i].Value;\n        // Process each child...\n    }\n}\n</code></pre>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#pros","title":"Pros","text":"<ul> <li> <p>Automatic hierarchy - transform hierarchies work like GameObject parent-child relationships without manual matrix math</p> </li> <li> <p>Efficient propagation - <code>LocalToWorldSystem</code> updates all child transforms in parallel using jobs</p> </li> <li> <p>Bidirectional access - Parent component for upward lookup, [[Child]] buffer for downward iteration</p> </li> <li> <p>Clean API - single Entity reference is simple to understand and modify</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#cons","title":"Cons","text":"<ul> <li> <p>Structural change - adding/removing Parent moves entity to different archetype, causing overhead</p> </li> <li> <p>No immediate update - parent changes processed by <code>ParentSystem</code>, then <code>LocalToWorldSystem</code> computes new LocalToWorld next frame</p> </li> <li> <p>Query complexity - finding all descendants requires recursive traversal or separate hierarchy data structure</p> </li> <li> <p>Deep hierarchy cost - very deep hierarchies (10+ levels) incur matrix multiplication overhead each frame</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#best-use","title":"Best use","text":"<ul> <li> <p>Transform hierarchies - characters with bones, vehicles with turrets, UI panels with child elements</p> </li> <li> <p>Spatial attachment - projectiles attached to moving platforms, weapons attached to character hands</p> </li> <li> <p>Scene hierarchies - building structures where rooms are children of buildings, furniture children of rooms</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Static relationships - if parent-child never changes at runtime, consider baking final world transforms</p> </li> <li> <p>Frequent reparenting - constantly changing parents causes repeated structural changes, consider alternatives</p> </li> <li> <p>Very deep hierarchies - hierarchies deeper than 10 levels may benefit from flattening or caching</p> </li> <li> <p>No transform dependency - if child doesn't need parent's transform (just logical grouping), use custom component</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/Parent/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ParentSystem vs LocalToWorldSystem ordering: <pre><code>// Update order each frame:\n1. ParentSystem - Updates Parent/Child relationships (structural changes)\n2. LocalToWorldSystem - Computes LocalToWorld from hierarchy + LocalTransform\n3. Runs in TransformSystemGroup\n</code></pre></p> </li> <li> <p>Child buffer component (reverse lookup): <pre><code>// Parent entity automatically gets Child buffer with all children\nDynamicBuffer&lt;Child&gt; children = em.GetBuffer&lt;Child&gt;(parentEntity);\nfor (int i = 0; i &lt; children.Length; i++)\n{\n    Entity childEntity = children[i].Value;\n}\n// Child buffer automatically maintained by ParentSystem\n</code></pre></p> </li> <li> <p>Removing parent (make world-space): <pre><code>ecb.RemoveComponent&lt;Parent&gt;(entity);\n// Entity's LocalTransform becomes world-space position\n</code></pre></p> </li> <li> <p>Setting parent during entity creation: <pre><code>Entity child = em.CreateEntity(typeof(LocalTransform), typeof(LocalToWorld), typeof(Parent));\nem.SetComponentData(child, new Parent { Value = parent });\n// ParentSystem will add Child buffer to parent automatically\n</code></pre></p> </li> <li> <p>Hierarchy traversal pattern: <pre><code>void ProcessHierarchy(Entity entity, EntityManager em)\n{\n    // Process current entity\n\n    // Process children\n    if (em.HasBuffer&lt;Child&gt;(entity))\n    {\n        DynamicBuffer&lt;Child&gt; children = em.GetBuffer&lt;Child&gt;(entity);\n        for (int i = 0; i &lt; children.Length; i++)\n        {\n            ProcessHierarchy(children[i].Value, em);\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Parent component is just Entity reference: <pre><code>public struct Parent : IComponentData\n{\n    public Entity Value;  // Reference to parent entity\n}\n</code></pre></p> </li> <li> <p>Baking automatically preserves hierarchy - GameObject parent-child relationships automatically become Parent components, no manual assignment needed</p> </li> <li> <p>Parent changes are deferred - changes via ECB are deferred until playback, Parent/Child buffers updated by ParentSystem, LocalToWorld updated by LocalToWorldSystem</p> </li> <li> <p>Checking if entity has parent: <pre><code>// Entity with no Parent component is world-space\nbool isWorldSpace = !em.HasComponent&lt;Parent&gt;(entity);\n</code></pre></p> </li> <li> <p>Performance consideration - Parent/Child relationship updates batched in ParentSystem, LocalToWorld computation parallelized, deep hierarchies (10+ levels) multiply matrices for each level each frame</p> </li> </ul>","tags":["component","transform","hierarchy"]},{"location":"DOTS/Components/PostTransformMatrix/","title":"PostTransformMatrix","text":"","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#description","title":"Description","text":"<ul> <li> <p>Additional 4x4 matrix applied after LocalTransform in transform hierarchy - enables non-uniform scale (different X/Y/Z values) not supported by LocalTransform</p> </li> <li> <p>Composed after LocalTransform - final LocalToWorld = Parent.LocalToWorld \u00d7 LocalTransform \u00d7 PostTransformMatrix</p> </li> <li> <p>Primarily for non-uniform scale - most common use is stretching entities (ellipsoids, boxes) where X/Y/Z scale differs</p> </li> <li> <p>Optional component - only add when needed, most entities use LocalTransform uniform scale alone</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#example","title":"Example","text":"<pre><code>// Creating entity with non-uniform scale\nEntity entity = em.CreateEntity(\n    typeof(LocalTransform),\n    typeof(LocalToWorld),\n    typeof(PostTransformMatrix)\n);\n\n// Set uniform transform (position, rotation, uniform scale)\nem.SetComponentData(entity, LocalTransform.FromPositionRotationScale(\n    new float3(0, 0, 0),\n    quaternion.identity,\n    1f  // Uniform scale = 1\n));\n\n// Set non-uniform scale in PostTransformMatrix\nem.SetComponentData(entity, new PostTransformMatrix\n{\n    Value = float4x4.Scale(2f, 1f, 0.5f)  // Stretch X, normal Y, squash Z\n});\n\n// Animating non-uniform scale\nforeach (var postMatrix in SystemAPI.Query&lt;RefRW&lt;PostTransformMatrix&gt;&gt;())\n{\n    float scaleX = 1f + math.sin(time) * 0.5f;\n    postMatrix.ValueRW.Value = float4x4.Scale(scaleX, 1f, 1f);\n}\n\n// Shear/skew transformations\nfloat shear = 0.5f;\npostMatrix.ValueRW.Value = new float4x4(\n    new float4(1, 0, 0, 0),       // X basis\n    new float4(shear, 1, 0, 0),   // Y basis (sheared)\n    new float4(0, 0, 1, 0),       // Z basis\n    new float4(0, 0, 0, 1)        // Translation\n);\n\n// Combining rotation with non-uniform scale\nforeach (var (transform, postMatrix) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRW&lt;PostTransformMatrix&gt;&gt;())\n{\n    // Rotate via LocalTransform (uniform)\n    transform.ValueRW.Rotation = math.mul(\n        transform.ValueRW.Rotation,\n        quaternion.RotateY(deltaTime)\n    );\n\n    // Non-uniform scale via PostTransformMatrix\n    postMatrix.ValueRW.Value = float4x4.Scale(2f, 1f, 1f);\n}\n</code></pre>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#pros","title":"Pros","text":"<ul> <li> <p>Non-uniform scale support - enables different X/Y/Z scale values (ellipsoids, boxes, stretched objects)</p> </li> <li> <p>Preserves LocalTransform simplicity - LocalTransform stays simple, complexity isolated to PostTransformMatrix</p> </li> <li> <p>Full matrix control - supports shear, skew, and other matrix transformations beyond basic TRS</p> </li> <li> <p>Optional addition - only adds memory cost when needed, most entities don't require it</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#cons","title":"Cons","text":"<ul> <li> <p>Additional memory - adds 64 bytes (float4x4) per entity, significant overhead</p> </li> <li> <p>Composition complexity - must understand LocalTransform \u00d7 PostTransformMatrix multiplication order</p> </li> <li> <p>Performance cost - extra matrix multiplication per entity in <code>LocalToWorldSystem</code></p> </li> <li> <p>Less intuitive - matrix-based transformations harder to understand than simple position/rotation/scale</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#best-use","title":"Best use","text":"<ul> <li> <p>Non-uniform scale objects - rectangular boxes, ellipsoids, walls, platforms with different X/Y/Z dimensions</p> </li> <li> <p>Stretched meshes - UI elements, ribbons, beams where one axis scales differently</p> </li> <li> <p>Advanced transformations - shear, skew, or custom matrix operations not representable as position/rotation/uniform-scale</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Uniform scale sufficient - if entity scales equally in all directions, use LocalTransform.Scale</p> </li> <li> <p>Many entities - if most entities need non-uniform scale, consider alternative approaches (bake into mesh)</p> </li> <li> <p>Simple transformations - basic position/rotation/uniform-scale should use LocalTransform alone</p> </li> <li> <p>Performance critical - extra matrix multiplication overhead may be unacceptable for thousands of entities</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/PostTransformMatrix/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Transform composition order: <pre><code>// With PostTransformMatrix:\nLocalToWorld = Parent.LocalToWorld \u00d7 LocalTransform \u00d7 PostTransformMatrix\n\n// Without PostTransformMatrix:\nLocalToWorld = Parent.LocalToWorld \u00d7 LocalTransform\n</code></pre></p> </li> <li> <p>PostTransformMatrix structure: <pre><code>public struct PostTransformMatrix : IComponentData\n{\n    public float4x4 Value;  // Applied after LocalTransform\n}\n</code></pre></p> </li> <li> <p>Creating non-uniform scale: <pre><code>new PostTransformMatrix { Value = float4x4.Scale(2f, 1f, 0.5f) }\nnew PostTransformMatrix { Value = float4x4.Scale(new float3(x, y, z)) }\n</code></pre></p> </li> <li> <p>Common transformations: <pre><code>float4x4.Scale(2, 1, 0.5)                  // Non-uniform scale\nfloat4x4.Scale(-1, 1, 1)                   // Flip/mirror on X axis\nnew float4x4(...)                          // Custom shear/skew matrix\n</code></pre></p> </li> <li> <p>When to use PostTransformMatrix vs LocalTransform:</p> </li> <li>Use LocalTransform.Scale (uniform): Spheres, cubes, characters, most props</li> <li> <p>Use PostTransformMatrix (non-uniform): Boxes (width \u2260 height), ellipsoids, walls, UI with aspect ratio</p> </li> <li> <p>Avoiding PostTransformMatrix overhead:</p> </li> <li>Option 1: Bake scale into mesh vertices during authoring</li> <li>Option 2: Use separate entity types (with/without PostTransformMatrix)</li> <li> <p>Option 3: Check if close to uniform, use uniform scale if within epsilon</p> </li> <li> <p>LocalToWorldSystem processing: <pre><code>// If no PostTransformMatrix:\nLocalToWorld = LocalTransform.ToMatrix()\n\n// If has PostTransformMatrix:\nLocalToWorld = LocalTransform.ToMatrix() \u00d7 PostTransformMatrix.Value\n</code></pre></p> </li> <li> <p>Memory impact - PostTransformMatrix adds 64 bytes per entity, reduces chunk capacity from ~500 to ~400 entities</p> </li> <li> <p>Rotation gotcha - rotation in PostTransformMatrix applied AFTER LocalTransform rotation, can produce unexpected results. Usually put all rotation in LocalTransform, only scale in PostTransformMatrix</p> </li> </ul>","tags":["component","transform","advanced"]},{"location":"DOTS/Components/Tag%20Component/","title":"Tag Component","text":"","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#description","title":"Description","text":"<ul> <li> <p>Empty IComponentData or ICleanupComponentData.</p> </li> <li> <p>Used only for marking entities.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#example","title":"Example","text":"<pre><code>public struct PlayerTag : IComponentData {}\n</code></pre>","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#pros","title":"Pros","text":"<ul> <li> <p>Minimal memory overhead.</p> </li> <li> <p>Simple filtering.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#cons","title":"Cons","text":"<ul> <li>No data, only a flag.</li> </ul>","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#best-use","title":"Best use","text":"<ul> <li> <p>Mark entity type (enemy, player, projectile).</p> </li> <li> <p>Toggle behavior quickly.</p> </li> </ul>","tags":["component"]},{"location":"DOTS/Components/Tag%20Component/#see-also","title":"See also","text":"<ul> <li>ECS Design Decisions - Tag component design patterns and architectural considerations</li> <li>Tag-Based Behavior Selection - Advanced tag patterns for behavior control</li> <li>Disable Tag Pattern - Exclusion filtering with disable tags</li> </ul>","tags":["component"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/","title":"UnityObjectRef (UnityEngine.Object references)","text":"","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#description","title":"Description","text":"<ul> <li> <p>Blittable wrapper for UnityEngine.Object references allowing Unity objects (GameObject, Texture, Material, etc.) in IComponentData while remaining Burst compatible</p> </li> <li> <p>Stores object reference as instance ID internally, enabling Burst compilation unlike direct <code>UnityEngine.Object</code> references</p> </li> <li> <p>Provides type-safe API for getting/setting Unity objects while maintaining ECS performance characteristics</p> </li> <li> <p>Alternative to Managed IComponentData for Unity object references while keeping components blittable</p> </li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#example","title":"Example","text":"<pre><code>// Component storing Unity object reference\npublic struct CharacterSkin : IComponentData\n{\n    // UnityObjectRef&lt;T&gt; instead of direct Material reference\n    public UnityObjectRef&lt;Material&gt; SkinMaterial;\n    public UnityObjectRef&lt;Texture2D&gt; SkinTexture;\n}\n\n// Baker creates UnityObjectRef from Unity objects\npublic class CharacterAuthoring : MonoBehaviour\n{\n    public Material CharacterMaterial;\n    public Texture2D CharacterTexture;\n\n    public class Baker : Baker&lt;CharacterAuthoring&gt;\n    {\n        public override void Bake(CharacterAuthoring authoring)\n        {\n            Entity entity = GetEntity(TransformUsageFlags.Renderable);\n\n            AddComponent(entity, new CharacterSkin\n            {\n                // Implicit conversion from Material to UnityObjectRef&lt;Material&gt;\n                SkinMaterial = authoring.CharacterMaterial,\n                SkinTexture = authoring.CharacterTexture\n            });\n\n            DependsOn(authoring.CharacterMaterial);\n            DependsOn(authoring.CharacterTexture);\n        }\n    }\n}\n\n// Using UnityObjectRef in systems (CANNOT be Burst compiled)\npublic partial struct CharacterRenderSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Access requires managed API - no Burst\n        foreach (var skin in SystemAPI.Query&lt;RefRO&lt;CharacterSkin&gt;&gt;())\n        {\n            // Get Unity object from UnityObjectRef\n            Material material = skin.ValueRO.SkinMaterial.Value;\n            Texture2D texture = skin.ValueRO.SkinTexture.Value;\n\n            if (material != null &amp;&amp; texture != null)\n            {\n                material.mainTexture = texture;\n            }\n        }\n    }\n}\n\n// Checking if reference is valid\nforeach (var skin in SystemAPI.Query&lt;RefRO&lt;CharacterSkin&gt;&gt;())\n{\n    if (skin.ValueRO.SkinMaterial.Value != null)\n    {\n        // Material is valid\n    }\n}\n\n// Setting UnityObjectRef at runtime\nMaterial newMaterial = Resources.Load&lt;Material&gt;(\"NewSkin\");\nforeach (var skin in SystemAPI.Query&lt;RefRW&lt;CharacterSkin&gt;&gt;())\n{\n    skin.ValueRW.SkinMaterial = newMaterial;\n}\n</code></pre>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#pros","title":"Pros","text":"<ul> <li> <p>Blittable component - keeps IComponentData blittable, better cache performance than managed components</p> </li> <li> <p>Burst storage compatible - component can be stored and moved by Burst code (though accessing <code>.Value</code> requires managed context)</p> </li> <li> <p>Type safety - <code>UnityObjectRef&lt;Material&gt;</code> ensures only Material references stored</p> </li> <li> <p>Null-safe - can check <code>.Value != null</code> to verify object still exists</p> </li> <li> <p>Instance ID based - survives Unity domain reloads better than direct references</p> </li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#cons","title":"Cons","text":"<ul> <li> <p>Accessing requires managed context - cannot use <code>.Value</code> in Burst jobs, must access on main thread</p> </li> <li> <p>Performance overhead - accessing <code>.Value</code> requires instance ID lookup, slower than direct reference</p> </li> <li> <p>Not fully ECS - still bridges to Unity object system, not pure data-oriented</p> </li> <li> <p>Broken references possible - if Unity object destroyed, <code>.Value</code> returns null (no automatic cleanup)</p> </li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#best-use","title":"Best use","text":"<ul> <li> <p>Baked asset references - materials, textures, prefabs converted during Baking</p> </li> <li> <p>Rendering data - storing meshes, materials, textures for hybrid rendering</p> </li> <li> <p>Audio/VFX - audio clips, particle system prefabs, visual effect assets</p> </li> <li> <p>Configuration assets - ScriptableObject references for game configuration</p> </li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Pure ECS is goal - if building fully data-oriented system, avoid Unity object references</p> </li> <li> <p>Need Burst access - if jobs need to access data, use BlobAsset to convert to blittable format</p> </li> <li> <p>Frequent runtime changes - if references change often, managed components may be simpler</p> </li> <li> <p>Can be baked to data - if Unity object data can be converted to pure data during baking, do that instead</p> </li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Implicit conversions: <pre><code>UnityObjectRef&lt;Material&gt; materialRef = myMaterial;  // Implicit\nMaterial material = materialRef.Value;               // Explicit via .Value\n</code></pre></p> </li> <li> <p>Null handling: <pre><code>if (materialRef.Value != null) { /* Safe to use */ }\nmaterialRef.Value?.SetFloat(\"_Metallic\", 1.0f);  // Null-conditional\n</code></pre></p> </li> <li> <p>Instance ID access: <pre><code>int id = materialRef.instanceID;\n// Useful for comparison or storage\n</code></pre></p> </li> <li> <p>Equality comparison: <pre><code>if (refA == refB)  // Compares instance IDs\n    Debug.Log(\"Same object\");\n</code></pre></p> </li> <li> <p>Works with Resources and AssetDatabase: <pre><code>var material = Resources.Load&lt;Material&gt;(\"MyMaterial\");\ncomponent.MaterialRef = material;\n</code></pre></p> </li> <li> <p>Cleanup pattern - use ICleanupComponentData to track when entities with UnityObjectRef destroyed if need custom cleanup</p> </li> <li> <p>Not serialized directly - Unity serializes as instance ID, resolves to object on load</p> </li> <li> <p>Performance vs Managed Components:</p> </li> <li>\u2705 Better cache performance (component stays in chunk)</li> <li>\u2705 Survives across Burst boundaries</li> <li>\u274c Accessing <code>.Value</code> still requires managed context</li> <li>\u274c Lookup overhead vs direct managed reference</li> </ul>","tags":["component","hybrid"]},{"location":"DOTS/Components/UnityObjectRef%20%28UnityEngine.Object%20references%29/#comparison-with-alternatives","title":"Comparison with Alternatives","text":"Approach Blittable Burst Storage Burst Access Use Case <code>UnityObjectRef&lt;T&gt;</code> \u2705 \u2705 \u274c Asset references in baked data [[Managed IComponentData (class components)|Managed Component]] \u274c \u274c \u274c GameObject companions [[BlobAsset (immutable data)|BlobAsset]] \u2705 \u2705 \u2705 Immutable configuration data Direct <code>UnityEngine.Object</code> \u274c \u274c \u274c Not allowed in IComponentData","tags":["component","hybrid"]},{"location":"DOTS/Glossary/Allocators/","title":"Allocators","text":""},{"location":"DOTS/Glossary/Allocators/#allocators","title":"Allocators","text":"<p>Memory allocation strategies in Unity for native containers - determines lifetime and performance characteristics of allocated memory.</p> <p>Common allocators: - Allocator.Temp - single frame, fastest, disposed automatically - Allocator.TempJob - up to 4 frames, for jobs - Allocator.Persistent - permanent until manual disposal - Allocator.Domain - lives until domain unload (rare use) - WorldUpdateAllocator - lives until system group update completes, auto-disposes (recommended for temp data in systems)</p> <p>Usage: <pre><code>// TempJob for jobs\nvar array = new NativeArray&lt;int&gt;(100, Allocator.TempJob);\n// Use in job\narray.Dispose(state.Dependency); // Schedule disposal after job\n\n// WorldUpdateAllocator - auto-disposes, no manual cleanup needed!\nvar tempData = CollectionHelper.CreateNativeArray&lt;int&gt;(100,\n    state.WorldUpdateAllocator); // Automatically disposed when system group update completes\n// Use in system, no Dispose() needed\n</code></pre></p> <p>Rules: - <code>Allocator.Temp</code> - use for single-frame temporary data - <code>Allocator.TempJob</code> - use for data passed to jobs (dispose after) - <code>Allocator.Persistent</code> - use for data that lives across frames - <code>WorldUpdateAllocator</code> - preferred for temp allocations in systems - automatic cleanup, no manual Dispose needed</p> <p>See also: Job, Rate Managers, NativeArray, NativeList</p>"},{"location":"DOTS/Glossary/Archetype/","title":"Archetype","text":""},{"location":"DOTS/Glossary/Archetype/#archetype","title":"Archetype","text":"<p>Unique combination of Component types that defines an Entity's structure - entities with the same set of components share the same archetype.</p> <p>Archetypes determine memory layout and enable efficient querying. Entities are grouped into chunks by archetype, allowing systems to iterate over entities with specific components at maximum speed.</p> <p>Key characteristics: - Component type set - defined by which components an entity has (order doesn't matter) - Memory grouping - all entities with same archetype stored together in chunks - Query matching - systems query by archetype to find entities to process - Structural identity - changing components changes archetype (moves entity to different chunk)</p> <p>Examples: <pre><code>// Archetype A: [Health, Transform, Player]\nEntity player;  // Has Health, Transform, Player components\n\n// Archetype B: [Health, Transform, Enemy]\nEntity enemy;   // Has Health, Transform, Enemy components\n\n// Different archetypes - stored in different chunks!\n</code></pre></p> <p>Archetype changes (Structural changes): - Adding component: entity moves to archetype with that component - Removing component: entity moves to archetype without that component - Structural changes trigger Sync points - avoid in hot paths</p> <p>Query example: <pre><code>// Queries archetype: [Health, Transform, *]\n// Matches any archetype containing Health AND Transform\nforeach (var (health, transform) in\n    SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRW&lt;Transform&gt;&gt;())\n{\n    // Only processes entities with both components\n}\n</code></pre></p> <p>Performance implications: - Good: Many entities per archetype = efficient iteration - Bad: Many archetypes with few entities = poor cache utilization, sparse chunks</p> <p>See also: Entity, Component, Chunk, Structural changes</p>"},{"location":"DOTS/Glossary/Aspect/","title":"Aspect","text":""},{"location":"DOTS/Glossary/Aspect/#aspect","title":"Aspect","text":"<p>Component grouping wrapper that bundles multiple related components together with their behavior logic, implemented via IAspect interface.</p> <p>Aspects provide reusable behavior that can be shared across systems and jobs, and help circumvent query limitations when you need more components than the query parameter limit.</p> <p>Key characteristics: - Component composition - groups RefRO/RefRW fields for multiple components - Behavior encapsulation - methods that operate on the grouped components - Automatic query generation - when you query for an aspect, Unity generates the underlying entity query - Type safety - ensures all required components are present at compile time</p> <p>Example: <code>ProjectileAspect</code> groups <code>Transform</code>, <code>Speed</code>, <code>Target</code> components with a <code>Move()</code> method</p> <p>See also: IAspect (component grouping), RefRO and RefRW</p>"},{"location":"DOTS/Glossary/Baking/","title":"Baking","text":""},{"location":"DOTS/Glossary/Baking/#baking","title":"Baking","text":"<p>Edit-time conversion process that transforms GameObject authoring data (MonoBehaviours, GameObjects, prefabs) into optimized ECS runtime data (entities, components, BlobAssets).</p> <p>Baking happens in a separate baking world, not the runtime world. When you modify a GameObject in the Editor, Unity automatically triggers incremental rebaking of affected entities, providing instant feedback.</p> <p>The Baker class defines the conversion logic, specifying how authoring data becomes runtime components. <p>Key characteristics: - Automatic and incremental - only rebakes changed GameObjects - Edit-time only - happens during authoring, not at runtime - Optimizes data - converts Unity-friendly authoring format to cache-friendly runtime format - Dependency tracking - tracks asset dependencies to trigger rebakes when assets change</p> <p>Example: GameObject with <code>HealthAuthoring</code> MonoBehaviour \u2192 bakes to Entity with <code>Health</code> IComponentData</p> <p>See also: Baker (authoring conversion), TransformUsageFlags</p>"},{"location":"DOTS/Glossary/Burst/","title":"Burst","text":""},{"location":"DOTS/Glossary/Burst/#burst","title":"Burst","text":"<p>High-performance compiler that translates C# code to highly optimized native CPU code using LLVM, providing 10-100x performance improvements over standard C#.</p> <p>Burst uses SIMD (Single Instruction Multiple Data) vectorization, aggressive optimizations, and platform-specific code generation to achieve near-C++ performance from C# code.</p> <p>Key characteristics: - SIMD vectorization - automatically uses CPU vector instructions (SSE, AVX, NEON) - Zero garbage collection - no managed allocations or GC pauses - Platform-optimized - generates optimal code for each target platform - Restricted C# subset - no managed objects, exceptions, or virtual calls</p> <p>What Burst allows: - Blittable types (primitives, structs) - Unity.Mathematics (math library) - Native collections (NativeArray, NativeList) - IComponentData, DynamicBuffer, BlobAsset</p> <p>What Burst forbids: - Managed objects (classes, strings) - Garbage collection allocations - Exceptions (try/catch/throw) - Virtual method calls - <code>Debug.Log</code></p> <p>Example: <code>[BurstCompile]</code> attribute on ISystem or IJobEntity enables Burst compilation</p> <p>See also: BurstCompile, IJobEntity, ISystem</p>"},{"location":"DOTS/Glossary/Cache%20hit/","title":"Cache hit","text":""},{"location":"DOTS/Glossary/Cache%20hit/#cache-hit","title":"Cache hit","text":"<p>Successful retrieval of data from CPU cache - requested memory is already in cache (L1/L2/L3), avoiding slow RAM access.</p> <p>Cache hits are 10-100x faster than cache misses. Unity DOTS achieves high cache hit rates through: - SoA layout - components stored contiguously - Chunk-based memory - entities grouped by Archetype - Sequential iteration - systems process chunks linearly</p> <p>Cache hit rate = (cache hits) / (total memory accesses) - higher is better.</p> <p>See also: Cache miss, Cache-friendly, Levels of cache</p>"},{"location":"DOTS/Glossary/Cache%20miss/","title":"Cache miss","text":"<p>It happens when the CPU tries to read some data, but it\u2019s not already in the CPU\u2019s cache, so it has to fetch it from a slower memory layer (like RAM). In DOTS terms - your next component is far away in memory (scattered layout), forcing the CPU to pause and wait for RAM. The opposite of this term is cache hit.</p>"},{"location":"DOTS/Glossary/Cache-friendly/","title":"Cache friendly","text":"<p>Data is laid out in memory so that when the CPU loads one piece of data, it\u2019s likely to also load other nearby data into its CPU cache \u2014 reducing the number of slow memory fetches from RAM.</p>"},{"location":"DOTS/Glossary/Cache-friendly/#why-it-matters-here","title":"Why it matters here","text":"<p>Modern CPUs don\u2019t read memory one byte at a time \u2014 they fetch it in cache lines (usually 64 bytes).  If your data is contiguous in memory and you process it in order, the CPU can pre-load the next data chunk while you\u2019re still working on the current one.</p> <p>ECS chunk layout and BlobAssets are designed for this:</p> <ul> <li> <p>IComponentData stores many entities\u2019 components of the same type back-to-back in a chunks \u2192 processing them in a loop hits data that\u2019s already in L1/L2 cache.</p> </li> <li> <p>BlobAssets put all their fields, arrays, and strings in a single Contiguous memory block \u2192 reading one part brings nearby parts into cache automatically.</p> </li> </ul>"},{"location":"DOTS/Glossary/Cache-friendly/#example","title":"Example","text":"<p>Imagine you have 1000 enemies and you want to update their health:</p> <ul> <li> <p>Cache-friendly: All <code>Health</code> values are stored consecutively in a chunk. CPU fetches a cache line and gets several <code>Health</code> structs at once \u2192 minimal RAM trips.</p> </li> <li> <p>Cache-unfriendly: Each <code>Health</code> is scattered in memory (e.g., as part of different GameObjects in MonoBehaviours). Every access may trigger a separate RAM fetch \u2192 slower.</p> </li> </ul>"},{"location":"DOTS/Glossary/Cache-friendly/#tldr-in-dots-terms","title":"TL;DR in DOTS terms:","text":"<p>Cache-friendly = Contiguous data layout \u2192 fewer CPU cache misses\u2192 much faster iteration over large sets of entities.</p>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/","title":"Chunk rearrangement","text":"<p>In DOTS, Chunk rearrangement means Unity moves entities between [[chunks]] in memory when their Archetype changes (i.e., the set of components they have changes).</p>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/#why-rearrangement-happens","title":"Why rearrangement happens","text":"<p>If an entity adds or removes a Component, it no longer fits in its current chunk\u2019s Archetype. Unity must: 1. Copy that entity\u2019s data from the old Chunk to a Chunk of the new Archetype.</p> <ol> <li> <p>Remove it from the old Chunk.</p> </li> <li> <p>Possibly reorder the other entities in that Chunk to keep it packed.</p> </li> </ol>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/#example","title":"Example","text":"<p>Initial state: <pre><code>Chunk A: Archetype {Position, Velocity}\n[Entity1] [Entity2] [Entity3]\n</code></pre></p> <p>You add <code>Health</code> to <code>Entity2</code> \u2192</p> <ul> <li> <p>Old archetype: <code>{Position, Velocity}</code></p> </li> <li> <p>New archetype: <code>{Position, Velocity, Health}</code></p> </li> </ul> <p>Result: <pre><code>Chunk A: Archetype {Position, Velocity}\n[Entity1] [Entity2]\n\nChunk B: Archetype {Position, Velocity, Health} \n[Entity2]\n</code></pre></p>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/#why-it-matters","title":"Why it matters","text":"<ul> <li> <p>Performance cost: Moving entities between chunks is structural change \u2014 relatively expensive because of memory copy + possible Chunk allocations.</p> </li> <li> <p>Cache impact: Moving entities might break sequential processing order if your queries expect certain memory locality.</p> </li> <li> <p>Job safety: Structural changes can\u2019t happen while jobs are reading/writing those entities, so Unity adds Sync points (stalls).</p> </li> </ul>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/#when-youll-see-chunk-rearrangement","title":"When you\u2019ll see chunk rearrangement","text":"<ul> <li> <p>Adding/removing components.</p> </li> <li> <p>Instantiating or destroying entities.</p> </li> <li> <p>Converting from prefab archetype to runtime archetype.</p> </li> </ul>"},{"location":"DOTS/Glossary/Chunk%20rearrangement/#tip","title":"\ud83d\udca1Tip","text":"<p>Enabling/disabling IEnableableComponent changes the enabled mask but does not cause rearrangement \u2014 faster!.</p>"},{"location":"DOTS/Glossary/Chunk/","title":"Chunk","text":""},{"location":"DOTS/Glossary/Chunk/#chunk","title":"Chunk","text":"<p>16KB memory block that stores entities with the same Archetype in SoA layout (Structure of Arrays).</p> <p>Chunks are the fundamental storage unit in Unity ECS - components of the same type are stored contiguously within a chunk for Cache-friendly iteration.</p> <p>Key facts: - Fixed size: 16KB per chunk - Same archetype: all entities in chunk have identical component set - Capacity: varies by archetype (typically 32-128 entities) - SoA storage: each component type has its own array</p> <p>Memory layout: <pre><code>Chunk (16KB):\n\u251c\u2500 [Health, Health, Health, ...]     (all Health components)\n\u251c\u2500 [Transform, Transform, ...]        (all Transform components)\n\u2514\u2500 [Velocity, Velocity, ...]          (all Velocity components)\n</code></pre></p> <p>Performance: - Good: full chunks = efficient memory use - Bad: sparse chunks (few entities) = wasted memory, poor iteration</p> <p>See also: Archetype, SoA layout, Cache-friendly, Chunk rearrangement</p>"},{"location":"DOTS/Glossary/Component/","title":"Component","text":""},{"location":"DOTS/Glossary/Component/#component","title":"Component","text":"<p>Data container attached to an Entity - pure data struct (no logic) that defines what an entity \"has\" or \"is\".</p> <p>Components are stored in memory using SoA layout (Structure of Arrays) within chunks, grouped by Archetype for optimal Cache-friendly iteration.</p> <p>Component types: - IComponentData - General-purpose component (struct, blittable) - ISharedComponentData - Shared across entities for memory efficiency - IBufferElementData - Dynamic array attached to entity - BlobAsset - Immutable shared configuration data - IEnableableComponent - Component that can be toggled on/off - ICleanupComponentData - Persists after entity destroyed for cleanup logic - Tag Component - Empty struct for filtering (no data) - Managed IComponentData - Class-based component (not recommended)</p> <p>Key characteristics: - Data only - no methods or behavior (logic lives in systems) - Blittable structs - must be copyable byte-by-byte for Burst - Cache-optimized storage - stored contiguously in chunks by type</p> <p>Example: <pre><code>public struct Health : IComponentData\n{\n    public float Current;\n    public float Max;\n}\n</code></pre></p> <p>See also: Entity, Archetype, ISystem</p>"},{"location":"DOTS/Glossary/Contiguous/","title":"Contiguous","text":""},{"location":"DOTS/Glossary/Contiguous/#contiguous","title":"Contiguous","text":"<p>Data stored in consecutive memory addresses without gaps - elements placed next to each other in a continuous block.</p> <p>Contiguous memory is fundamental to Cache-friendly code because CPU cache prefetcher can load upcoming data automatically.</p> <p>Unity ECS contiguous storage: - Components in Chunk stored contiguously by type (SoA layout) - Entities with same Archetype grouped together - Iteration accesses memory sequentially</p> <p>Example: <pre><code>Contiguous array: [1][2][3][4][5] - cache-friendly\nFragmented data: [1]--[2]----[3]- - cache-unfriendly\n</code></pre></p> <p>See also: Cache-friendly, SoA layout, Chunk</p>"},{"location":"DOTS/Glossary/Entity/","title":"Entity","text":""},{"location":"DOTS/Glossary/Entity/#entity","title":"Entity","text":"<p>Unique identifier (ID) for a game object in Unity ECS - lightweight handle that represents an instance without storing any data itself.</p> <p>An Entity is just an integer index combined with a version number, taking only 8 bytes of memory. All actual game data lives in components attached to the entity.</p> <p>Key characteristics: - ID only - contains no data, just points to components - Lightweight - 8 bytes (int Index + int Version) - Version tracking - version increments when entity destroyed and ID reused, preventing stale references - Archetype-based - entity's Archetype defines what components it has</p> <p>Example: <pre><code>Entity playerEntity;  // Just an ID\n</code></pre></p> <p>The entity with components Health, Transform, and Player has archetype <code>[Health, Transform, Player]</code> and lives in a Chunk with other entities of the same archetype.</p> <p>See also: Component, Archetype, IComponentData</p>"},{"location":"DOTS/Glossary/EntityManager/","title":"EntityManager","text":""},{"location":"DOTS/Glossary/EntityManager/#entitymanager","title":"EntityManager","text":"<p>Primary interface for creating, destroying, and modifying entities and their components in a World - handles all Structural changes and entity data manipulation.</p> <p>The EntityManager is the central authority for entity operations, managing the underlying archetypes and chunks automatically as entities are created and modified.</p> <p>Key characteristics: - One per World - each World has its own EntityManager accessed via <code>World.EntityManager</code> - Structural change authority - only way to add/remove components or create/destroy entities - Main thread only - most operations must run on main thread (use EntityCommandBuffer in jobs) - Automatic archetype management - creates and manages archetypes transparently</p> <p>Common methods:</p> <p>Entity creation/destruction: <pre><code>Entity entity = entityManager.CreateEntity();\nEntity copy = entityManager.Instantiate(entity);\nentityManager.DestroyEntity(entity);\n</code></pre></p> <p>Component operations: <pre><code>entityManager.AddComponent&lt;Health&gt;(entity);\nentityManager.RemoveComponent&lt;Health&gt;(entity);\nbool has = entityManager.HasComponent&lt;Health&gt;(entity);\n\nHealth health = entityManager.GetComponent&lt;Health&gt;(entity);\nentityManager.SetComponent(entity, new Health { Value = 100 });\n</code></pre></p> <p>Buffer operations: <pre><code>DynamicBuffer&lt;Waypoint&gt; buffer = entityManager.GetBuffer&lt;Waypoint&gt;(entity);\nentityManager.AddBuffer&lt;Waypoint&gt;(entity);\n</code></pre></p> <p>EntityQuery operations: <pre><code>EntityQuery query = entityManager.CreateEntityQuery(typeof(Health), typeof(Transform));\nNativeArray&lt;Entity&gt; entities = query.ToEntityArray(Allocator.Temp);\n</code></pre></p> <p>Important: Operations that add/remove components or create/destroy entities are Structural changes that can trigger Sync points. In jobs, use EntityCommandBuffer to defer these changes to the main thread.</p> <p>See also: Entity, World, Component, EntityCommandBuffer, Structural changes</p>"},{"location":"DOTS/Glossary/EntityQuery/","title":"EntityQuery","text":""},{"location":"DOTS/Glossary/EntityQuery/#entityquery","title":"EntityQuery","text":"<p>Efficient filtering system that finds all entities having a specified set of Component types - core mechanism for processing entities in Unity DOTS systems.</p> <p>An EntityQuery gathers chunks from all matching archetypes, enabling fast iteration over large numbers of entities without searching the entire World.</p> <p>Key characteristics: - Archetype matching - finds archetypes that include specified component types - Cached results - matching archetypes are cached until new archetypes are added to the world - Flexible filtering - supports inclusion, exclusion, and optional component types - Cache-friendly - returns entire chunks for efficient sequential processing</p> <p>Query construction: <pre><code>// All entities with Health AND Transform components\nEntityQuery query = entityManager.CreateEntityQuery(\n    typeof(Health),\n    typeof(Transform)\n);\n\n// With exclusions - has Health and Transform, but NOT Dead\nEntityQuery query2 = new EntityQueryBuilder(Allocator.Temp)\n    .WithAll&lt;Health, Transform&gt;()\n    .WithNone&lt;Dead&gt;()\n    .Build(ref systemState);\n</code></pre></p> <p>Querying behavior: - Query for <code>[Health, Transform]</code> matches entities with:   - Exactly <code>[Health, Transform]</code> \u2713   - Also <code>[Health, Transform, Player]</code> \u2713 (has more components)   - But NOT <code>[Health]</code> alone \u2717 (missing Transform)</p> <p>Common operations: <pre><code>int count = query.CalculateEntityCount();\nNativeArray&lt;Entity&gt; entities = query.ToEntityArray(Allocator.Temp);\nNativeArray&lt;Health&gt; healths = query.ToComponentDataArray&lt;Health&gt;(Allocator.Temp);\n</code></pre></p> <p>In systems: <pre><code>public partial struct HealthSystem : ISystem\n{\n    EntityQuery query;\n\n    public void OnCreate(ref SystemState state)\n    {\n        query = state.GetEntityQuery(typeof(Health), typeof(Transform));\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (health, transform) in SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;Transform&gt;&gt;())\n        {\n            // Process entities...\n        }\n    }\n}\n</code></pre></p> <p>Performance note: Query caching makes repeated queries very cheap. The archetype cache is only invalidated when new archetypes are added, which stabilizes early in the program lifetime.</p> <p>See also: Entity, Component, Archetype, Chunk, SystemAPI</p>"},{"location":"DOTS/Glossary/Immutable/","title":"Immutable","text":""},{"location":"DOTS/Glossary/Immutable/#immutable","title":"Immutable","text":"<p>Data that cannot be modified after creation - read-only and unchanging throughout its lifetime.</p> <p>In Unity DOTS, BlobAssets are immutable shared data structures that multiple entities can reference without copying.</p> <p>Benefits: - Thread-safe - multiple threads can read safely - Memory efficient - shared across entities - Performance - no need for synchronization</p> <p>Example: Configuration data, lookup tables, shared mesh data</p> <p>See also: BlobAsset (immutable data), Shared</p>"},{"location":"DOTS/Glossary/Job/","title":"Job","text":""},{"location":"DOTS/Glossary/Job/#job","title":"Job","text":"<p>Parallel work unit that executes on worker threads, processing entity data in a Thread-safe and Burst-compilable manner for maximum performance.</p> <p>Jobs are the primary way to parallelize entity processing in DOTS. Unity's job system schedules jobs across CPU cores, handles dependencies, and ensures thread safety.</p> <p>Key characteristics: - Parallel execution - runs on multiple worker threads simultaneously - Burst compatible - compiles to highly optimized native code - Automatic scheduling - Unity schedules jobs efficiently across available CPU cores - Dependency tracking - job dependencies ensure correct execution order</p> <p>Common job types: - IJobEntity - simplified entity iteration (most common) - IJobChunk - manual chunk iteration for advanced control - ITriggerEventsJob - physics trigger event processing - IJobParallelFor - general parallel for loops</p> <p>Example: <code>ProjectileMoveJob : IJobEntity</code> processes all projectile entities in parallel</p> <p>See also: IJobEntity, BurstCompile, ChunkIndexInQuery</p>"},{"location":"DOTS/Glossary/Levels%20of%20cache/","title":"Levels of cache","text":""},{"location":"DOTS/Glossary/Levels%20of%20cache/#quick-breakdown","title":"Quick breakdown","text":""},{"location":"DOTS/Glossary/Levels%20of%20cache/#modern-cpus-have-multiple-levels-of-cache","title":"Modern CPUs have multiple levels of cache","text":"<ul> <li> <p>L1 cache \u2192 fastest (~1\u20134 CPU cycles)</p> </li> <li> <p>L2 cache \u2192 still fast (~4\u201312 cycles)</p> </li> <li> <p>L3 cache \u2192 slower (~12\u201350 cycles)</p> </li> <li> <p>RAM \u2192 much slower (~100\u2013300 cycles)</p> </li> </ul>"},{"location":"DOTS/Glossary/Levels%20of%20cache/#when-you-access-a-variable","title":"When you access a variable:","text":"<ol> <li> <p>CPU checks if it\u2019s already in L1 cache (fastest).</p> </li> <li> <p>If not, it checks L2, then L3.</p> </li> <li> <p>If it\u2019s nowhere in cache \u2192 Cache miss \u2192 fetch from RAM (slow).</p> </li> </ol>"},{"location":"DOTS/Glossary/Lookup/","title":"Lookup","text":""},{"location":"DOTS/Glossary/Lookup/#lookup","title":"Lookup","text":"<p>Random access container that provides dictionary-like access to component or buffer data by Entity ID, enabling entity relationships and references.</p> <p>Lookups involve random memory access, causing cache misses and poor performance compared to sequential iteration. Use only when necessary for entity relationships (targets, parents, references).</p> <p>Two types: - ComponentLookup - random access to IComponentData - BufferLookup - random access to DynamicBuffer <p>Key characteristics: - Must be updated - call <code>lookup.Update(ref state)</code> before each use as entity storage can move - Read-only or read-write - created with <code>GetComponentLookup&lt;T&gt;(isReadOnly)</code> parameter - Thread-safe with [ReadOnly] - read-only lookups can be used in parallel jobs - HasComponent check - use <code>lookup.HasComponent(entity)</code> before accessing to avoid errors</p> <p>Example: Projectile system uses <code>ComponentLookup&lt;LocalToWorld&gt;</code> to get target entity's position</p> <p>See also: ComponentLookup and BufferLookup, ReadOnly and Optional, ITriggerEventsJob</p>"},{"location":"DOTS/Glossary/Shared/","title":"Shared","text":""},{"location":"DOTS/Glossary/Shared/#shared","title":"Shared","text":"<p>Data referenced by multiple entities without duplication - stored once in memory and accessed by many.</p> <p>In Unity DOTS: - ISharedComponentData - component value shared across entities - BlobAsset - immutable configuration shared via reference</p> <p>Benefits: - Memory efficiency - store once, use many times - Cache-friendly - entities grouped by shared value in same Chunk</p> <p>Trade-offs: - ISharedComponentData changes cause Chunk rearrangement - Must be Immutable or managed carefully for thread safety</p> <p>See also: ISharedComponentData, BlobAsset (immutable data), Immutable</p>"},{"location":"DOTS/Glossary/SoA%20layout/","title":"SoA layout","text":""},{"location":"DOTS/Glossary/SoA%20layout/#soa-layout-structure-of-arrays","title":"SoA Layout (Structure of Arrays)","text":"<p>Memory layout pattern where component data of the same type is stored contiguously in arrays, as opposed to AoS (Array of Structures).</p> <p>In Unity ECS, each Component type is stored in its own array within a Chunk, allowing efficient Cache-friendly iteration over components of the same type.</p> <p>SoA (Unity ECS): <pre><code>Chunk memory layout:\n[Health1, Health2, Health3, ...] (all Health components together)\n[Transform1, Transform2, Transform3, ...] (all Transform components together)\n</code></pre></p> <p>AoS (traditional OOP): <pre><code>[Health1+Transform1, Health2+Transform2, Health3+Transform3, ...]\n</code></pre></p> <p>Benefits: - Cache-friendly - CPU prefetcher loads next component automatically - SIMD vectorization - process multiple components in parallel - Skip unused data - only load component types needed by system</p> <p>See also: Chunk, Cache-friendly, Archetype</p>"},{"location":"DOTS/Glossary/Structural%20changes/","title":"Structural changes","text":""},{"location":"DOTS/Glossary/Structural%20changes/#structural-changes","title":"Structural changes","text":"<p>Operations that modify Entity archetypes by adding/removing components, creating/destroying entities, or changing entity structure.</p> <p>Structural changes cause Sync points - all scheduled jobs must complete before the change executes, killing parallelization and performance.</p> <p>Common structural changes: - <code>EntityManager.AddComponent/RemoveComponent</code> - <code>EntityManager.CreateEntity/DestroyEntity</code> - <code>EntityManager.Instantiate</code> - <code>EntityCommandBuffer.Playback</code></p> <p>Alternatives to avoid sync points: - Use IEnableableComponent - toggle components on/off without structural change - Use EntityCommandBuffer - defer changes to specific sync point - Batch operations - do many changes at once instead of incrementally</p> <p>See also: Sync points, Archetype, IEnableableComponent</p>"},{"location":"DOTS/Glossary/Sync%20points/","title":"Sync points","text":""},{"location":"DOTS/Glossary/Sync%20points/#sync-points","title":"Sync Points","text":"<p>Main thread blocking operation that forces completion of scheduled jobs by calling <code>JobHandle.Complete()</code>, causing the main thread to wait until jobs finish execution.</p> <p>Sync points are performance killers - they prevent parallel execution by forcing sequential processing.</p>"},{"location":"DOTS/Glossary/Sync%20points/#types-of-sync-points","title":"Types of Sync Points","text":"<p>1. Read-Only Sync Point - Completes jobs with ReadWrite access to component - Triggered by: <code>EntityManager.GetComponentData&lt;T&gt;()</code>, <code>SystemAPI.GetComponent&lt;T&gt;()</code></p> <p>2. Read-Write Sync Point - Completes all jobs (both read and write) accessing component - Triggered by: <code>EntityManager.SetComponentData&lt;T&gt;()</code>, <code>SystemAPI.SetComponent&lt;T&gt;()</code></p> <p>3. Structural Change Sync Point - Completes ALL jobs in the entire World - Triggered by: <code>EntityManager.AddComponent/RemoveComponent/CreateEntity/DestroyEntity</code>, <code>ECB.Playback()</code> - Most expensive - blocks everything</p>"},{"location":"DOTS/Glossary/Sync%20points/#common-causes","title":"Common Causes","text":"<pre><code>// Main thread component access\nHealth h = state.EntityManager.GetComponentData&lt;Health&gt;(entity);\nstate.EntityManager.SetComponentData(entity, new Health { Current = 100 });\n\n// Main thread iteration\nforeach (var health in SystemAPI.Query&lt;RefRW&lt;Health&gt;&gt;())\n    health.ValueRW.Current += 10;\n\n// Structural changes\nstate.EntityManager.AddComponent&lt;Tag&gt;(entity);\nstate.EntityManager.DestroyEntity(entity);\n\n// ECB playback\necb.Playback(state.EntityManager);\n\n// Query operations with filtering\nint count = query.CalculateEntityCount();  // Syncs if has enableable/change filters\n</code></pre>"},{"location":"DOTS/Glossary/Sync%20points/#operations-that-dont-sync","title":"Operations That DON'T Sync","text":"<pre><code>// Singleton access (but throws if job is scheduled with it)\nGameConfig config = SystemAPI.GetSingleton&lt;GameConfig&gt;();\n\n// Entity count without filtering\nint count = query.CalculateEntityCountWithoutFiltering();\nbool isEmpty = query.IsEmptyIgnoreFilter;\n\n// Job scheduling\nstate.Dependency = job.Schedule(state.Dependency);\n</code></pre>"},{"location":"DOTS/Glossary/Sync%20points/#how-to-avoid","title":"How to Avoid","text":"<p>1. Schedule jobs instead of main thread access: <pre><code>// \u274c BAD: Main thread access = sync point\nforeach (var health in SystemAPI.Query&lt;RefRW&lt;Health&gt;&gt;())\n    health.ValueRW.Current += 10;\n\n// \u2705 GOOD: Job access = no sync point\nnew HealJob().ScheduleParallel();\n</code></pre></p> <p>2. Use EntityCommandBuffer for structural changes: <pre><code>// \u274c BAD: Immediate = sync ALL jobs\nstate.EntityManager.DestroyEntity(entity);\n\n// \u2705 GOOD: Deferred = no sync until playback\necb.DestroyEntity(entity);\n</code></pre></p> <p>3. Organize system order: <pre><code>Frame Structure:\n\u251c\u2500\u2500 Input/UI Systems (unavoidable sync points)\n\u251c\u2500\u2500 Job Scheduling Systems (no sync points!)\n\u2514\u2500\u2500 End of frame (natural completion)\n</code></pre></p>"},{"location":"DOTS/Glossary/Sync%20points/#best-practices","title":"Best Practices","text":"<ul> <li>Minimize structural changes - use IEnableableComponent instead of add/remove</li> <li>Batch ECB usage - use one ECB system per frame</li> <li>Schedule jobs for data access - avoid main thread component iteration</li> <li>Check Unity Profiler - look for \"Sync Point\" markers</li> </ul> <p>See also: Job, EntityCommandBuffer, Job Safety System, System Dependencies</p>"},{"location":"DOTS/Glossary/System%20Group/","title":"System Group","text":""},{"location":"DOTS/Glossary/System%20Group/#system-group","title":"System Group","text":"<p>Container for organizing systems - groups systems into logical phases (initialization, simulation, rendering) and controls their execution order and update frequency.</p> <p>Key characteristics: - System groups are systems - they implement the same ISystem/SystemBase interface - Can be nested - system groups can contain other system groups, creating hierarchy - Control update order - systems run in group order: earlier groups before later groups - Manage rate - each group can have a rate manager to control update frequency and time perception</p> <p>Structure: <pre><code>InitializationSystemGroup\n  \u2514\u2500 [initialization systems]\n\nSimulationSystemGroup\n  \u251c\u2500 FixedStepSimulationSystemGroup (60 Hz fixed)\n  \u2502    \u2514\u2500 [physics systems]\n  \u251c\u2500 VariableRateSimulationSystemGroup (15 FPS variable)\n  \u2502    \u2514\u2500 [low-frequency tasks]\n  \u251c\u2500 [default gameplay systems]\n  \u2514\u2500 LateSimulationSystemGroup\n       \u2514\u2500 [post-transform systems]\n\nPresentationSystemGroup\n  \u2514\u2500 [rendering systems]\n</code></pre></p> <p>Usage: <pre><code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\npublic partial struct PhysicsSystem : ISystem { }\n\n// Custom system group\n[UpdateInGroup(typeof(SimulationSystemGroup))]\n[UpdateBefore(typeof(TransformSystemGroup))]\npublic class GameplaySystemGroup : ComponentSystemGroup { }\n\n[UpdateInGroup(typeof(GameplaySystemGroup))]\npublic partial struct PlayerMovementSystem : ISystem { }\n</code></pre></p> <p>Default groups: - InitializationSystemGroup - runs first every frame (setup, initialization) - SimulationSystemGroup - main gameplay logic (default if no [UpdateInGroup] specified) - PresentationSystemGroup - rendering and presentation, runs last</p> <p>Important: - Systems without <code>[UpdateInGroup]</code> automatically go to SimulationSystemGroup - Within a group, systems run in creation order unless explicit ordering is specified - System groups push their own time context via SystemAPI.Time - Each group can have different update frequency via Rate Managers</p> <p>See also: UpdateInGroup, UpdateBefore, UpdateAfter, Rate Managers, ISystem, SystemAPI.Time</p>"},{"location":"DOTS/Glossary/SystemAPI.Time/","title":"SystemAPI.Time","text":""},{"location":"DOTS/Glossary/SystemAPI.Time/#systemapitime","title":"SystemAPI.Time","text":"<p>Time context for ECS systems - provides delta time and elapsed time values that are controlled by Rate Managers and system groups.</p> <p>Key properties: - DeltaTime - time since last update (framerate-dependent or fixed) - ElapsedTime - total time elapsed since game start - Values depend on system group's rate manager configuration</p> <p>How it works: - Each system group \"pushes\" its own time context - Systems see time values from their parent group's rate manager - Different groups can have different time perception simultaneously</p> <p>Example: <pre><code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\npublic partial struct PhysicsSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        float fixedDelta = SystemAPI.Time.DeltaTime;  // Always 0.0166f (60 Hz)\n        velocity.y -= 9.81f * fixedDelta;\n    }\n}\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic partial struct AnimationSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        float frameDelta = SystemAPI.Time.DeltaTime;  // Frame delta (varies)\n        alpha += speed * frameDelta;\n    }\n}\n</code></pre></p> <p>Comparison:</p> System Group DeltaTime Behavior Use Case SimulationSystemGroup Frame delta (varies) Smooth visual updates FixedStepSimulationSystemGroup Fixed (0.0166f default) Deterministic physics VariableRateSimulationSystemGroup Real time (unscaled) Background tasks <p>Important: - <code>SystemAPI.Time</code> \u2260 <code>UnityEngine.Time</code> - they can have different values - Each rate manager controls what time values systems perceive - Fixed rate systems see fixed DeltaTime even when framerate varies - Variable rate systems see real unscaled time</p> <p>See also: Rate Managers, ISystem, UpdateInGroup, UpdateBefore, UpdateAfter</p>"},{"location":"DOTS/Glossary/Thread-safe/","title":"Thread safe","text":""},{"location":"DOTS/Glossary/Thread-safe/#thread-safe","title":"Thread-safe","text":"<p>Property of code that can be safely executed by multiple threads simultaneously without causing race conditions or data corruption.</p> <p>In Unity DOTS, Job system ensures thread safety through: - Job Safety System - validates no conflicting read/write access - [ReadOnly] attribute - marks data as read-only for parallel access - Job dependencies - ensures jobs with conflicting access run sequentially</p> <p>Thread-safe operations: - Multiple jobs reading same data (<code>[ReadOnly]</code>) - Jobs accessing different data in parallel - Properly dependency-chained jobs</p> <p>Not thread-safe: - Multiple jobs writing to same data - Reading while another job writes - Without proper job dependencies</p> <p>See also: Job Safety System, [ReadOnly], Job</p>"},{"location":"DOTS/Glossary/World/","title":"World","text":""},{"location":"DOTS/Glossary/World/#world","title":"World","text":"<p>Collection of entities and systems that forms an isolated ECS container in Unity DOTS - entities exist within a specific world and systems process entities from their world.</p> <p>A World provides entity isolation - an entity ID is only unique within its own world. The same ID number in different worlds refers to completely different entities.</p> <p>Key characteristics: - Owns entities - manages creation, storage, and destruction of entities through EntityManager - Owns systems - contains systems that process entities, typically running once per frame - Isolated namespace - entity IDs from one world are unrelated to IDs in another world - Multiple worlds possible - applications can create multiple worlds for different purposes</p> <p>Common worlds: - Default World - main runtime world created automatically on play mode - Editor World - separate world for editor-specific functionality - Streaming Worlds - additional worlds for scene streaming or multi-world scenarios</p> <p>Example: <pre><code>// Access the default world\nWorld defaultWorld = World.DefaultGameObjectInjectionWorld;\n\n// Create a custom world\nWorld customWorld = new World(\"MyCustomWorld\");\n\n// Get the world's EntityManager\nEntityManager entityManager = defaultWorld.EntityManager;\n\n// Dispose when done\ncustomWorld.Dispose();\n</code></pre></p> <p>See also: Entity, EntityManager, Component, Archetype</p>"},{"location":"DOTS/Jobs/","title":"Jobs","text":"<p>Jobs are the primary mechanism for parallel entity processing in Unity DOTS. They execute on worker threads, process entity data in a thread-safe manner, and compile with Burst for maximum performance.</p>"},{"location":"DOTS/Jobs/#job-types","title":"Job Types","text":""},{"location":"DOTS/Jobs/#core-job-types","title":"Core Job Types","text":"<ul> <li>IJobEntity - Simplified entity iteration with automatic query generation (most common for ECS)</li> <li>IJob - Single-threaded job for sequential processing on worker thread</li> <li>IJobParallelFor - Parallel array processing distributed across multiple CPU cores</li> </ul>"},{"location":"DOTS/Jobs/#physics-job-types","title":"Physics Job Types","text":"<ul> <li>ITriggerEventsJob - Physics trigger event processing</li> </ul>"},{"location":"DOTS/Jobs/#advanced-job-types","title":"Advanced Job Types","text":"<ul> <li>IJobChunk - Manual chunk iteration for advanced control over entity processing</li> </ul>"},{"location":"DOTS/Jobs/#key-concepts","title":"Key Concepts","text":"<p>Jobs enable massive parallelization of entity processing by distributing work across CPU cores. Unity's job system handles scheduling, dependencies, and thread safety automatically.</p>"},{"location":"DOTS/Jobs/#job-dependencies","title":"Job Dependencies","text":"<ul> <li>JobHandle - Returned by <code>.Schedule()</code>, represents a scheduled job and enables dependency chaining</li> <li>Jobs execute in order when dependencies are specified, preventing race conditions</li> <li><code>JobHandle.Complete()</code> forces synchronization, creating a sync point</li> </ul>"},{"location":"DOTS/Jobs/#data-containers","title":"Data Containers","text":"<ul> <li>NativeCollections - Unmanaged collections (<code>NativeArray</code>, <code>NativeList</code>, etc.) compatible with jobs and Burst</li> <li>Must use <code>Allocator.TempJob</code> or <code>Allocator.Persistent</code> when passing to jobs</li> <li>Manual disposal required with <code>.Dispose()</code> to prevent memory leaks</li> </ul>"},{"location":"DOTS/Jobs/#safety-and-performance","title":"Safety and Performance","text":"<p>All jobs support Burst compilation for 10-100x performance improvements and integrate with the EntityCommandBuffer system for deferred structural changes.</p> <p>The Job Safety System validates thread safety at runtime, preventing race conditions by tracking read/write access to native containers.</p>"},{"location":"DOTS/Jobs/#best-practices","title":"Best Practices","text":"<ol> <li>Use IJobEntity for most entity processing - it's the simplest and most ergonomic</li> <li>Always add BurstCompile attribute for maximum performance</li> <li>Use ChunkIndexInQuery when using EntityCommandBuffer.ParallelWriter</li> <li>Mark read-only data with [ReadOnly] to enable parallel execution</li> <li>Update lookups before scheduling jobs</li> </ol>"},{"location":"DOTS/Jobs/IJob/","title":"IJob","text":"","tags":["job"]},{"location":"DOTS/Jobs/IJob/#description","title":"Description","text":"<ul> <li> <p>Single-threaded job that executes on a worker thread, defined as a struct implementing the <code>IJob</code> interface with an <code>Execute()</code> method</p> </li> <li> <p>Scheduled from the main thread using <code>.Schedule()</code>, returning a JobHandle that tracks the job's completion and enables dependency chaining</p> </li> <li> <p>Cannot access managed objects, perform I/O, or access non-readonly static fields - only works with NativeCollections and unmanaged data types</p> </li> <li> <p>Scheduled jobs create a private copy of the struct, but external data accessed through pointers or native containers remains visible outside the job</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic struct CalculateSumJob : IJob\n{\n    [ReadOnly] public NativeArray&lt;int&gt; Input;\n    public NativeArray&lt;int&gt; Result;  // Single element to store sum\n\n    public void Execute()\n    {\n        int sum = 0;\n        for (int i = 0; i &lt; Input.Length; i++)\n        {\n            sum += Input[i];\n        }\n        Result[0] = sum;\n    }\n}\n\n// Scheduling the job\npublic void ProcessData()\n{\n    var input = new NativeArray&lt;int&gt;(1000, Allocator.TempJob);\n    var result = new NativeArray&lt;int&gt;(1, Allocator.TempJob);\n\n    // Populate input...\n\n    // Schedule the job\n    var job = new CalculateSumJob\n    {\n        Input = input,\n        Result = result\n    };\n\n    JobHandle handle = job.Schedule();\n\n    // Complete the job before accessing results\n    handle.Complete();  // This is a sync point\n\n    int sum = result[0];\n\n    input.Dispose();\n    result.Dispose();\n}\n</code></pre>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#pros","title":"Pros","text":"<ul> <li> <p>Simple threading model - single Execute() method runs on one worker thread, no need to think about parallel synchronization</p> </li> <li> <p>Burst compatible - compiles to highly optimized native code for 10-100x performance gains over managed C#</p> </li> <li> <p>Composable with dependencies - JobHandle enables chaining jobs in specific execution order without explicit synchronization</p> </li> <li> <p>No garbage collection - works with unmanaged data only, eliminating GC overhead during execution</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#cons","title":"Cons","text":"<ul> <li> <p>Single-threaded execution - doesn't leverage multiple CPU cores, use IJobParallelFor or IJobEntity for parallel processing</p> </li> <li> <p>Main thread scheduling only - jobs must be scheduled from the main thread, cannot schedule jobs from within other jobs</p> </li> <li> <p>Sync point required - must call <code>JobHandle.Complete()</code> before accessing job results on main thread, potentially stalling execution</p> </li> <li> <p>Limited data access - cannot use managed collections, strings, or classes - restricted to NativeCollections and primitives</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#best-use","title":"Best use","text":"<ul> <li> <p>Expensive single-threaded calculations - physics queries, pathfinding, AI decision making that doesn't parallelize well</p> </li> <li> <p>Data aggregation - summing values, finding min/max, calculating averages from entity data processed by other jobs</p> </li> <li> <p>Serialization preparation - converting entity data to serializable format before saving or network transmission</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>You're processing arrays or entities - use IJobParallelFor for array processing or IJobEntity for entity iteration instead</p> </li> <li> <p>Simple calculations on main thread - if the work is trivial (&lt; 0.1ms), job scheduling overhead may exceed the benefit</p> </li> <li> <p>You need structural changes - jobs cannot add/remove entities or components, use EntityCommandBuffer for deferred structural changes</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJob/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Always add BurstCompile attribute for maximum performance - without Burst, jobs are only ~30% faster than main thread</p> </li> <li> <p>Job scheduling overhead - the Unity Job System 101 tutorial showed ~30ms main thread execution vs ~30ms single-threaded job (without Burst), but only ~1.5ms with Burst enabled</p> </li> <li> <p>Dependencies prevent race conditions - when scheduling multiple jobs that access same data, pass previous JobHandle as dependency:   <pre><code>JobHandle jobA = jobA.Schedule();\nJobHandle jobB = jobB.Schedule(jobA);  // jobB waits for jobA to complete\n</code></pre></p> </li> <li> <p>Complete() is a sync point - calling <code>handle.Complete()</code> forces the main thread to wait for the job, blocking execution until completion</p> </li> <li> <p>Use TempJob allocator - when passing NativeCollections to jobs, use <code>Allocator.TempJob</code> which is thread-safe and designed for job usage</p> </li> <li> <p>Read-only optimization - mark input containers with <code>[ReadOnly]</code> attribute to help Job Safety System validate thread safety</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobChunk/","title":"IJobChunk","text":"","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#description","title":"Description","text":"<ul> <li> <p>Chunk-by-chunk entity processing job type that iterates chunks of entities with direct array access - lower-level alternative to IJobEntity with more control over data access</p> </li> <li> <p>ComponentTypeHandle access - uses type handles to get NativeArray slices of component data from chunks, allowing batch operations on contiguous memory</p> </li> <li> <p>Full chunk control - Execute method receives entire [[ArchetypeChunk]], enabling enableable component filtering, change detection, and custom iteration patterns</p> </li> <li> <p>No SystemAPI support - unlike IJobEntity, cannot use SystemAPI methods; must manually create and update type handles</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#example","title":"Example","text":"<pre><code>// Basic IJobChunk example\n[BurstCompile]\npublic partial struct MovementJob : IJobChunk\n{\n    public float DeltaTime;\n\n    // Type handles for component access (must be updated each frame)\n    public ComponentTypeHandle&lt;LocalTransform&gt; TransformHandle;\n    [ReadOnly] public ComponentTypeHandle&lt;Velocity&gt; VelocityHandle;\n\n    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,\n                       bool useEnabledMask, in v128 chunkEnabledMask)\n    {\n        // Get component arrays from chunk\n        NativeArray&lt;LocalTransform&gt; transforms = chunk.GetNativeArray(ref TransformHandle);\n        NativeArray&lt;Velocity&gt; velocities = chunk.GetNativeArray(ref VelocityHandle);\n\n        // Iterate entities in chunk\n        for (int i = 0; i &lt; chunk.Count; i++)\n        {\n            LocalTransform transform = transforms[i];\n            Velocity velocity = velocities[i];\n\n            transform.Position += velocity.Value * DeltaTime;\n\n            transforms[i] = transform;\n        }\n    }\n}\n\n// System scheduling IJobChunk\n[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    private EntityQuery _query;\n    private ComponentTypeHandle&lt;LocalTransform&gt; _transformHandle;\n    private ComponentTypeHandle&lt;Velocity&gt; _velocityHandle;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Create query\n        _query = state.GetEntityQuery(typeof(LocalTransform), typeof(Velocity));\n\n        // Get type handles (must update each frame)\n        _transformHandle = state.GetComponentTypeHandle&lt;LocalTransform&gt;(isReadOnly: false);\n        _velocityHandle = state.GetComponentTypeHandle&lt;Velocity&gt;(isReadOnly: true);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Update type handles (REQUIRED each frame)\n        _transformHandle.Update(ref state);\n        _velocityHandle.Update(ref state);\n\n        // Schedule job\n        var job = new MovementJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime,\n            TransformHandle = _transformHandle,\n            VelocityHandle = _velocityHandle\n        };\n\n        state.Dependency = job.ScheduleParallel(_query, state.Dependency);\n    }\n}\n\n// IJobChunk with enableable components\n[BurstCompile]\npublic partial struct EnableableComponentJob : IJobChunk\n{\n    public ComponentTypeHandle&lt;Health&gt; HealthHandle;\n\n    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,\n                       bool useEnabledMask, in v128 chunkEnabledMask)\n    {\n        NativeArray&lt;Health&gt; healths = chunk.GetNativeArray(ref HealthHandle);\n\n        // Iterate only enabled entities using mask\n        var enumerator = new ChunkEntityEnumerator(useEnabledMask, chunkEnabledMask, chunk.Count);\n        while (enumerator.NextEntityIndex(out int i))\n        {\n            // Only processes entities with enabled Health component\n            Health health = healths[i];\n            health.Current += 1f;\n            healths[i] = health;\n        }\n    }\n}\n</code></pre>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#pros","title":"Pros","text":"<ul> <li> <p>Maximum performance - direct array access with minimal overhead, ideal for performance-critical systems</p> </li> <li> <p>Chunk-level operations - can process entire chunks atomically, useful for spatial partitioning or batch operations</p> </li> <li> <p>Enableable component support - full control over enabled/disabled entity iteration with ChunkEntityEnumerator</p> </li> <li> <p>Change filtering - chunk.DidChange() enables efficient \"only process modified data\" patterns</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#cons","title":"Cons","text":"<ul> <li> <p>More boilerplate - requires creating, storing, and updating ComponentTypeHandle for each component accessed</p> </li> <li> <p>No SystemAPI - cannot use SystemAPI.Query, SystemAPI.Time, or other convenience methods inside job</p> </li> <li> <p>Manual handle updates - forgetting to Update() type handles each frame causes stale data bugs</p> </li> <li> <p>Steeper learning curve - more complex API compared to IJobEntity with foreach loops</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#best-use","title":"Best use","text":"<ul> <li> <p>Performance-critical systems - when you've profiled and identified IJobEntity as bottleneck, IJobChunk may be faster</p> </li> <li> <p>Enableable component filtering - when you need precise control over which enabled entities to process</p> </li> <li> <p>Change detection - systems that only react to component changes, avoiding redundant processing</p> </li> <li> <p>Chunk-wide operations - spatial hashing, bounding box computation, or other chunk-level batch operations</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Simple iteration - IJobEntity is cleaner and easier for straightforward entity processing</p> </li> <li> <p>Prototyping - IJobEntity has less boilerplate, better for rapid development</p> </li> <li> <p>No performance issues - premature optimization; start with IJobEntity, switch to IJobChunk only if profiling shows need</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobChunk/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ComponentTypeHandle pattern: <pre><code>public partial struct MySystem : ISystem\n{\n    // Store handles as fields\n    private ComponentTypeHandle&lt;Health&gt; _healthHandle;\n\n    public void OnCreate(ref SystemState state)\n    {\n        // Create handles in OnCreate\n        _healthHandle = state.GetComponentTypeHandle&lt;Health&gt;(isReadOnly: false);\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        // CRITICAL: Update handles every frame\n        _healthHandle.Update(ref state);\n\n        // Use in job\n        new MyJob { HealthHandle = _healthHandle }.ScheduleParallel(query, state.Dependency);\n    }\n}\n</code></pre></p> </li> <li> <p>Type handle types: <pre><code>ComponentTypeHandle&lt;T&gt;  // Read-write or read-only component\nBufferTypeHandle&lt;T&gt;  // DynamicBuffer&lt;T&gt; access\nEntityTypeHandle  // Get Entity ID from chunk\nSharedComponentTypeHandle&lt;T&gt;  // Access shared component value\n</code></pre></p> </li> <li> <p>Getting data from chunk: <pre><code>public void Execute(in ArchetypeChunk chunk, ...)\n{\n    // Component arrays\n    NativeArray&lt;Health&gt; healths = chunk.GetNativeArray(ref healthHandle);\n\n    // Buffer accessor\n    BufferAccessor&lt;Waypoint&gt; waypoints = chunk.GetBufferAccessor(ref waypointHandle);\n\n    // Entity array\n    NativeArray&lt;Entity&gt; entities = chunk.GetNativeArray(entityHandle);\n\n    // Shared component value (single value for entire chunk)\n    SharedComponent shared = chunk.GetSharedComponent(sharedHandle);\n\n    // Chunk count (entity count in this chunk)\n    int count = chunk.Count;\n}\n</code></pre></p> </li> <li> <p>Enableable component iteration: <pre><code>if (!useEnabledMask)\n{\n    // All entities enabled, iterate normally\n    for (int i = 0; i &lt; chunk.Count; i++) { /* ... */ }\n}\nelse\n{\n    // Some entities disabled, use enumerator\n    var enumerator = new ChunkEntityEnumerator(useEnabledMask, chunkEnabledMask, chunk.Count);\n    while (enumerator.NextEntityIndex(out int i))\n    {\n        // Only processes enabled entities\n    }\n}\n</code></pre></p> </li> <li> <p>Change detection: <pre><code>// Did component change since last system version?\nif (chunk.DidChange(ref transformHandle, LastSystemVersion))\n{\n    // Process changed chunk\n}\n</code></pre></p> </li> <li> <p>unfilteredChunkIndex parameter - use for thread-safe writes to parallel arrays:   <pre><code>results[unfilteredChunkIndex] = computedValue;\n</code></pre></p> </li> <li> <p>Scheduling methods: <pre><code>JobHandle handle = job.Schedule(query, inputDeps);  // Single-threaded\nJobHandle handle = job.ScheduleParallel(query, inputDeps);  // Parallel (recommended)\n</code></pre></p> </li> <li> <p>Common mistakes: <pre><code>// WRONG: Forgot to Update() handles\npublic void OnUpdate(ref SystemState state)\n{\n    // _transformHandle is stale! Will read old data\n    new MyJob { Handle = _transformHandle }.ScheduleParallel(query, state.Dependency);\n}\n\n// CORRECT: Update handles every frame\npublic void OnUpdate(ref SystemState state)\n{\n    _transformHandle.Update(ref state);  // Update first!\n    new MyJob { Handle = _transformHandle }.ScheduleParallel(query, state.Dependency);\n}\n</code></pre></p> </li> <li> <p>IJobChunk vs IJobEntity: <pre><code>// Use IJobEntity for:\n- Simple per-entity processing\n- Prototype/development speed\n- SystemAPI convenience methods\n- Cleaner, more maintainable code\n\n// Use IJobChunk for:\n- Maximum performance (profiled bottleneck)\n- Enableable component filtering\n- Change detection optimization\n- Chunk-wide batch operations\n- Custom iteration patterns\n</code></pre></p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/IJobEntity/","title":"IJobEntity","text":"<p>\ud83d\udca1 Modern Replacement (Unity Entities 6.5+)</p> <p><code>IJobEntity</code> is the recommended replacement for the deprecated <code>Entities.ForEach</code> and <code>Job.WithCode</code> patterns. If you're migrating from older DOTS code, use <code>IJobEntity</code> combined with SystemAPI.Query for equivalent functionality with better performance and clearer syntax.</p>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#description","title":"Description","text":"<ul> <li> <p>Simplified job type for iterating over entities with Burst compilation, automatically generating queries based on <code>Execute</code> method parameters</p> </li> <li> <p>Defined as <code>partial struct</code> inside an ISystem, with an <code>Execute</code> method that specifies which components to process</p> </li> <li> <p>Most ergonomic job type - no manual chunk iteration, automatic query generation, supports Aspects and RefRO/RefRW parameters</p> </li> <li> <p>Scheduled with <code>.Schedule()</code> or <code>.ScheduleParallel()</code> for parallel execution across worker threads</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct ProjectileMoveSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Schedule the job to run in parallel\n        state.Dependency = new ProjectileMoveJob()\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        }.ScheduleParallel(state.Dependency);\n    }\n\n    // IJobEntity with aspect parameter\n    public partial struct ProjectileMoveJob : IJobEntity\n    {\n        public float DeltaTime;\n\n        // Execute runs per entity - parameters define the query\n        private void Execute(ProjectileAspect projectile)\n        {\n            projectile.Move(DeltaTime);\n        }\n    }\n}\n\n// Example with multiple component parameters\npublic partial struct DamageJob : IJobEntity\n{\n    // RefRO = read-only, RefRW = read-write\n    private void Execute(RefRW&lt;Health&gt; health, in DamageBuffer damageBuffer)\n    {\n        foreach (var damage in damageBuffer)\n        {\n            health.ValueRW.Current -= damage.Amount;\n        }\n    }\n}\n\n// Example with entity index for EntityCommandBuffer.ParallelWriter\npublic partial struct KillJob : IJobEntity\n{\n    public EntityCommandBuffer.ParallelWriter Ecb;\n\n    // [ChunkIndexInQuery] provides sort key for parallel command buffer\n    private void Execute(Entity entity, [ChunkIndexInQuery] int sortKey, in Health health)\n    {\n        if (health.Current &lt;= 0)\n        {\n            Ecb.DestroyEntity(sortKey, entity);\n        }\n    }\n}\n</code></pre>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#pros","title":"Pros","text":"<ul> <li> <p>Automatic query generation - no need to manually create EntityQuery, parameters define what entities to process</p> </li> <li> <p>Burst compatible - full performance benefits of compiled jobs</p> </li> <li> <p>Clean syntax - simpler than IJobChunk, no manual chunk iteration code</p> </li> <li> <p>Aspect support - can use IAspect parameters for grouped component access</p> </li> <li> <p>Parallel execution - <code>ScheduleParallel()</code> distributes work across multiple threads automatically</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#cons","title":"Cons","text":"<ul> <li> <p>Less control than IJobChunk - can't manually control chunk iteration or access chunk-level data easily</p> </li> <li> <p>Hidden allocations - query generation happens behind the scenes, less visibility into what's happening</p> </li> <li> <p>Limited to entity iteration - can't do custom iteration patterns like processing chunks in specific order</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#best-use","title":"Best use","text":"<ul> <li> <p>Simple entity iteration - when you need to process entities with specific components in parallel</p> </li> <li> <p>Per-entity logic - damage calculation, movement, state updates, AI behavior</p> </li> <li> <p>Aspect-based systems - when using Aspects to group related components and behavior</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>You need IJobChunk - when you need chunk-level control, accessing ComponentTypeHandle, or custom iteration</p> </li> <li> <p>Physics jobs are better suited - for collision/trigger processing, use ITriggerEventsJob instead</p> </li> <li> <p>The query is trivial - for simple single-component updates, <code>SystemAPI.Query</code> in OnUpdate may be clearer and sufficient</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Query filtering - use attributes on the Execute method to filter queries: <code>[WithAll(typeof(TagComponent))]</code>, <code>[WithNone(typeof(Disabled))]</code></p> </li> <li> <p>EntityCommandBuffer.ParallelWriter - use <code>[ChunkIndexInQuery] int sortKey</code> parameter to get the sort key for parallel command buffers, ensuring deterministic playback</p> </li> <li> <p>in/ref/RefRO/RefRW - parameter modifiers control access: <code>in</code> or <code>RefRO&lt;T&gt;</code> for read-only, <code>ref</code> or <code>RefRW&lt;T&gt;</code> for read-write</p> </li> <li> <p>Entity parameter - add <code>Entity entity</code> parameter if you need the entity ID (for command buffers, lookups, etc.)</p> </li> <li> <p>DynamicBuffer parameters - can use <code>DynamicBuffer&lt;T&gt;</code> parameters to access buffer data</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#migration-from-entitiesforeach-deprecated","title":"Migration from Entities.ForEach (Deprecated)","text":"<p>Unity Entities 6.5+ deprecated <code>Entities.ForEach</code> and <code>Job.WithCode</code>. Here's how to migrate:</p>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#before-entitiesforeach-deprecated","title":"Before: Entities.ForEach (Deprecated \u274c)","text":"<pre><code>// OLD - Deprecated in Unity Entities 6.5+\npublic partial class OldHealthSystem : SystemBase\n{\n    protected override void OnUpdate()\n    {\n        float deltaTime = Time.DeltaTime;\n\n        Entities\n            .WithAll&lt;Active&gt;()\n            .WithNone&lt;Dead&gt;()\n            .ForEach((ref Health health, in HealthRegen regen) =&gt;\n            {\n                health.Current += regen.PointPerSec * deltaTime;\n            })\n            .ScheduleParallel();\n    }\n}\n</code></pre>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#after-ijobentity-recommended","title":"After: IJobEntity (Recommended \u2705)","text":"<pre><code>// NEW - Modern approach with IJobEntity\n[BurstCompile]\npublic partial struct ModernHealthSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        new HealthRegenJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        }.ScheduleParallel();\n    }\n\n    [BurstCompile]\n    [WithAll(typeof(Active))]      // Query filtering via attributes\n    [WithNone(typeof(Dead))]\n    public partial struct HealthRegenJob : IJobEntity\n    {\n        public float DeltaTime;\n\n        private void Execute(ref Health health, in HealthRegen regen)\n        {\n            health.Current += regen.PointPerSec * DeltaTime;\n        }\n    }\n}\n</code></pre>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#key-migration-points","title":"Key Migration Points","text":"<ol> <li>SystemBase \u2192 ISystem</li> <li>Change from <code>SystemBase</code> to <code>ISystem</code> (partial struct)</li> <li> <p>Add <code>[BurstCompile]</code> for performance</p> </li> <li> <p>ForEach \u2192 IJobEntity</p> </li> <li>Extract lambda into <code>IJobEntity</code> struct with <code>Execute</code> method</li> <li> <p>Move query filters to attributes: <code>[WithAll]</code>, <code>[WithNone]</code>, <code>[WithAny]</code></p> </li> <li> <p>Scheduling</p> </li> <li><code>ForEach(...).ScheduleParallel()</code> \u2192 <code>new MyJob().ScheduleParallel()</code></li> <li> <p><code>ForEach(...).Schedule()</code> \u2192 <code>new MyJob().Schedule(state.Dependency)</code></p> </li> <li> <p>EntityCommandBuffer</p> </li> <li>Before: <code>var ecb = GetSingleton&lt;ECBSystem&gt;().CreateCommandBuffer(this)</code></li> <li>After: <code>var ecbSingleton = SystemAPI.GetSingleton&lt;ECBSystem.Singleton&gt;(); var ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged)</code></li> </ol>","tags":["job"]},{"location":"DOTS/Jobs/IJobEntity/#alternative-systemapiquery-for-simple-cases","title":"Alternative: SystemAPI.Query for Simple Cases","text":"<p>For very simple iterations, you can also use SystemAPI.Query: <pre><code>[BurstCompile]\npublic partial struct SimpleHealthSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float dt = SystemAPI.Time.DeltaTime;\n\n        // Direct iteration on main thread (no job)\n        foreach (var (health, regen) in\n            SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;HealthRegen&gt;&gt;()\n                .WithAll&lt;Active&gt;()\n                .WithNone&lt;Dead&gt;())\n        {\n            health.ValueRW.Current += regen.ValueRO.PointPerSec * dt;\n        }\n    }\n}\n</code></pre></p> <p>Use <code>IJobEntity</code> when you need parallel execution, <code>SystemAPI.Query</code> for simple main-thread iteration.</p>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/","title":"IJobParallelFor","text":"","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#description","title":"Description","text":"<ul> <li> <p>Parallel job that processes array indices across multiple worker threads, defined as a struct implementing <code>IJobParallelFor</code> with an <code>Execute(int index)</code> method</p> </li> <li> <p>Scheduled with <code>.Schedule(count, batchSize)</code> where count is the number of indices to process and batchSize controls how many indices each worker thread processes at a time</p> </li> <li> <p>Work is automatically distributed across CPU cores - batches execute concurrently on separate threads for massive performance gains</p> </li> <li> <p>Batch size tuning - larger batches reduce scheduling overhead but decrease parallelism granularity, requiring empirical testing to optimize</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic struct FindClosestTargetJob : IJobParallelFor\n{\n    [ReadOnly] public NativeArray&lt;float3&gt; SeekerPositions;\n    [ReadOnly] public NativeArray&lt;float3&gt; TargetPositions;\n\n    // NativeDisableParallelForRestriction allows writing to any index\n    [NativeDisableParallelForRestriction]\n    public NativeArray&lt;int&gt; ClosestTargetIndices;\n\n    public void Execute(int seekerIndex)\n    {\n        float3 seekerPos = SeekerPositions[seekerIndex];\n        float closestDistSq = float.MaxValue;\n        int closestTarget = -1;\n\n        // Search all targets for closest one\n        for (int i = 0; i &lt; TargetPositions.Length; i++)\n        {\n            float distSq = math.distancesq(seekerPos, TargetPositions[i]);\n            if (distSq &lt; closestDistSq)\n            {\n                closestDistSq = distSq;\n                closestTarget = i;\n            }\n        }\n\n        ClosestTargetIndices[seekerIndex] = closestTarget;\n    }\n}\n\n// Scheduling the parallel job\npublic void FindClosestTargets()\n{\n    int seekerCount = 10000;\n    var seekers = new NativeArray&lt;float3&gt;(seekerCount, Allocator.TempJob);\n    var targets = new NativeArray&lt;float3&gt;(1000, Allocator.TempJob);\n    var results = new NativeArray&lt;int&gt;(seekerCount, Allocator.TempJob);\n\n    // Populate arrays...\n\n    var job = new FindClosestTargetJob\n    {\n        SeekerPositions = seekers,\n        TargetPositions = targets,\n        ClosestTargetIndices = results\n    };\n\n    // Process in batches of 64 - tune this value!\n    JobHandle handle = job.Schedule(seekerCount, batchSize: 64);\n\n    handle.Complete();\n\n    // Process results...\n\n    seekers.Dispose();\n    targets.Dispose();\n    results.Dispose();\n}\n</code></pre>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#pros","title":"Pros","text":"<ul> <li> <p>Massive parallelization - automatically distributes work across all CPU cores for near-linear performance scaling</p> </li> <li> <p>Simple parallel programming - no manual thread management, locks, or synchronization needed - Unity handles it</p> </li> <li> <p>Burst compatible - combines parallel execution with highly optimized native code for maximum throughput</p> </li> <li> <p>Cache-friendly - batch processing enables better CPU cache utilization as each thread processes contiguous indices</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#cons","title":"Cons","text":"<ul> <li> <p>Index-only parallelism - can only parallelize array-based operations, not arbitrary work patterns</p> </li> <li> <p>Batch size tuning required - optimal batch size varies by workload and must be determined through profiling and testing</p> </li> <li> <p>Limited write access - by default, each thread can only write to its assigned batch indices, requiring <code>[NativeDisableParallelForRestriction]</code> for arbitrary writes</p> </li> <li> <p>No guaranteed order - batches execute in unpredictable order, making deterministic execution challenging without careful design</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#best-use","title":"Best use","text":"<ul> <li> <p>Array transformations - processing positions, velocities, damage calculations across large arrays</p> </li> <li> <p>Brute-force searches - finding nearest neighbors, collision checks, spatial queries on large datasets</p> </li> <li> <p>Independent calculations - any per-element computation where each result doesn't depend on others (embarrassingly parallel problems)</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>You're processing entities - use IJobEntity instead, which provides better integration with ECS and automatic query generation</p> </li> <li> <p>Heavy inter-element dependencies - if processing index N requires results from index N-1, parallel execution becomes difficult</p> </li> <li> <p>Tiny arrays - for arrays with &lt; 100 elements, parallel overhead may exceed benefits, use IJob or main thread instead</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/IJobParallelFor/#extra-tip","title":"Extra tip","text":"<ul> <li>Performance progression (from Unity Job System 101 tutorial with 1000 seekers \u00d7 1000 targets):</li> <li>Main thread: ~330ms</li> <li>Single-threaded IJob without Burst: ~30ms</li> <li>Single-threaded IJob with Burst: ~1.5ms</li> <li> <p><code>IJobParallelFor</code> with 16 cores: ~17ms elapsed for 10,000 entities</p> </li> <li> <p>Batch size guidelines - start with 32-64 and profile. Larger batches (128+) reduce overhead for heavy computations, smaller batches (16-32) increase parallelism for lightweight operations</p> </li> <li> <p>[NativeDisableParallelForRestriction] - disables safety checks that restrict write access to assigned batch indices. Use carefully - you're responsible for preventing race conditions:   <pre><code>[NativeDisableParallelForRestriction]\npublic NativeArray&lt;int&gt; SharedOutput;  // Can write to any index\n</code></pre></p> </li> <li> <p>Read-only data sharing - multiple threads can safely read from same NativeCollections if marked <code>[ReadOnly]</code>, enabling data sharing without copies</p> </li> <li> <p>Dependency chaining - combine with other jobs using JobHandle dependencies to build complex parallel pipelines:   <pre><code>JobHandle sortJob = sortJob.Schedule(count, 64);\nJobHandle searchJob = searchJob.Schedule(count, 64, sortJob);  // Waits for sort\n</code></pre></p> </li> <li> <p>For entity processing, prefer IJobEntity - it automatically handles parallel scheduling, provides cleaner syntax, and integrates better with the ECS query system</p> </li> </ul>","tags":["job"]},{"location":"DOTS/Jobs/ITriggerEventsJob/","title":"ITriggerEventsJob","text":"","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#description","title":"Description","text":"<ul> <li> <p>Physics-specific job for processing trigger collision events from Unity Physics, executing once per trigger pair with Burst compilation</p> </li> <li> <p>Scheduled with <code>.Schedule(SimulationSingleton, state.Dependency)</code> after physics simulation completes</p> </li> <li> <p>Provides access to <code>TriggerEvent</code> struct containing the pair of entities involved in the collision and collision details</p> </li> <li> <p>Typically runs in <code>[UpdateInGroup(typeof(AfterPhysicsSystemGroup))]</code> to process results after physics step</p> </li> </ul>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#example","title":"Example","text":"<pre><code>[UpdateInGroup(typeof(AfterPhysicsSystemGroup))]\n[BurstCompile]\npublic partial struct EnemyPlayerCollisionSystem : ISystem\n{\n    BufferLookup&lt;Waypoints&gt; _enemyLookup;\n    ComponentLookup&lt;Player&gt; _playerLookup;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        state.RequireForUpdate&lt;SimulationSingleton&gt;();\n\n        // Create lookups for component access\n        _enemyLookup = SystemAPI.GetBufferLookup&lt;Waypoints&gt;(true);\n        _playerLookup = SystemAPI.GetComponentLookup&lt;Player&gt;(false);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Get physics simulation results\n        SimulationSingleton simulation = SystemAPI.GetSingleton&lt;SimulationSingleton&gt;();\n\n        // Update lookups before use\n        _enemyLookup.Update(ref state);\n        _playerLookup.Update(ref state);\n\n        // Schedule trigger events job\n        state.Dependency = new EnemyPlayerCollisionJob()\n        {\n            Enemies = _enemyLookup,\n            Players = _playerLookup,\n            Ecb = /* EntityCommandBuffer */\n        }.Schedule(simulation, state.Dependency);\n    }\n\n    [BurstCompile]\n    private struct EnemyPlayerCollisionJob : ITriggerEventsJob\n    {\n        [ReadOnly] public BufferLookup&lt;Waypoints&gt; Enemies;\n        public ComponentLookup&lt;Player&gt; Players;\n        public EntityCommandBuffer Ecb;\n\n        // Executes once per trigger event\n        public void Execute(TriggerEvent triggerEvent)\n        {\n            // Identify which entity is which\n            Entity playerEntity = Entity.Null;\n            Entity enemyEntity = Entity.Null;\n\n            if (Players.HasComponent(triggerEvent.EntityA))\n                playerEntity = triggerEvent.EntityA;\n            if (Players.HasComponent(triggerEvent.EntityB))\n                playerEntity = triggerEvent.EntityB;\n            if (Enemies.HasBuffer(triggerEvent.EntityA))\n                enemyEntity = triggerEvent.EntityA;\n            if (Enemies.HasBuffer(triggerEvent.EntityB))\n                enemyEntity = triggerEvent.EntityB;\n\n            if (playerEntity == Entity.Null || enemyEntity == Entity.Null)\n                return;\n\n            // Process collision - damage player, destroy enemy\n            Player player = Players[playerEntity];\n            player.LifeCount -= 1;\n            Players[playerEntity] = player;\n\n            Ecb.DestroyEntity(enemyEntity);\n        }\n    }\n}\n</code></pre>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#pros","title":"Pros","text":"<ul> <li> <p>Burst compatible - full performance benefits for physics event processing</p> </li> <li> <p>Automatic event iteration - Unity calls Execute for each trigger pair, no manual iteration needed</p> </li> <li> <p>Collision filtering - only processes actual trigger events based on CollisionFilter setup</p> </li> <li> <p>Entity pair access - provides both entities involved in collision via <code>TriggerEvent.EntityA</code> and <code>EntityB</code></p> </li> </ul>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#cons","title":"Cons","text":"<ul> <li> <p>Requires ComponentLookup/BufferLookup - can't use direct component access, must use lookups for random access</p> </li> <li> <p>Entity identification required - must determine which entity is which from the pair using lookups</p> </li> <li> <p>Physics-only - only works with Unity Physics trigger colliders, not useful for other collision detection</p> </li> <li> <p>No chunk iteration - processes one event at a time, can't batch process events by chunk</p> </li> </ul>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#best-use","title":"Best use","text":"<ul> <li> <p>Trigger-based gameplay - projectile hits, player-enemy collisions, pickup collection</p> </li> <li> <p>Event-driven damage - apply damage when entities collide based on physics triggers</p> </li> <li> <p>Area detection - detecting when entities enter/exit zones or trigger volumes</p> </li> </ul>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>You need collision contacts - for detailed collision contact info, use <code>ICollisionEventsJob</code> instead</p> </li> <li> <p>Non-physics collision detection - for spatial queries without physics simulation, use [[PhysicsWorldSingleton]] raycasts or overlap queries</p> </li> <li> <p>Simple trigger checks - if you only need to check if entities are nearby, spatial queries in a regular system may be simpler</p> </li> </ul>","tags":["job","physics"]},{"location":"DOTS/Jobs/ITriggerEventsJob/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Update lookups - always call <code>lookup.Update(ref state)</code> before scheduling the job, as entity storage may have been reorganized</p> </li> <li> <p>Entity identification pattern - use <code>HasComponent()</code>/<code>HasBuffer()</code> on both EntityA and EntityB to determine which entity has which component type</p> </li> <li> <p>Multiple EntityCommandBuffers - common pattern: use BeginInitializationECB for adding components, BeginSimulationECB for destroying entities to ensure proper execution order</p> </li> <li> <p>CollisionFilter setup - configure <code>CollisionFilter.BelongsTo</code> and <code>CollidesWith</code> during [[Baker|baking]] to control which entities can trigger with each other <li> <p>SystemGroup ordering - use <code>[UpdateInGroup(typeof(AfterPhysicsSystemGroup))]</code> to ensure physics simulation has completed before processing events</p> </li>","tags":["job","physics"]},{"location":"DOTS/Jobs/JobHandle/","title":"JobHandle","text":"","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#description","title":"Description","text":"<ul> <li> <p>Job tracking handle returned by <code>.Schedule()</code> that represents a scheduled job and enables establishing execution order dependencies</p> </li> <li> <p>Used to chain job execution - passing a JobHandle as a dependency ensures the new job won't start until the dependency completes</p> </li> <li> <p>Calling <code>Complete()</code> on a JobHandle completes all dependencies recursively, waits for execution to finish, and removes the job from the queue</p> </li> <li> <p>Only the main thread can complete jobs - worker threads cannot call <code>Complete()</code> or schedule new jobs, only the main thread has this capability</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic struct GenerateDataJob : IJob\n{\n    public NativeArray&lt;float&gt; Output;\n\n    public void Execute()\n    {\n        for (int i = 0; i &lt; Output.Length; i++)\n        {\n            Output[i] = i * 2.5f;\n        }\n    }\n}\n\n[BurstCompile]\npublic struct ProcessDataJob : IJob\n{\n    [ReadOnly] public NativeArray&lt;float&gt; Input;\n    public NativeArray&lt;float&gt; Output;\n\n    public void Execute()\n    {\n        for (int i = 0; i &lt; Input.Length; i++)\n        {\n            Output[i] = Input[i] * Input[i];  // Square the values\n        }\n    }\n}\n\npublic void ChainJobs()\n{\n    var tempData = new NativeArray&lt;float&gt;(1000, Allocator.TempJob);\n    var finalData = new NativeArray&lt;float&gt;(1000, Allocator.TempJob);\n\n    // Schedule first job\n    JobHandle generateHandle = new GenerateDataJob\n    {\n        Output = tempData\n    }.Schedule();\n\n    // Schedule second job with dependency - it waits for generateHandle\n    JobHandle processHandle = new ProcessDataJob\n    {\n        Input = tempData,\n        Output = finalData\n    }.Schedule(generateHandle);  // Dependency passed here\n\n    // Complete only the final job - automatically completes generateHandle first\n    processHandle.Complete();\n\n    // Now safe to access finalData on main thread\n\n    tempData.Dispose();\n    finalData.Dispose();\n}\n\n// Combining multiple dependencies\npublic void CombineDependencies()\n{\n    JobHandle job1 = new JobA { Data = data1 }.Schedule();\n    JobHandle job2 = new JobB { Data = data2 }.Schedule();\n\n    // Combine multiple handles - new job waits for BOTH to complete\n    JobHandle combined = JobHandle.CombineDependencies(job1, job2);\n\n    JobHandle finalJob = new JobC().Schedule(combined);\n\n    finalJob.Complete();\n}\n</code></pre>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#pros","title":"Pros","text":"<ul> <li> <p>Automatic dependency management - worker threads respect dependencies without manual synchronization or locks</p> </li> <li> <p>Prevents race conditions - Job Safety System uses JobHandles to validate no two jobs access same data unsafely</p> </li> <li> <p>Enables complex pipelines - chain multiple jobs in specific execution order to build sophisticated data processing workflows</p> </li> <li> <p>Minimal overhead - dependency tracking is extremely lightweight, no significant performance cost</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#cons","title":"Cons","text":"<ul> <li> <p>Main thread restriction - only main thread can complete jobs, limiting flexibility in complex threading scenarios</p> </li> <li> <p>Sync point overhead - calling <code>Complete()</code> is a sync point that blocks main thread until job finishes, potentially stalling execution</p> </li> <li> <p>Manual dependency management - developer must manually track and pass JobHandles, errors can lead to race conditions or deadlocks</p> </li> <li> <p>No partial completion - cannot complete just part of a job, must wait for entire execution to finish</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#best-use","title":"Best use","text":"<ul> <li> <p>Job dependency chains - when job B needs results from job A, pass A's JobHandle to B's Schedule() method</p> </li> <li> <p>Preventing race conditions - when multiple jobs access same NativeCollections, establish dependencies to ensure safe sequential access</p> </li> <li> <p>Parallel pipelines - run independent jobs concurrently, then combine their handles for a final processing job</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Unity ECS handles it automatically - in ISystem, <code>SystemState.Dependency</code> automatically manages dependencies between systems based on component access</p> </li> <li> <p>You need real-time blocking - if you must immediately access job results, consider running on main thread instead of creating Sync points</p> </li> <li> <p>Single job with no dependencies - for simple cases, the default <code>default(JobHandle)</code> (no dependency) is sufficient</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/JobHandle/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Complete() is recursive - calling <code>processHandle.Complete()</code> automatically completes <code>generateHandle</code> first if it was a dependency. You only need to complete the final job in a chain</p> </li> <li> <p>default(JobHandle) means no dependency - passing <code>default</code> or omitting the dependency parameter schedules the job to run ASAP without waiting:   <pre><code>JobHandle immediate = job.Schedule();  // No dependency, runs ASAP\nJobHandle withDep = job.Schedule(previousJob);  // Waits for previousJob\n</code></pre></p> </li> <li> <p>SystemState.Dependency in ECS - Unity ECS automatically manages JobHandles through <code>SystemState.Dependency</code>. Each system reads the dependency, schedules its jobs, and writes back the new handle:   <pre><code>public void OnUpdate(ref SystemState state)\n{\n    // Read previous system's dependency\n    JobHandle inputDeps = state.Dependency;\n\n    // Schedule job with dependency\n    JobHandle outputDeps = new MyJob().Schedule(inputDeps);\n\n    // Write new dependency for next system\n    state.Dependency = outputDeps;\n}\n</code></pre></p> </li> <li> <p>CombineDependencies for parallel work - use <code>JobHandle.CombineDependencies()</code> to wait for multiple independent jobs:   <pre><code>JobHandle combined = JobHandle.CombineDependencies(jobA, jobB, jobC);\nJobHandle finalJob = aggregateJob.Schedule(combined);  // Waits for all 3\n</code></pre></p> </li> <li> <p>Complete() vs CompleteDependency() - in ECS systems, use <code>state.CompleteDependency()</code> instead of <code>state.Dependency.Complete()</code> for clearer intent</p> </li> <li> <p>Avoid premature Complete() - each <code>Complete()</code> is a sync point that forces the main thread to wait. Delay completing until you actually need the results</p> </li> <li> <p>Read-only enables parallelism - when multiple jobs need same input data, mark it <code>[ReadOnly]</code> so they can run in parallel instead of sequentially</p> </li> <li> <p>Safety handle reservation - JobHandles \"reserve\" safety handles on NativeCollections until <code>Complete()</code> is called, preventing conflicting access during execution</p> </li> </ul>","tags":["job","advanced"]},{"location":"DOTS/Jobs/NativeCollections/","title":"NativeCollections","text":"","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#description","title":"Description","text":"<ul> <li> <p>Unmanaged collections from <code>Unity.Collections</code> namespace (<code>NativeArray</code>, <code>NativeList</code>, etc.) designed for use with jobs and Burst compilation</p> </li> <li> <p>Compatible with job system - include thread-safety checks via the Job Safety System to prevent race conditions during parallel execution</p> </li> <li> <p>Manual memory management - must call <code>Dispose()</code> to free memory, avoiding garbage collection overhead but requiring careful lifetime management</p> </li> <li> <p>Allocated with one of three allocator types: <code>Allocator.Persistent</code> (long-lived), <code>Allocator.Temp</code> (frame-scoped), or <code>Allocator.TempJob</code> (thread-safe for jobs)</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct ProcessDataSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Allocator.TempJob - thread-safe, manual disposal required\n        var positions = new NativeArray&lt;float3&gt;(1000, Allocator.TempJob);\n        var velocities = new NativeArray&lt;float3&gt;(1000, Allocator.TempJob);\n\n        // Populate arrays...\n        for (int i = 0; i &lt; positions.Length; i++)\n        {\n            positions[i] = new float3(i, 0, 0);\n            velocities[i] = new float3(1, 0, 0);\n        }\n\n        // Schedule job using the native arrays\n        var job = new MoveJob\n        {\n            Positions = positions,\n            Velocities = velocities,\n            DeltaTime = SystemAPI.Time.DeltaTime\n        };\n\n        JobHandle handle = job.Schedule(state.Dependency);\n        handle.Complete();\n\n        // CRITICAL: Always dispose to prevent memory leaks\n        positions.Dispose();\n        velocities.Dispose();\n    }\n}\n\n[BurstCompile]\npublic struct MoveJob : IJob\n{\n    public NativeArray&lt;float3&gt; Positions;\n    [ReadOnly] public NativeArray&lt;float3&gt; Velocities;  // Read-only optimization\n    public float DeltaTime;\n\n    public void Execute()\n    {\n        for (int i = 0; i &lt; Positions.Length; i++)\n        {\n            Positions[i] += Velocities[i] * DeltaTime;\n        }\n    }\n}\n</code></pre>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#pros","title":"Pros","text":"<ul> <li> <p>Burst compatible - enables 10-100x performance gains through native code compilation</p> </li> <li> <p>No garbage collection - unmanaged memory eliminates GC pauses and overhead during gameplay</p> </li> <li> <p>Thread-safety validation - Job Safety System automatically detects race conditions and throws exceptions before bugs occur</p> </li> <li> <p>Cache-friendly - contiguous memory layout enables efficient CPU cache utilization for better performance</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#cons","title":"Cons","text":"<ul> <li> <p>Manual disposal required - forgetting to call <code>Dispose()</code> causes memory leaks, requiring disciplined memory management</p> </li> <li> <p>Allocator restrictions - <code>Allocator.Temp</code> cannot be passed to jobs, must use thread-safe <code>Allocator.TempJob</code> instead</p> </li> <li> <p>Limited API - native collections have fewer features than managed collections (no LINQ, limited resizing, etc.)</p> </li> <li> <p>Complexity overhead - thread-safety attributes and disposal tracking add cognitive load compared to managed collections</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#best-use","title":"Best use","text":"<ul> <li> <p>Job data passing - primary mechanism for passing data to IJob, IJobParallelFor, and IJobEntity jobs</p> </li> <li> <p>Burst-compiled code - required data structures when using Burst compiler for maximum performance</p> </li> <li> <p>High-performance arrays - when you need contiguous, Cache-friendly memory without GC overhead for large datasets</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Data only used on main thread - managed arrays are simpler if you never pass data to jobs</p> </li> <li> <p>Temporary small allocations - for tiny, short-lived data (&lt; 10 elements), stack-allocated arrays may be sufficient</p> </li> <li> <p>Complex collections needed - if you need dictionaries, hash sets, or advanced LINQ operations, managed collections are more appropriate</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Jobs/NativeCollections/#extra-tip","title":"Extra tip","text":"<ul> <li>Allocator.Persistent vs TempJob lifetime:</li> <li><code>Persistent</code>: indefinite lifetime, use for data lasting multiple frames or entire game session</li> <li><code>TempJob</code>: up to 4 frames, use for data passed to jobs that complete within a few frames</li> <li> <p><code>Temp</code>: single frame only, fastest but CANNOT be used in jobs</p> </li> <li> <p>Thread-safe allocators mandatory for jobs - only <code>Allocator.TempJob</code> and <code>Allocator.Persistent</code> are thread-safe. Never pass <code>Allocator.Temp</code> collections to jobs</p> </li> <li> <p>[ReadOnly] attribute enables parallelism - mark fields <code>[ReadOnly]</code> when jobs only read data, allowing multiple jobs to access same collection concurrently</p> </li> <li> <p>Dispose with job dependencies - use <code>Dispose(JobHandle)</code> to schedule disposal after job completes, avoiding manual completion:   <pre><code>var array = new NativeArray&lt;int&gt;(100, Allocator.TempJob);\nJobHandle job = new MyJob { Data = array }.Schedule();\narray.Dispose(job);  // Schedules disposal after job completes\n</code></pre></p> </li> <li> <p>Safety checks are Editor-only by default - native collection safety checks add overhead in Editor but are disabled in builds for performance</p> </li> <li> <p>Common native collection types:</p> </li> <li><code>NativeArray&lt;T&gt;</code>: Fixed-size array (most common)</li> <li><code>NativeList&lt;T&gt;</code>: Resizable list (like <code>List&lt;T&gt;</code>)</li> <li><code>NativeQueue&lt;T&gt;</code>: FIFO queue for producer-consumer patterns</li> <li><code>NativeHashMap&lt;K,V&gt;</code>: Dictionary for key-value lookups</li> <li> <p><code>NativeHashSet&lt;T&gt;</code>: Set for unique value storage</p> </li> <li> <p>Memory leak detection - Unity Editor warns about undisposed native collections in console. Enable \"Jobs &gt; Leak Detection\" in Preferences for detailed tracking</p> </li> <li> <p>[NativeDisableContainerSafetyRestriction] - disables safety checks on a specific field when you guarantee thread-safety manually. Dangerous - only use when profiling proves safety checks are a bottleneck</p> </li> </ul>","tags":["job","collections"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/","title":"Buffer Capacity Optimization","text":"","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#description","title":"Description","text":"<ul> <li> <p>Memory layout optimization using <code>[InternalBufferCapacity]</code> attribute to control buffer storage location in Chunk vs heap</p> </li> <li> <p>Buffers with capacity \u2264 InternalBufferCapacity store elements inline in chunk memory (Cache-friendly), larger buffers allocate on heap</p> </li> <li> <p>Default capacity is 8 elements; tune based on actual usage patterns to maximize chunk storage and minimize heap allocations</p> </li> <li> <p>Strategic capacity sizing prevents both wasted chunk space (oversized capacity) and heap allocation overhead (undersized capacity)</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#example","title":"Example","text":"<pre><code>// Default capacity (8 elements) - may be wasteful or insufficient\npublic struct Targets : IBufferElementData\n{\n    public Entity Value;  // 8 bytes\n}\n// Stores 8 Entities = 64 bytes in chunk by default\n// If typical usage is 3 targets \u2192 wastes 40 bytes per entity\n// If typical usage is 15 targets \u2192 allocates heap memory\n\n// Optimized capacity based on profiling\n[InternalBufferCapacity(3)]  // Typical enemy has 1-3 targets\npublic struct Targets : IBufferElementData\n{\n    public Entity Value;\n}\n// 3 Entities = 24 bytes in chunk\n// Saves 40 bytes per entity vs default\n// For 100 entities: saves 4KB chunk memory\n\n// Boss state machine buffers\n[InternalBufferCapacity(10)]  // ~2 conditions per state, 5 states\npublic struct BossStateConditionSetup : IBufferElementData\n{\n    public BossConditionType Type;\n    public BossConditionEvaluationType EvalType;\n    public float Parameter;\n    public int StateIndex;\n}\n// 10 conditions * 16 bytes = 160 bytes inline\n\n[InternalBufferCapacity(5)]  // 3-5 boss phases typical\npublic struct BossStateSetup : IBufferElementData\n{\n    public float Weight;\n}\n// 5 states * 4 bytes = 20 bytes inline\n\n[InternalBufferCapacity(4)]  // 3-6 patrol waypoints common\npublic struct PatrolWaypoint : IBufferElementData\n{\n    public float3 Position;\n}\n// 4 waypoints * 12 bytes = 48 bytes inline\n\n// Zero capacity for large/variable buffers\n[InternalBufferCapacity(0)]  // Always heap-allocated\npublic struct LargeDataBuffer : IBufferElementData\n{\n    public float4x4 Matrix;  // 64 bytes per element - too large for chunk\n}\n// Chunk stores only pointer (8 bytes), data on heap\n\n// Runtime capacity override\nvar buffer = ecb.SetBuffer&lt;Targets&gt;(enemy);\nbuffer.Capacity = 10;  // Override internal capacity\n// If 10 &gt; InternalBufferCapacity \u2192 allocates heap\n// If 10 &lt;= InternalBufferCapacity \u2192 stays inline\n</code></pre> <p>Capacity sizing formula: - Element size: <code>sizeof(YourStruct)</code> bytes - Typical usage: Profile actual buffer lengths in game - Chunk budget: Balance against other components - Optimal capacity: Cover 80th percentile usage</p> <p>Profiling workflow: 1. Start with default (no attribute) 2. Profile: Log buffer lengths during gameplay 3. Analyze distribution: Find 80th percentile 4. Optimize: Set capacity to cover common case</p>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#pros","title":"Pros","text":"<ul> <li> <p>Cache-friendly - inline buffer storage keeps data in chunk, same cache line as other components</p> </li> <li> <p>Zero heap allocations - if buffer stays within capacity, no GC pressure or allocation overhead</p> </li> <li> <p>Predictable performance - chunk storage has consistent access patterns, no pointer chasing</p> </li> <li> <p>Memory efficiency - right-sized capacity avoids wasting chunk space on unused buffer elements</p> </li> <li> <p>Query performance - systems iterate chunks with better locality when buffers inline</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#cons","title":"Cons","text":"<ul> <li> <p>Wasted chunk space - oversized capacity reserves space even when buffer is small/empty</p> </li> <li> <p>Archetype fragmentation - changing capacity requires code change and archetype rebuild</p> </li> <li> <p>Profiling required - optimal capacity not obvious, requires measuring actual usage patterns</p> </li> <li> <p>Chunk overflow - entities with large components + buffers may not fit in 16KB Chunk, forcing early chunk allocation</p> </li> <li> <p>One size fits all - single capacity value for all entities of that archetype, can't vary per entity</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#best-use","title":"Best use","text":"<ul> <li> <p>Known size ranges - when profiling shows consistent buffer sizes (e.g., 90% of entities have 1-5 elements)</p> </li> <li> <p>Small elements - Entity (8 bytes), float (4 bytes), int (4 bytes) fit well in chunk with reasonable capacities</p> </li> <li> <p>Frequent access - buffers accessed every frame benefit most from chunk-inline storage</p> </li> <li> <p>Performance-critical - tight loops iterating thousands of entities gain measurable speedup from cache locality</p> </li> <li> <p>Stable usage - buffer sizes don't vary wildly between entities or over entity lifetime</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Highly variable sizes - if 50% of entities have 2 elements, 50% have 100 elements, no good capacity fits both</p> </li> <li> <p>Large elements - float4x4 (64 bytes), large structs waste chunk space even at capacity 1-2</p> </li> <li> <p>Rare usage - buffers accessed once per second don't benefit from chunk locality</p> </li> <li> <p>Unknown distribution - without profiling data, default capacity 8 is safer than guessing</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Element size calculation: Multiply struct size by capacity \u2192 <code>float3 (12 bytes) * capacity 5 = 60 bytes per entity</code></p> </li> <li> <p>Chunk budget awareness: Chunk is 16KB shared by all components - large buffers reduce entities per chunk</p> </li> <li> <p>Common capacity patterns: Small lists (3), medium lists (5), large lists (10), heap-only (0)</p> </li> <li> <p>Zero capacity pattern: <code>[InternalBufferCapacity(0)]</code> for large/variable data - never store inline, always heap</p> </li> <li> <p>Runtime capacity override: Can set higher capacity at spawn with <code>buffer.Capacity = N</code> to avoid reallocations</p> </li> <li> <p>Profiling in development: Log buffer lengths to find distribution: 80% have 1-3 \u2192 use capacity 3</p> </li> <li> <p>Performance impact: Chunk-inline ~1ns access (L1 cache) vs heap ~10ns (pointer indirection)</p> </li> <li> <p>Memory comparison: Capacity 3 saves 40 bytes vs capacity 8 for Entity buffers - scales across thousands of entities</p> </li> <li> <p>Combining with factories: Set buffer capacity in Entity Factory with Archetype to avoid heap allocation</p> </li> <li> <p>Testing tools: Create custom inspector to visualize buffer usage: capacity, length, heap-allocated flag</p> </li> <li> <p>Capacity evolution: Start with default, profile in alpha, optimize in beta based on actual gameplay data</p> </li> <li> <p>Best practices: Profile first, optimize for 80th percentile, consider element size impact, document reasoning</p> </li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Buffer%20Capacity%20Optimization/#see-also","title":"See also","text":"<ul> <li>Component Memory Alignment - Optimize memory layout within buffer elements for better cache performance</li> <li>ECS Design Decisions - Container component patterns and when to use buffers vs multiple components</li> </ul>","tags":["optimization"]},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/","title":"Component Memory Alignment","text":"<p>Practical guide to memory alignment and struct layout optimization in Unity ECS components for minimizing memory footprint and maximizing Cache-friendly performance.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#understanding-memory-alignment","title":"Understanding Memory Alignment","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#what-is-memory-alignment","title":"What is Memory Alignment?","text":"<p>Memory alignment is the practice of arranging data in memory so the CPU can read values efficiently as complete \"words\" without multiple memory accesses.</p> <p>Key concept: CPUs cannot read misaligned data directly. The compiler adds padding (empty bytes) to ensure each field starts at an address divisible by its size.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#the-problem-wasted-memory","title":"The Problem: Wasted Memory","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#example-1-simple-struct","title":"Example 1: Simple Struct","text":"<pre><code>// Naive assumption: 5 bytes total\nstruct BadLayout : IComponentData\n{\n    public int Health;     // 4 bytes\n    public bool IsDead;    // 1 byte\n}\n</code></pre> <p>Expected size: 5 bytes (4 + 1) Actual size: 8 bytes</p> <p>Memory footprint: <pre><code>[Health|Health|Health|Health]\n[IsDead|-------|-------|-------]\n</code></pre></p> <p>The compiler adds 3 bytes of padding after <code>IsDead</code> to align the struct to 4-byte boundaries.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#example-2-complex-struct","title":"Example 2: Complex Struct","text":"<pre><code>// \u274c Bad: Poorly ordered fields\nstruct PoorlyOrganized : IComponentData\n{\n    public bool IsDead;      // a - 1 byte\n    public int Health;       // b - 4 bytes\n    public bool NeedsHelp;   // c - 1 byte\n    public int XP;           // d - 4 bytes\n}\n</code></pre> <p>Memory footprint (16 bytes): <pre><code>[a|-|-|-]\n[b|b|b|b]\n[c|-|-|-]\n[d|d|d|d]\n</code></pre></p> <ul> <li>10 bytes of actual data</li> <li>6 bytes of padding (37.5% waste!)</li> </ul>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#example-3-optimized-layout","title":"Example 3: Optimized Layout","text":"<pre><code>// \u2705 Good: Fields ordered by size\nstruct WellOrganized : IComponentData\n{\n    public int Health;       // a - 4 bytes\n    public int XP;           // b - 4 bytes\n    public bool IsDead;      // c - 1 byte\n    public bool NeedsHelp;   // d - 1 byte\n}\n</code></pre> <p>Memory footprint (12 bytes): <pre><code>[a|a|a|a]\n[b|b|b|b]\n[c|d|-|-]\n</code></pre></p> <ul> <li>10 bytes of actual data</li> <li>2 bytes of padding</li> <li>25% memory reduction (from 16 to 12 bytes)</li> </ul>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#nested-structs-amplified-problem","title":"Nested Structs: Amplified Problem","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#bad-nested-structure","title":"Bad Nested Structure","text":"<pre><code>struct NestedBad\n{\n    public bool a;        // 1 byte\n    public long b;        // 8 bytes\n    public bool c;        // 1 byte\n}\n\nstruct ParentBad : IComponentData\n{\n    public NestedBad nested;\n    public int d;\n    public bool e;\n}\n\n// Inline expansion:\nstruct ParentBad_Expanded\n{\n    public bool a;\n    public long b;\n    public bool c;\n    public int d;\n    public bool e;\n}\n</code></pre> <p>Memory footprint (32 bytes): <pre><code>[a|-|-|-|-|-|-|-]\n[b|b|b|b|b|b|b|b]\n[c|-|-|-|-|-|-|-]\n[d|d|d|d|e|-|-|-]\n</code></pre></p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#optimized-nested-structure","title":"Optimized Nested Structure","text":"<pre><code>struct NestedGood\n{\n    public long b;        // 8 bytes\n    public int d;         // 4 bytes\n    public bool a;        // 1 byte\n    public bool c;        // 1 byte\n    public bool e;        // 1 byte\n}\n</code></pre> <p>Memory footprint (16 bytes): <pre><code>[b|b|b|b|b|b|b|b]\n[d|d|d|d|a|c|e|-]\n</code></pre></p> <p>Result: 50% memory reduction (from 32 to 16 bytes)</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#enum-optimization","title":"Enum Optimization","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#problem-default-enum-size","title":"Problem: Default Enum Size","text":"<pre><code>// \u274c Bad: Uses int (4 bytes) by default\nenum State\n{\n    Idle,\n    Walking,\n    Running\n}\n\nstruct Component : IComponentData\n{\n    public State CurrentState;  // 4 bytes for 3 values!\n}\n</code></pre> <p>Default enums use <code>int</code> (4 bytes), supporting 4+ billion values\u2014far more than needed.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#solution-byte-sized-enums","title":"Solution: Byte-Sized Enums","text":"<pre><code>// \u2705 Good: Uses byte (1 byte) for up to 256 values\nenum State : byte\n{\n    Idle,\n    Walking,\n    Running\n}\n\nstruct Component : IComponentData\n{\n    public State CurrentState;  // 1 byte (75% reduction)\n}\n</code></pre> <p>Impact: With 10,000 entities, this saves 30KB immediately.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#measuring-struct-size","title":"Measuring Struct Size","text":"<p>Use Unity's <code>UnsafeUtility</code> to inspect component sizes:</p> <pre><code>using Unity.Collections.LowLevel.Unsafe;\n\n// Check alignment (how struct should be aligned in memory)\nint alignment = UnsafeUtility.AlignOf&lt;MyComponent&gt;();\n\n// Check total size (including padding)\nint size = UnsafeUtility.SizeOf&lt;MyComponent&gt;();\n\nDebug.Log($\"MyComponent: {size} bytes, {alignment}-byte alignment\");\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#example-output","title":"Example Output","text":"<pre><code>struct Example : IComponentData\n{\n    public long a;    // 8 bytes\n    public int b;     // 4 bytes\n    public bool c;    // 1 byte\n}\n\n// Output: \"Example: 16 bytes, 8-byte alignment\"\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#optimization-best-practices","title":"Optimization Best Practices","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#1-sort-fields-by-size-largest-first","title":"1. Sort Fields by Size (Largest First)","text":"<pre><code>// \u2705 Optimal ordering\nstruct OptimalComponent : IComponentData\n{\n    // 8-byte types first\n    public double Timestamp;\n    public long EntityID;\n\n    // 4-byte types\n    public float Speed;\n    public int Health;\n\n    // 2-byte types\n    public ushort Level;\n\n    // 1-byte types last\n    public byte TeamID;\n    public bool IsActive;\n}\n</code></pre> <p>Field size reference: - 8 bytes: <code>long</code>, <code>ulong</code>, <code>double</code> - 4 bytes: <code>int</code>, <code>uint</code>, <code>float</code>, <code>enum</code> (default) - 2 bytes: <code>short</code>, <code>ushort</code> - 1 byte: <code>byte</code>, <code>sbyte</code>, <code>bool</code>, <code>enum : byte</code></p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#2-avoid-complex-nested-structs","title":"2. Avoid Complex Nested Structs","text":"<pre><code>// \u274c Bad: Nested struct makes alignment difficult to predict\nstruct PlayerComponent : IComponentData\n{\n    public HealthData Health;\n    public MovementData Movement;\n    public InventoryData Inventory;\n}\n\n// \u2705 Better: Flatten or separate into multiple components\nstruct PlayerHealthComponent : IComponentData\n{\n    public float MaxHealth;\n    public float CurrentHealth;\n}\n\nstruct PlayerMovementComponent : IComponentData\n{\n    public float Speed;\n    public float Acceleration;\n}\n</code></pre> <p>Benefits: - Predictable memory layout - Better Archetype granularity - Systems query only needed data</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#3-minimize-field-count","title":"3. Minimize Field Count","text":"<pre><code>// \u274c Bad: Kitchen sink component\nstruct PlayerComponent : IComponentData\n{\n    public float Health;\n    public float MaxHealth;\n    public float Speed;\n    public float JumpForce;\n    public float AttackDamage;\n    public int Level;\n    public int XP;\n    public bool IsGrounded;\n    public bool IsAttacking;\n    // ... 20 more fields\n}\n\n// \u2705 Good: Focused components\nstruct HealthComponent : IComponentData\n{\n    public float Max;\n    public float Current;\n}\n\nstruct MovementComponent : IComponentData\n{\n    public float Speed;\n    public bool IsGrounded;\n}\n</code></pre> <p>See also: ECS Design Decisions for component composition strategies</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#4-use-byte-sized-enums","title":"4. Use Byte-Sized Enums","text":"<pre><code>// \u2705 Always specify enum size when &lt; 256 values\npublic enum AIState : byte\n{\n    Idle,\n    Patrol,\n    Chase,\n    Attack\n}\n\npublic enum Team : byte\n{\n    Red,\n    Blue,\n    Green,\n    Neutral\n}\n\nstruct AIComponent : IComponentData\n{\n    public AIState CurrentState;   // 1 byte\n    public Team Team;               // 1 byte\n}\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#5-group-boolean-fields","title":"5. Group Boolean Fields","text":"<pre><code>// If you have many bools, consider bit packing\nstruct FlagsComponent : IComponentData\n{\n    public byte Flags;  // 1 byte can hold 8 booleans\n\n    public bool IsActive\n    {\n        get =&gt; (Flags &amp; 0b00000001) != 0;\n        set =&gt; Flags = value ? (byte)(Flags | 0b00000001) : (byte)(Flags &amp; ~0b00000001);\n    }\n\n    public bool IsVisible\n    {\n        get =&gt; (Flags &amp; 0b00000010) != 0;\n        set =&gt; Flags = value ? (byte)(Flags | 0b00000010) : (byte)(Flags &amp; ~0b00000010);\n    }\n\n    // ... up to 8 flags\n}\n</code></pre> <p>Trade-off: CPU instructions vs memory\u2014use sparingly for frequently accessed flags.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#real-world-impact","title":"Real-World Impact","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#scaling-analysis","title":"Scaling Analysis","text":"<pre><code>// Example: Character component\nstruct CharacterBad : IComponentData\n{\n    public bool IsDead;        // 1 byte\n    public int Health;         // 4 bytes\n    public bool NeedsHelp;     // 1 byte\n    public int XP;             // 4 bytes\n    // Actual: 16 bytes\n}\n\nstruct CharacterGood : IComponentData\n{\n    public int Health;         // 4 bytes\n    public int XP;             // 4 bytes\n    public bool IsDead;        // 1 byte\n    public bool NeedsHelp;     // 1 byte\n    // Actual: 12 bytes\n}\n</code></pre> <p>Memory savings at scale:</p> Entities Bad Layout Good Layout Savings 1,000 16 KB 12 KB 4 KB (25%) 10,000 160 KB 120 KB 40 KB (25%) 100,000 1.6 MB 1.2 MB 400 KB (25%) 1,000,000 16 MB 12 MB 4 MB (25%)"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#cache-line-considerations","title":"Cache Line Considerations","text":"<p>Modern CPUs load data in 64-byte cache lines. Smaller components mean:</p> <ol> <li>More entities per cache line:</li> <li>12-byte component: ~5 entities per cache line</li> <li> <p>16-byte component: ~4 entities per cache line</p> </li> <li> <p>Fewer cache misses during iteration</p> </li> <li> <p>Better Burst performance with SIMD processing</p> </li> </ol> <p>See also: Cache-friendly, Chunk</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#component-size-analyzer-tool","title":"Component Size Analyzer Tool","text":"<p>Maxim Zaks created a component size analyzer tool:</p> <p>Gist: https://gist.github.com/mzaks/ec261ac853621af8503b73391ebd18f1</p> <p>This tool analyzes your project's components and suggests optimizations.</p>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#common-type-sizes-reference","title":"Common Type Sizes Reference","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#primitive-types","title":"Primitive Types","text":"Type Size Alignment <code>bool</code> 1 byte 1 byte <code>byte</code>, <code>sbyte</code> 1 byte 1 byte <code>short</code>, <code>ushort</code> 2 bytes 2 bytes <code>int</code>, <code>uint</code>, <code>float</code> 4 bytes 4 bytes <code>long</code>, <code>ulong</code>, <code>double</code> 8 bytes 8 bytes <code>enum</code> (default) 4 bytes 4 bytes <code>enum : byte</code> 1 byte 1 byte"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#unity-types","title":"Unity Types","text":"Type Size Notes <code>float2</code> 8 bytes 2 floats <code>float3</code> 12 bytes 3 floats, padded to 16 <code>float4</code> 16 bytes 4 floats <code>quaternion</code> 16 bytes 4 floats <code>Entity</code> 8 bytes 2 ints <code>FixedString32Bytes</code> 32 bytes Fixed-size string <code>FixedString64Bytes</code> 64 bytes Fixed-size string"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#1-alternating-smalllarge-fields","title":"1. Alternating Small/Large Fields","text":"<pre><code>// \u274c Creates maximum padding\nstruct Worst : IComponentData\n{\n    public bool a;     // 1 byte + 3 padding\n    public int b;      // 4 bytes\n    public bool c;     // 1 byte + 3 padding\n    public int d;      // 4 bytes\n    // Total: 16 bytes (50% waste!)\n}\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#2-unnecessary-nesting","title":"2. Unnecessary Nesting","text":"<pre><code>// \u274c Nested structs inherit alignment requirements\nstruct Inner\n{\n    public long Value;  // Forces 8-byte alignment\n}\n\nstruct Outer : IComponentData\n{\n    public bool Flag;   // 1 byte + 7 padding due to Inner\n    public Inner Data;  // 8 bytes\n    // Total: 16 bytes (1 byte + 7 padding + 8 bytes)\n}\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#3-using-default-enums","title":"3. Using Default Enums","text":"<pre><code>// \u274c Wastes 3 bytes per enum\nenum Status { Active, Inactive }  // 4 bytes\n\n// \u2705 Use byte-sized enums\nenum Status : byte { Active, Inactive }  // 1 byte\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#debugging-memory-layout","title":"Debugging Memory Layout","text":""},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#manual-calculation","title":"Manual Calculation","text":"<ol> <li>Sort fields by size (largest first)</li> <li>Calculate cumulative offset:</li> <li>Each field starts at next multiple of its size</li> <li>Round struct size to largest field's alignment</li> </ol>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#example-calculation","title":"Example Calculation","text":"<pre><code>struct Example : IComponentData\n{\n    public int a;      // Offset 0, size 4\n    public bool b;     // Offset 4, size 1\n    public bool c;     // Offset 5, size 1\n    // Next field would start at offset 6\n}\n\n// Size calculation:\n// - Last field ends at offset 6 (5 + 1)\n// - Largest field alignment: 4 bytes (int)\n// - Round up to 8 bytes (next multiple of 4 &gt;= 6)\n// Total size: 8 bytes\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#performance-testing","title":"Performance Testing","text":"<pre><code>using Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\n\npublic static class ComponentProfiler\n{\n    public static void LogComponentInfo&lt;T&gt;() where T : struct, IComponentData\n    {\n        int size = UnsafeUtility.SizeOf&lt;T&gt;();\n        int alignment = UnsafeUtility.AlignOf&lt;T&gt;();\n\n        Debug.Log($\"{typeof(T).Name}:\");\n        Debug.Log($\"  Size: {size} bytes\");\n        Debug.Log($\"  Alignment: {alignment} bytes\");\n        Debug.Log($\"  Entities per 64B cache line: {64 / size}\");\n    }\n}\n\n// Usage in editor script or test\nComponentProfiler.LogComponentInfo&lt;MyComponent&gt;();\n</code></pre>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#optimization-checklist","title":"Optimization Checklist","text":"<p>Before finalizing component design:</p> <ul> <li> Fields sorted by size (8-byte \u2192 4-byte \u2192 2-byte \u2192 1-byte)</li> <li> Enums use <code>:byte</code> for &lt; 256 values</li> <li> Nested structs minimized or flattened</li> <li> Component size checked with <code>UnsafeUtility.SizeOf&lt;T&gt;()</code></li> <li> Total field count kept minimal (consider splitting)</li> <li> Boolean flags grouped or bit-packed if many</li> <li> No alternating large/small field patterns</li> <li> Alignment verified with <code>UnsafeUtility.AlignOf&lt;T&gt;()</code></li> </ul>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#related-topics","title":"Related Topics","text":"<ul> <li>Cache-friendly - How memory layout affects cache performance</li> <li>Chunk - How components are stored in 16KB chunks</li> <li>SoA layout - Structure of Arrays layout in ECS</li> <li>ECS Design Decisions - When to split vs combine components</li> <li>IComponentData - Basic component type</li> </ul>"},{"location":"DOTS/Optimization/Component%20Memory%20Alignment/#further-reading","title":"Further Reading","text":"<ul> <li>Original article: Memory alignment and Component design in Unity ECS by Maxim Zaks (July 2019)</li> <li>Component Size Analyzer: https://gist.github.com/mzaks/ec261ac853621af8503b73391ebd18f1</li> <li>Follow-up article: Slicing and Dicing Components for Unity ECS</li> </ul>"},{"location":"DOTS/Patterns/","title":"Patterns","text":"<p>Common design patterns and best practices for Unity DOTS development.</p>"},{"location":"DOTS/Patterns/#architecture-design","title":"Architecture &amp; Design","text":"<ul> <li>ECS Design Decisions - Architectural patterns and decision-making framework for component design, system architecture, and OOP integration</li> </ul>"},{"location":"DOTS/Patterns/#query-patterns","title":"Query Patterns","text":"<ul> <li>SystemAPI.Query - Main entity iteration pattern with foreach syntax</li> <li>WithChangeFilter (reactive updates) - Reactive systems that only process changed entities</li> <li>Singleton entities and components - Global single-instance components and entities</li> </ul>"},{"location":"DOTS/Patterns/#query-pattern-overview","title":"Query Pattern Overview","text":""},{"location":"DOTS/Patterns/#systemapiquery","title":"SystemAPI.Query","text":"<p>The primary way to iterate entities in OnUpdate: <pre><code>foreach (var (health, damage) in\n    SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;Damage&gt;&gt;()\n        .WithAll&lt;Active&gt;()\n        .WithNone&lt;Dead&gt;())\n{\n    health.ValueRW.Current -= damage.ValueRO.Amount;\n}\n</code></pre></p>"},{"location":"DOTS/Patterns/#withchangefilter","title":"WithChangeFilter","text":"<p>Reactive pattern for UI, synchronization, or expensive operations: <pre><code>foreach (var (health, healthBar) in\n    SystemAPI.Query&lt;RefRO&lt;Health&gt;, HealthBarUI&gt;()\n        .WithChangeFilter&lt;Health&gt;())\n{\n    healthBar.UpdateUI(health.ValueRO.Current);\n}\n</code></pre></p>"},{"location":"DOTS/Patterns/#singleton-pattern","title":"Singleton Pattern","text":"<p>Global access to single-instance components: <pre><code>GameConfig config = SystemAPI.GetSingleton&lt;GameConfig&gt;();\nRefRW&lt;PlayerState&gt; state = SystemAPI.GetSingletonRW&lt;PlayerState&gt;();\n</code></pre></p>"},{"location":"DOTS/Patterns/#component-management-patterns","title":"Component Management Patterns","text":"<ul> <li>Cleanup Component Pattern - Detect component removal using paired cleanup components</li> <li>Helper Methods for Component Sets - Utility functions to add groups of interdependent components</li> <li>Auto-Add System Pattern - Automatically add supporting components when entry component exists</li> <li>Reusable Archetype Groups - Cache archetype definitions for reuse across systems</li> </ul>"},{"location":"DOTS/Patterns/#entity-control-patterns","title":"Entity Control Patterns","text":"<ul> <li>Disable Tag Pattern - Temporarily pause entity processing using disable tags</li> <li>Request Component Pattern - Reversible operations triggered by adding/removing request components</li> </ul>"},{"location":"DOTS/Patterns/#data-structure-patterns","title":"Data Structure Patterns","text":"<ul> <li>NativeParallelMultiHashMap for Entity Collections - Store one-to-many entity relationships (parent-children, groupings)</li> </ul>"},{"location":"DOTS/Patterns/#additional-patterns","title":"Additional Patterns","text":""},{"location":"DOTS/Patterns/#entity-relationships","title":"Entity Relationships","text":"<ul> <li>Parent-Child - Using Parent component and ComponentLookup</li> <li>Entity References - Components storing Entity IDs for targets, owners, etc.</li> </ul>"},{"location":"DOTS/Patterns/#deferred-changes","title":"Deferred Changes","text":"<ul> <li>EntityCommandBuffer - Queue structural changes for later playback</li> <li>Parallel ECB - Use ChunkIndexInQuery for deterministic parallel writes</li> </ul>"},{"location":"DOTS/Patterns/#performance-patterns","title":"Performance Patterns","text":"<ul> <li>Burst - Always use BurstCompile for maximum performance</li> <li>Job Parallelization - Use IJobEntity.ScheduleParallel() for multi-threading</li> <li>Change Filters - Skip unchanged entities with WithChangeFilter (reactive updates)</li> </ul>"},{"location":"DOTS/Patterns/#best-practices","title":"Best Practices","text":"<ol> <li>Use SystemAPI.Query for most entity iteration (simplest and most ergonomic)</li> <li>Add WithChangeFilter for reactive systems (UI, logging, expensive operations)</li> <li>Use singletons for global state and configuration</li> <li>Prefer read-only access (RefRO, [ReadOnly]) when possible for parallelization</li> <li>Use EntityCommandBuffer for structural changes in jobs</li> </ol>"},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/","title":"Auto Add System Pattern","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#description","title":"Description","text":"<ul> <li> <p>Automatic component addition pattern where a system detects \"entry point\" Component and automatically adds required supporting components</p> </li> <li> <p>Query pattern uses <code>.WithAll&lt;EntryComponent&gt;().WithNone&lt;SupportingComponent&gt;()</code> to find entities missing required components</p> </li> <li> <p>Supporting components become difficult to manually remove - system re-adds them next frame, enforcing component dependencies</p> </li> <li> <p>Useful for maintaining invariants where certain components always require other components to function correctly</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#example","title":"Example","text":"<pre><code>// Entry point component - user adds this\npublic struct CharacterController : IComponentData\n{\n    public float Speed;\n    public float JumpForce;\n}\n\n// Supporting components - auto-added by system\npublic struct CharacterVelocity : IComponentData { public float3 Value; }\npublic struct GroundedState : IComponentData { public bool IsGrounded; }\n\n// Auto-add system\n[UpdateInGroup(typeof(InitializationSystemGroup))]\n[BurstCompile]\npublic partial struct AutoAddCharacterComponentsSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        var ecb = new EntityCommandBuffer(Allocator.Temp);\n\n        // Find entities missing supporting components\n        foreach (var (controller, entity) in\n            SystemAPI.Query&lt;RefRO&lt;CharacterController&gt;&gt;()\n                .WithNone&lt;CharacterVelocity&gt;()\n                .WithEntityAccess())\n        {\n            // Auto-add required components\n            ecb.AddComponent(entity, new CharacterVelocity { Value = float3.zero });\n            ecb.AddComponent(entity, new GroundedState { IsGrounded = true });\n        }\n\n        ecb.Playback(state.EntityManager);\n        ecb.Dispose();\n    }\n}\n\n// Example: Auto-add with calculated values\npublic struct Enemy : IComponentData { public int Level; }\npublic struct EnemyStats : IComponentData\n{\n    public float Health;\n    public float Damage;\n    public float Speed;\n}\n\nforeach (var (enemy, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Enemy&gt;&gt;()\n        .WithNone&lt;EnemyStats&gt;()\n        .WithEntityAccess())\n{\n    // Calculate stats based on entry component data\n    int level = enemy.ValueRO.Level;\n    ecb.AddComponent(entity, new EnemyStats\n    {\n        Health = 100 + (level * 20),\n        Damage = 10 + (level * 2),\n        Speed = 3 + (level * 0.5f)\n    });\n}\n</code></pre> <p>Common use cases: - Physics body \u2192 auto-add velocity + damping components - Renderable \u2192 auto-add render bounds + material info - Character \u2192 auto-add velocity + grounded state - Parent \u2192 auto-add PreviousParent cleanup component</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#pros","title":"Pros","text":"<ul> <li> <p>Enforces dependencies - ensures required components always present, preventing bugs</p> </li> <li> <p>Simplifies entity creation - users only add entry component, supporting components added automatically</p> </li> <li> <p>Self-healing - if supporting components accidentally removed, re-added next frame</p> </li> <li> <p>Decouples creation - entity creation code doesn't need to know all required components</p> </li> <li> <p>Centralized logic - component dependencies defined in one place</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#cons","title":"Cons","text":"<ul> <li> <p>Hidden behavior - not obvious from entity inspector that components will be auto-added</p> </li> <li> <p>Performance overhead - system runs every frame checking for missing components</p> </li> <li> <p>Can't manually remove - supporting components resist removal, harder to test/debug</p> </li> <li> <p>Structural changes cost - adding components has overhead, though only happens once</p> </li> <li> <p>Execution order dependency - must run in InitializationSystemGroup or early</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#best-use","title":"Best use","text":"<ul> <li> <p>Required component pairs - when component A always needs B and C (physics body + velocity + damping)</p> </li> <li> <p>Complex features - rendering, physics, AI requiring multiple components</p> </li> <li> <p>Framework features - reusable systems users interact with via single entry component</p> </li> <li> <p>Preventing user errors - when manual component management error-prone</p> </li> <li> <p>Cleanup component pairs - auto-add ICleanupComponentData cleanup components</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Optional components - if supporting components situational, don't auto-add</p> </li> <li> <p>Performance critical - if entities created very frequently, structural change overhead too high</p> </li> <li> <p>Simple dependencies - for 1-2 components, Helper Methods for Component Sets may be clearer</p> </li> <li> <p>Need manual control - if users need fine-grained control, auto-add too restrictive</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Auto-Add%20System%20Pattern/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Run early: Use <code>[UpdateInGroup(typeof(InitializationSystemGroup))]</code> to ensure components added before other systems</p> </li> <li> <p>RequireMatchingQueriesForUpdate: Add this attribute to skip system when no matching entities:   <pre><code>[RequireMatchingQueriesForUpdate]\npublic partial struct AutoAddSystem : ISystem { }\n</code></pre></p> </li> <li> <p>Multiple component sets: Can use ComponentTypeSet to add multiple at once:   <pre><code>var components = new ComponentTypeSet(/* ... */);\necb.AddComponent(entity, components);\n</code></pre></p> </li> <li> <p>Cleanup component auto-add: Common pattern for cleanup components:   <pre><code>// Auto-add PreviousParent when Parent added\n.WithAll&lt;Parent&gt;().WithNone&lt;PreviousParent&gt;()\n</code></pre></p> </li> <li> <p>Conditional auto-add: Can check component values to decide what to add:   <pre><code>if (!config.ValueRO.IsPlayer)\n    ecb.AddComponent&lt;AIController&gt;(entity);\n</code></pre></p> </li> <li> <p>Unity packages using this: Unity.Transforms, Unity.Rendering, Unity.Physics all use variations</p> </li> <li> <p>Documentation critical: Clearly document which components are entry points and what gets auto-added</p> </li> <li> <p>Performance optimization: Cache EntityQuery in OnCreate and check <code>.IsEmpty</code>:   <pre><code>if (_missingComponentsQuery.IsEmpty) return;\n</code></pre></p> </li> <li> <p>Alternative - Baking: Can add supporting components during baking instead of runtime:   <pre><code>public override void Bake(MyAuthoring authoring)\n{\n    AddComponent&lt;EntryComponent&gt;(entity);\n    AddComponent&lt;SupportingComponent&gt;(entity);\n}\n</code></pre></p> </li> <li> <p>Hybrid approach: Use baking for SubScene entities, auto-add for runtime-spawned entities</p> </li> <li> <p>Best practices: Document entry points, run in InitializationSystemGroup, use RequireMatchingQueriesForUpdate, consider baking for static entities</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/","title":"Cleanup Component Pattern","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#description","title":"Description","text":"<ul> <li> <p>Cleanup detection pattern using paired ICleanupComponentData components to detect when a regular Component is removed or its Entity is destroyed</p> </li> <li> <p>Works by pairing a regular component with a cleanup component - when the regular component is removed, the cleanup component remains temporarily</p> </li> <li> <p>Query pattern uses <code>.WithNone&lt;RegularComponent&gt;().WithAll&lt;CleanupComponent&gt;()</code> to find entities where the regular component was removed</p> </li> <li> <p>Unity's official packages use this extensively - <code>Parent</code> paired with <code>PreviousParent</code> to detect parent relationship changes</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#example","title":"Example","text":"<pre><code>// Regular component\npublic struct Parent : IComponentData\n{\n    public Entity Value;\n}\n\n// Cleanup component - remains when Parent removed\npublic struct PreviousParent : ICleanupComponentData\n{\n    public Entity Value;\n}\n\n// Detect removal\nforeach (var (previousParent, entity) in\n    SystemAPI.Query&lt;RefRO&lt;PreviousParent&gt;&gt;()\n        .WithNone&lt;Parent&gt;()  // Parent was removed\n        .WithEntityAccess())\n{\n    // Access last known parent value\n    Entity oldParent = previousParent.ValueRO.Value;\n    // Perform cleanup logic...\n    ecb.RemoveComponent&lt;PreviousParent&gt;(entity);\n}\n\n// Maintain pair - add cleanup when Parent added\nforeach (var (parent, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Parent&gt;&gt;()\n        .WithNone&lt;PreviousParent&gt;()\n        .WithEntityAccess())\n{\n    ecb.AddComponent(entity, new PreviousParent { Value = parent.ValueRO.Value });\n}\n</code></pre> <p>Pattern flow: 1. Entity gets <code>Parent</code> component 2. System auto-adds <code>PreviousParent</code> cleanup component 3. When <code>Parent</code> removed, <code>PreviousParent</code> remains one frame 4. Detection system finds <code>.WithNone&lt;Parent&gt;().WithAll&lt;PreviousParent&gt;()</code> 5. System performs cleanup, removes <code>PreviousParent</code></p>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#pros","title":"Pros","text":"<ul> <li> <p>Captures last state - cleanup component preserves last known value for cleanup logic</p> </li> <li> <p>Automatic entity destruction handling - cleanup components automatically removed when entity destroyed</p> </li> <li> <p>Reliable detection - guaranteed to detect component removal regardless of how removed</p> </li> <li> <p>Used in Unity packages - battle-tested pattern in Unity.Transforms, Unity.Scenes</p> </li> <li> <p>Decoupled cleanup - separation between component and cleanup logic</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#cons","title":"Cons","text":"<ul> <li> <p>Requires two components - doubles component count, increases memory overhead</p> </li> <li> <p>Manual maintenance - must ensure cleanup component is added/updated alongside regular component</p> </li> <li> <p>Processing delay - cleanup detection happens in next frame, not immediately</p> </li> <li> <p>Extra Archetype overhead - entities cycle through multiple archetypes</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#best-use","title":"Best use","text":"<ul> <li> <p>Parent-child relationships - detect when parent/child relationships broken (like Unity.Transforms)</p> </li> <li> <p>Resource cleanup - detect when entities with external resources destroyed</p> </li> <li> <p>Relationship tracking - detect when entity references removed to update bidirectional relationships</p> </li> <li> <p>Death detection - trigger effects when health/alive component removed</p> </li> <li> <p>Network synchronization - detect entity destruction to send removal messages</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Simple removal logic - if no special cleanup needed, use regular component destruction</p> </li> <li> <p>Frequent add/remove - overhead of maintaining cleanup pairs too high</p> </li> <li> <p>Can use IEnableableComponent - if just toggling on/off, enableable components lighter</p> </li> <li> <p>Immediate cleanup needed - cleanup pattern has one-frame delay</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Cleanup%20Component%20Pattern/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Unity.Transforms example: <code>Parent</code> + <code>PreviousParent</code> is canonical example - check Unity.Transforms source</p> </li> <li> <p>Automatic cleanup: Cleanup components automatically removed when entity destroyed</p> </li> <li> <p>Combining with change filters: Use WithChangeFilter on regular component to detect changes, cleanup component to detect removal</p> </li> <li> <p>Auto-add integration: Combine with Auto-Add System Pattern to automatically add cleanup when regular component added</p> </li> <li> <p>Query optimization: <code>.WithNone&lt;Regular&gt;().WithAll&lt;Cleanup&gt;()</code> efficient - only matches transition state entities</p> </li> <li> <p>Store meaningful state: Cleanup component can store snapshot, not just tag</p> </li> <li> <p>Always remove cleanup: Remove cleanup component after processing to avoid re-detection next frame</p> </li> <li> <p>Best practices: Name cleanup components clearly (Previous, Cleanup), use ISystem with BurstCompile, document behavior</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/","title":"Disable Tag Pattern","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#description","title":"Description","text":"<ul> <li> <p>System pause pattern using Tag Component that systems include in <code>.WithNone&lt;DisableTag&gt;()</code> queries to temporarily stop processing entities</p> </li> <li> <p>Allows pausing systems by adding disable tag, avoiding expensive component removal/re-addition and preserving component data</p> </li> <li> <p>Unity's <code>Unity.Scenes</code> package uses <code>DisableSceneResolveAndLoad</code> tag to temporarily pause scene loading</p> </li> <li> <p>More granular than disabling entire systems - can disable specific entities while others continue processing</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#example","title":"Example","text":"<pre><code>// Define disable tag\npublic struct DisableAI : IComponentData { }\n\n// System respects disable tag\nforeach (var (aiState, entity) in\n    SystemAPI.Query&lt;RefRW&lt;AIState&gt;&gt;()\n        .WithNone&lt;DisableAI&gt;()  // Skip disabled entities\n        .WithEntityAccess())\n{\n    // Update AI logic...\n}\n\n// Toggle processing\nentityManager.AddComponent&lt;DisableAI&gt;(entity);     // Pause\nentityManager.RemoveComponent&lt;DisableAI&gt;(entity);  // Resume\n\n// Multiple systems can respect same disable tag\n[BurstCompile]\npublic partial struct AIUpdateSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var ai in SystemAPI.Query&lt;RefRW&lt;AIState&gt;&gt;()\n            .WithNone&lt;DisableAI&gt;()) { /* ... */ }\n    }\n}\n\n[BurstCompile]\npublic partial struct AITargetingSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var target in SystemAPI.Query&lt;RefRW&lt;Target&gt;&gt;()\n            .WithNone&lt;DisableAI&gt;()) { /* ... */ }\n    }\n}\n\n// Stun effect using disable tags\npublic struct StunTimer : IComponentData { public float Remaining; }\n\nforeach (var (stunTimer, entity) in\n    SystemAPI.Query&lt;RefRW&lt;StunTimer&gt;&gt;().WithEntityAccess())\n{\n    if (stunTimer.ValueRO.Remaining &gt; 0)\n    {\n        // Apply disable tags\n        ecb.AddComponent&lt;DisableMovement&gt;(entity);\n        ecb.AddComponent&lt;DisableCombat&gt;(entity);\n        stunTimer.ValueRW.Remaining -= deltaTime;\n    }\n    else\n    {\n        // Remove disable tags\n        ecb.RemoveComponent&lt;DisableMovement&gt;(entity);\n        ecb.RemoveComponent&lt;DisableCombat&gt;(entity);\n    }\n}\n</code></pre> <p>Common disable tags: - <code>DisableAI</code> - pause all AI systems - <code>DisableRendering</code> - hide entity - <code>DisablePhysics</code> - pause physics simulation - <code>DisableMovement</code> - prevent movement - <code>DisableCombat</code> - prevent attacks</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#pros","title":"Pros","text":"<ul> <li> <p>Preserves data - disabling via tag keeps all component data intact, no need to cache and restore</p> </li> <li> <p>Cheaper than removal - adding/removing zero-size tag faster than removing/re-adding data components</p> </li> <li> <p>Granular control - can disable specific entities while others continue, unlike disabling entire systems</p> </li> <li> <p>Reversible - easily toggle on/off, perfect for temporary states (pause, stun, cutscenes)</p> </li> <li> <p>Multi-system coordination - multiple systems can respect same disable tag</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#cons","title":"Cons","text":"<ul> <li> <p>Must update all queries - every relevant system must include <code>.WithNone&lt;DisableTag&gt;()</code></p> </li> <li> <p>Easy to forget - developers might create new systems and forget disable tag check</p> </li> <li> <p>Structural changes still occur - adding/removing tags causes structural changes</p> </li> <li> <p>Not automatic - requires manual coordination, unlike IEnableableComponent</p> </li> <li> <p>Memory overhead - tag component creates archetype variants (with/without disable tag)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#best-use","title":"Best use","text":"<ul> <li> <p>Pause/resume systems - temporarily pause scene loading, AI, rendering without losing state</p> </li> <li> <p>Status effects - stun, freeze, sleep effects that disable multiple systems</p> </li> <li> <p>Cutscenes - disable gameplay systems during cutscenes while keeping entity state</p> </li> <li> <p>Debugging - selectively disable entity processing to debug specific behaviors</p> </li> <li> <p>Multi-system coordination - when multiple systems need to pause together</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Single system - if only one system needs check, consider component flag instead</p> </li> <li> <p>Frequent toggling - if changes every frame, IEnableableComponent more efficient (no structural changes)</p> </li> <li> <p>Complex conditions - if logic is complex, consider state machine components</p> </li> <li> <p>Need per-component disable - disable tags affect entire entity, use IEnableableComponent for specific components</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Disable%20Tag%20Pattern/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Naming conventions: Prefix with <code>Disable</code> (DisableAI, DisableRendering) for clarity</p> </li> <li> <p>Multiple disable tags: Can use multiple for different system groups: <code>.WithNone&lt;DisableMovement&gt;().WithNone&lt;DisableCombat&gt;()</code></p> </li> <li> <p>IEnableableComponent alternative: For frequent toggling, use IEnableableComponent to avoid structural changes:   <pre><code>public struct AIEnabled : IComponentData, IEnableableComponent { }\nSystemAPI.SetComponentEnabled&lt;AIEnabled&gt;(entity, false);  // No structural change\n</code></pre></p> </li> <li> <p>Global disable via singleton: Can use singleton to disable all entities:   <pre><code>if (SystemAPI.HasSingleton&lt;GlobalDisableAI&gt;()) return;\n</code></pre></p> </li> <li> <p>Unity.Scenes usage: <code>DisableSceneResolveAndLoad</code> is real example from Unity packages</p> </li> <li> <p>Documentation critical: Document which systems respect which disable tags - easy to forget</p> </li> <li> <p>Archetype fragmentation: Disable tags create variants - Enemy, Enemy+DisableAI, Enemy+DisableMovement, Enemy+Both</p> </li> <li> <p>Batch operations: When disabling many entities, batch tag additions for efficiency</p> </li> <li> <p>Editor debugging: Disable tags visible in Entity Inspector, easy to see why entity not processing</p> </li> <li> <p>When to use IEnableableComponent instead: Disable specific component, frequent toggling, avoid structural changes, per-component state</p> </li> <li> <p>When to use disable tag: Coordinate multiple systems, temporary infrequent disable, simple on/off, following Unity patterns</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/","title":"ECS Design Decisions","text":"<p>A practical guide to architectural decisions when building games with ECS. Based on production experience and common design challenges.</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#core-design-questions","title":"Core Design Questions","text":"<p>Every ECS architecture faces four fundamental decisions:</p> <ol> <li>Data distribution: Which Component should hold specific data?</li> <li>Logic placement: Should processing occur in Systems, scripts, or components?</li> <li>Integration: How to combine ECS with existing OOP codebases?</li> <li>Refactoring: When and how to restructure as understanding evolves?</li> </ol>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#component-design-anti-patterns","title":"Component Design Anti-Patterns","text":""},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#monolithic-components","title":"Monolithic Components","text":"<p>Problem: Combining multiple concerns into one component creates maintainability issues.</p> <pre><code>// \u274c Bad: Everything bundled together\npublic struct CharacterComponent : IComponentData\n{\n    // Control data\n    public float controlSpeed;\n    public float controlAcceleration;\n\n    // Platformer data\n    public float platformGravity;\n    public float platformFriction;\n\n    // Jump data\n    public float jumpForce;\n    public int jumpMaxCount;\n}\n</code></pre> <p>Issues: - Variables with prefixes indicate mixed concerns - Can't reuse jump logic without dragging control/platform data - Systems querying this component get unnecessary data - Archetype bloat when entities need only subset of features</p> <p>Solution: Separate into focused components:</p> <pre><code>// \u2705 Good: Single responsibility\npublic struct ControlComponent : IComponentData\n{\n    public float Speed;\n    public float Acceleration;\n}\n\npublic struct PlatformerComponent : IComponentData\n{\n    public float Gravity;\n    public float Friction;\n}\n\npublic struct JumpComponent : IComponentData\n{\n    public float Force;\n    public int MaxCount;\n    public int CurrentCount;\n}\n</code></pre> <p>Benefits: - Entities selectively include relevant functionality - Systems query only required components - Better Cache-friendly data access - Reduced Archetype fragmentation</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#component-design-patterns","title":"Component Design Patterns","text":""},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#tag-components-pattern","title":"Tag Components Pattern","text":"<p>Empty components serve as inclusion/exclusion markers without data overhead.</p> <pre><code>// Inclusion marker\npublic struct EnemyTag : IComponentData { }\n\n// Exclusion marker\npublic struct DisabledTag : IComponentData { }\n</code></pre> <p>Use cases: - Filtering: Systems use tags in queries to process specific entity subsets - State flags: Add/remove tags instead of boolean fields (avoids Structural changes overhead when state changes frequently) - Debug markers: Temporary tags for profiling or visualization</p> <pre><code>// System processes only enabled enemies\npartial struct EnemyAISystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (transform, ai) in SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;AIComponent&gt;&gt;()\n            .WithAll&lt;EnemyTag&gt;()\n            .WithNone&lt;DisabledTag&gt;())\n        {\n            // Process enabled enemies only\n        }\n    }\n}\n</code></pre> <p>See also: Tag-Based Behavior Selection, Disable Tag Pattern</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#command-components-pattern","title":"Command Components Pattern","text":"<p>Single-frame components encapsulate one-time operations requiring system-level knowledge.</p> <pre><code>public struct SpineSkinChangeCommand : IComponentData\n{\n    public FixedString64Bytes SkinName;\n}\n</code></pre> <p>When to use: - Operation needs access to system-level data structures - Requires specific execution ordering - Must coordinate with multiple systems - Direct method calls unavailable due to burst/jobs context</p> <p>Implementation: <pre><code>// Producer: Add command\necb.AddComponent(entity, new SpineSkinChangeCommand { SkinName = \"DamagedSkin\" });\n\n// Consumer: Process and remove\nforeach (var (cmd, entity) in SystemAPI.Query&lt;RefRO&lt;SpineSkinChangeCommand&gt;&gt;()\n    .WithEntityAccess())\n{\n    ProcessSkinChange(cmd.ValueRO.SkinName);\n    ecb.RemoveComponent&lt;SpineSkinChangeCommand&gt;(entity);\n}\n</code></pre></p> <p>See also: Request Component Pattern, Cleanup Component Pattern</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#container-components-pattern","title":"Container Components Pattern","text":"<p>Use container structs instead of multiple component instances of same type.</p> <pre><code>// \u274c Bad: Can't add multiple components of same type\n// entity.AddComponent&lt;AbilityComponent&gt;(); // Want 3 abilities? Can't!\n\n// \u2705 Good: Container holds collection\npublic struct AbilitiesComponent : IComponentData\n{\n    public BlobAssetReference&lt;BlobArray&lt;Ability&gt;&gt; Abilities;\n}\n\n// Or with dynamic buffers:\npublic struct AbilityElement : IBufferElementData\n{\n    public int AbilityID;\n    public float Cooldown;\n}\n</code></pre> <p>Benefits: - Query efficiency maintained (one component vs many) - No special-case handling - Natural iteration over collection - Better memory locality</p> <p>See also: IBufferElementData (dynamic buffers), BlobAsset (immutable data)</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#system-architecture-patterns","title":"System Architecture Patterns","text":""},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#focused-system-queries","title":"Focused System Queries","text":"<p>Problem: Broad system queries create processing inefficiencies.</p> <pre><code>// \u274c Bad: Requires all components\npartial struct MovementSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Only processes entities with ALL components\n        foreach (var (transform, velocity, gravity, friction) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;,\n                           RefRO&lt;Gravity&gt;, RefRO&lt;Friction&gt;&gt;())\n        {\n            // Entities without Gravity or Friction are excluded entirely\n        }\n    }\n}\n</code></pre> <p>Solution: Decompose into focused systems:</p> <pre><code>// \u2705 Good: Minimal component requirements\npartial struct VelocitySystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (transform, velocity) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;())\n        {\n            transform.ValueRW.Position += velocity.ValueRO.Value * SystemAPI.Time.DeltaTime;\n        }\n    }\n}\n\npartial struct GravitySystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Separate system for gravity - runs on entities with Velocity + Gravity\n        foreach (var (velocity, gravity) in\n            SystemAPI.Query&lt;RefRW&lt;Velocity&gt;, RefRO&lt;Gravity&gt;&gt;())\n        {\n            velocity.ValueRW.Value += gravity.ValueRO.Value * SystemAPI.Time.DeltaTime;\n        }\n    }\n}\n</code></pre> <p>Benefits: - Selective processing (entities get only relevant updates) - Better parallelization opportunities - Clearer system dependencies - Reduced false-positive entity inclusions</p> <p>Principle: \"Better to have more systems running small chunks of logic than fewer systems handling mixed concerns\"</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#system-ordering-dependencies","title":"System Ordering Dependencies","text":"<p>Incorrect ordering causes perception delays and bugs.</p> <pre><code>// \u274c Problem: Heavy objects don't initialize until frame 2\n// Frame 1: SpawnSystem creates entity\n// Frame 2: InitializationSystem processes entity (too late!)\n</code></pre> <p>Solutions:</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#1-explicit-system-ordering","title":"1. Explicit System Ordering","text":"<pre><code>[UpdateInGroup(typeof(InitializationSystemGroup))]\n[UpdateAfter(typeof(SpawnSystem))]\npublic partial struct InitializationSystem : ISystem { }\n</code></pre>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#2-entity-creation-callbacks","title":"2. Entity Creation Callbacks","text":"<pre><code>var entity = ecb.CreateEntity(archetype);\n// Immediate initialization\necb.AddComponent(entity, new InitializedComponent { Value = ComputeHeavyValue() });\n</code></pre>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#3-lazy-initialization","title":"3. Lazy Initialization","text":"<pre><code>public struct HeavyDataComponent : IComponentData\n{\n    public bool IsInitialized;\n    public float ExpensiveValue;\n}\n\n// Defer until needed\nif (!data.IsInitialized)\n{\n    data.ExpensiveValue = ComputeHeavyValue();\n    data.IsInitialized = true;\n}\n</code></pre>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#4-multiple-update-phases","title":"4. Multiple Update Phases","text":"<pre><code>[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\npublic partial struct PhysicsSystem : ISystem { }\n\n[UpdateInGroup(typeof(SimulationSystemGroup))]\npublic partial struct GameplaySystem : ISystem { }\n\n[UpdateInGroup(typeof(PresentationSystemGroup))]\npublic partial struct RenderSystem : ISystem { }\n</code></pre> <p>See also: UpdateInGroup, UpdateBefore, UpdateAfter, System Group, System Dependencies</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#one-frame-delays-vs-immediate-execution","title":"One-Frame Delays vs Immediate Execution","text":"<p>Guideline: Not all logic belongs in systems.</p> <pre><code>// \u2705 Good: Immediate state transitions\npublic void OnTriggerEntered(Entity other)\n{\n    // Change state immediately\n    currentState = State.Attacking;\n\n    // Store event for system processing\n    ecb.AddComponent(entity, new StateChangedEvent\n    {\n        OldState = State.Idle,\n        NewState = State.Attacking\n    });\n}\n\n// System processes events later for callbacks/reactions\npartial struct StateEventSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (evt, entity) in SystemAPI.Query&lt;RefRO&lt;StateChangedEvent&gt;&gt;()\n            .WithEntityAccess())\n        {\n            NotifyScriptsOfStateChange(evt.ValueRO);\n            ecb.RemoveComponent&lt;StateChangedEvent&gt;(entity);\n        }\n    }\n}\n</code></pre> <p>Principle: Simple operations (vector addition, state transitions) can execute instantly. Defer to systems only when coordination, ordering, or system-level knowledge required.</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#integration-with-oop-codebases","title":"Integration with OOP Codebases","text":""},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#gradual-migration-pattern","title":"Gradual Migration Pattern","text":"<p>Don't refactor everything at once. Embed existing classes initially:</p> <pre><code>// \u2705 Good: Incremental transition\npublic struct FormationComponent : IComponentData\n{\n    public BlobAssetReference&lt;FormationData&gt; Formation; // Converted to blob\n}\n\npublic struct BehaviorComponent : IComponentData\n{\n    public ManagedBehavior Behavior; // Still OOP class (managed component)\n}\n</code></pre> <p>Benefits: - Reuse existing logic without rewrites - Identify ECS boundaries incrementally - Transition step-by-step as systems stabilize - Validate architecture before committing</p> <p>Note: Managed components break Burst compilation and reduce performance. Migrate to unmanaged data over time.</p> <p>See also: Managed IComponentData (class components)</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#entity-abstractions-for-complex-concepts","title":"Entity Abstractions for Complex Concepts","text":"<p>Abstract concepts (formations, squads, teams) benefit from becoming entities.</p> <pre><code>// \u274c Old: Formation as data in members\npublic struct UnitComponent : IComponentData\n{\n    public int FormationID; // Weak reference\n}\n\n// \u2705 Better: Formation as entity\npublic struct FormationTag : IComponentData { }\npublic struct FormationMemberComponent : IComponentData\n{\n    public Entity FormationEntity; // Strong entity reference\n}\n\n// Query all units in a formation\nforeach (var member in SystemAPI.Query&lt;RefRO&lt;FormationMemberComponent&gt;&gt;())\n{\n    if (member.ValueRO.FormationEntity == targetFormation)\n    {\n        // Process unit\n    }\n}\n\n// Formation entity can have its own components\necb.AddComponent(formationEntity, new DebugVisualizationComponent());\necb.AddComponent(formationEntity, new FormationConfigComponent { Shape = Shape.Wedge });\n</code></pre> <p>Benefits: - Composition flexibility (add debug/visual components to formations) - Natural identity management (formation auto-destruction cascades to members) - Proper query semantics - Fits ECS paradigm naturally</p> <p>See also: Entity Factory with Archetype, Helper Methods for Component Sets</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#decision-framework-script-vs-system","title":"Decision Framework: Script vs System","text":"<p>When uncertain about logic placement, use this workflow:</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#1-start-with-scripts","title":"1. Start with Scripts","text":"<p>Write unproven logic in MonoBehaviour/scripts first.</p> <pre><code>// Initial prototype\npublic class UnitController : MonoBehaviour\n{\n    void Update()\n    {\n        // Test gameplay logic here\n    }\n}\n</code></pre> <p>Why: Avoids premature architecture decisions, faster iteration.</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#2-extract-data-to-components","title":"2. Extract Data to Components","text":"<p>When multiple scripts/systems need access, move data to components.</p> <pre><code>public struct UnitStatsComponent : IComponentData\n{\n    public float Speed;\n    public float Health;\n}\n</code></pre>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#3-move-logic-to-systems","title":"3. Move Logic to Systems","text":"<p>When reusability becomes evident, migrate processing to systems.</p> <pre><code>partial struct UnitMovementSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (transform, stats) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;UnitStatsComponent&gt;&gt;())\n        {\n            // Shared movement logic\n        }\n    }\n}\n</code></pre>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#4-remove-unused-code","title":"4. Remove Unused Code","text":"<p>Delete obsolete scripts/systems throughout development.</p> <p>Principle: Treat initial architecture as provisional. Optimize for refactorability, not perfect first decisions.</p>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#refactoring-code-smells","title":"Refactoring Code Smells","text":"<p>ECS exhibits similar refactoring needs as OOP but requires different solutions:</p> Code Smell Signal ECS Solution Variable prefixes <code>controlSpeed</code>, <code>platformGravity</code> in same component Separate into focused components Monolithic systems Single system handling many responsibilities Extract logic into separate systems Inflexible filtering Boolean flags to disable features Tag Components or IEnableableComponent (toggleable components) Broad queries System queries many components but uses few Split into focused systems with minimal queries Shared mutable state Multiple components modifying same data Entity-based abstraction or singleton pattern"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#component-design","title":"Component Design","text":"<ul> <li>\u2705 Minimize component dependencies per system query</li> <li>\u2705 Separate data concerns instead of boolean flags</li> <li>\u2705 Use component presence as primary control mechanism</li> <li>\u2705 Prefer containers over multiple instances of same type</li> <li>\u2705 Allow helper methods in components for readonly operations</li> </ul>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#system-architecture","title":"System Architecture","text":"<ul> <li>\u2705 Make system order explicit and testable</li> <li>\u2705 Query minimum number of components needed</li> <li>\u2705 Decompose into focused systems for parallelization</li> <li>\u2705 Defer only when coordination/ordering required</li> <li>\u2705 Use multiple update phases (Fixed/Simulation/Presentation)</li> </ul>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#integration-migration","title":"Integration &amp; Migration","text":"<ul> <li>\u2705 Gradual migration preserves existing logic</li> <li>\u2705 Entity abstractions for complex concepts</li> <li>\u2705 Start with scripts, extract to systems when proven</li> <li>\u2705 Remove unused code continuously</li> </ul>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#related-patterns","title":"Related Patterns","text":"<ul> <li>Request Component Pattern - Command component variation</li> <li>Cleanup Component Pattern - Lifecycle management</li> <li>Tag-Based Behavior Selection - Tag component usage</li> <li>Disable Tag Pattern - Exclusion filtering</li> <li>State Machine Architecture - State management in ECS</li> <li>Auto-Add System Pattern - Component initialization</li> <li>Entity Factory with Archetype - Entity creation optimization</li> </ul>"},{"location":"DOTS/Patterns/ECS%20Design%20Decisions/#further-reading","title":"Further Reading","text":"<p>Source: Design Decisions When Building Games Using ECS by Ariel Coppes</p>"},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/","title":"Entity Factory with Archetype","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#description","title":"Description","text":"<ul> <li> <p>Pre-configured entity spawning pattern using <code>EntityArchetype</code> to define component composition upfront for fast, cache-friendly entity creation</p> </li> <li> <p>Factory struct stores archetype and provides Burst-compiled spawn methods, eliminating repeated component type lookups</p> </li> <li> <p>Enables type-safe entity creation with guaranteed component layout, preventing missing or incorrect components</p> </li> <li> <p>Particularly powerful when combined with EntityCommandBuffer for deferred spawning and conditional component setup</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#example","title":"Example","text":"<pre><code>// Factory stores pre-created archetype\n[BurstCompile]\npublic readonly struct EffectFactory\n{\n    private readonly EntityArchetype _effectArchetype;\n\n    public EffectFactory(EntityManager entityManager)\n    {\n        // Define archetype once at construction\n        _effectArchetype = entityManager.CreateArchetype(\n            ComponentType.ReadWrite&lt;Effect&gt;(),\n            ComponentType.ReadWrite&lt;DestroyEntityFlag&gt;(),\n            ComponentType.ReadWrite&lt;Processed&gt;(),\n            ComponentType.ReadWrite&lt;EffectValue&gt;(),\n            ComponentType.ReadWrite&lt;Producer&gt;(),\n            ComponentType.ReadWrite&lt;Target&gt;());\n    }\n\n    [BurstCompile]\n    public void CreateEffect(EntityCommandBuffer ecb, EffectSetup setup,\n        Entity producer, Entity target)\n    {\n        // Fast creation using pre-cached archetype\n        var effect = ecb.CreateEntity(_effectArchetype);\n\n        // Initialize component values\n        ecb.SetComponent(effect, new EffectValue { Value = setup.Value });\n        ecb.SetComponentEnabled&lt;Processed&gt;(effect, false);\n\n        // Conditionally add type-specific components\n        switch (setup.Type)\n        {\n            case EffectTypeId.Damage:\n                ecb.AddComponent&lt;DamageEffect&gt;(effect);\n                break;\n            case EffectTypeId.Heal:\n                ecb.AddComponent&lt;HealEffect&gt;(effect);\n                break;\n        }\n    }\n}\n\n// Usage in system\n[BurstCompile]\npublic partial struct SpawnSystem : ISystem\n{\n    private EffectFactory _factory;\n\n    public void OnCreate(ref SystemState state)\n    {\n        _factory = new EffectFactory(state.EntityManager);\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        // Use factory to spawn\n        _factory.CreateEffect(ecb, setup, producer, target);\n    }\n}\n</code></pre>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#pros","title":"Pros","text":"<ul> <li> <p>Performance - archetype lookup cached at construction, entity creation is 2-3x faster than repeated <code>CreateEntity(params ComponentType[])</code></p> </li> <li> <p>Burst compatible - readonly struct with no managed references can be Burst compiled for maximum performance</p> </li> <li> <p>Type safety - factory method signatures enforce required parameters, preventing missing components at spawn time</p> </li> <li> <p>Cache-friendly - entities created with same archetype are stored in same Chunk, improving cache locality</p> </li> <li> <p>Centralized logic - all entity creation code in one place, easier to maintain and modify</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#cons","title":"Cons","text":"<ul> <li> <p>Archetype fragmentation - conditional <code>AddComponent</code> in factory creates multiple archetypes, potentially reducing cache efficiency</p> </li> <li> <p>Initialization overhead - must construct factory in <code>OnCreate</code>, adds setup complexity</p> </li> <li> <p>Limited flexibility - archetype defined upfront, can't easily vary component composition per spawn</p> </li> <li> <p>Memory footprint - storing archetype in system state adds small memory cost per factory instance</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#best-use","title":"Best use","text":"<ul> <li> <p>Frequent spawning - projectiles, effects, enemies that spawn hundreds per second benefit from cached archetype</p> </li> <li> <p>Complex entity setup - entities with 5+ components where manual creation is error-prone</p> </li> <li> <p>Type variations - multiple entity types (basic/homing/explosive projectile) that share common components</p> </li> <li> <p>EntityCommandBuffer workflows - factory methods take ECB, perfect for deferred spawning in jobs</p> </li> <li> <p>Guaranteed composition - when entity must have exact component set, factory enforces this at compile time</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Rare spawning - entities created once per level don't benefit from archetype caching overhead</p> </li> <li> <p>Highly variable composition - if every entity needs different components, archetype caching provides no benefit</p> </li> <li> <p>Simple entities - 1-2 component entities are simpler with direct <code>CreateEntity</code> call</p> </li> <li> <p>Authoring-driven - entities created from prefabs in editor should use [[Baker|baking]] workflow, not factories</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Entity%20Factory%20with%20Archetype/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Factory lifetime: Store factory in system state, create once in OnCreate for maximum efficiency</p> </li> <li> <p>Minimize fragmentation: Include optional components in base archetype, use IEnableableComponent instead of AddComponent to avoid creating multiple archetypes</p> </li> <li> <p>Buffer pre-allocation: Set buffer capacity in factory to avoid heap allocation: <code>targets.Capacity = 10</code></p> </li> <li> <p>Parallel jobs: Factories work great with parallel job ECB - capture factory for job, use <code>ecb.AsParallelWriter()</code></p> </li> <li> <p>Naming for debugging: Use <code>ecb.SetName(effect, \"DamageEffect\")</code> for better entity inspector visibility</p> </li> <li> <p>Multiple archetypes: Create specialized factories for different entity categories (ProjectileFactory, EffectFactory, EnemyFactory)</p> </li> <li> <p>Factory parameters: Pass setup data via struct parameter for clean API instead of many method parameters</p> </li> <li> <p>Performance comparison: Factory archetype creation ~0.5ms for 10k entities vs manual ~2ms (4x speedup)</p> </li> <li> <p>Readonly struct: Mark factory readonly for better Burst optimization: <code>public readonly struct Factory</code></p> </li> <li> <p>Testing benefit: Factories make unit tests cleaner by centralizing entity creation logic</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/","title":"Helper Methods for Component Sets","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#description","title":"Description","text":"<ul> <li> <p>Component bundling pattern providing utility functions to add groups of interdependent components in single call</p> </li> <li> <p>Uses <code>FixedList128Bytes&lt;ComponentType&gt;</code> to define component sets, then <code>ComponentTypeSet</code> for efficient batch addition via <code>EntityManager.AddComponent(entity, componentSet)</code></p> </li> <li> <p>Prevents forgetting required supporting components and ensures consistent entity setup across codebase</p> </li> <li> <p>Unity's Entities Graphics uses this - <code>RenderMeshUtility.AddComponents()</code> adds all rendering-related components in one call</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#example","title":"Example","text":"<pre><code>// Helper class with utility methods\npublic static class CharacterUtility\n{\n    public static void AddCharacterComponents(\n        Entity entity,\n        EntityManager em,\n        bool isPlayer = false)\n    {\n        // Build component list\n        var components = new FixedList128Bytes&lt;ComponentType&gt;\n        {\n            ComponentType.ReadWrite&lt;Health&gt;(),\n            ComponentType.ReadWrite&lt;CharacterController&gt;(),\n            ComponentType.ReadWrite&lt;MovementSpeed&gt;(),\n            ComponentType.ReadWrite&lt;LocalTransform&gt;(),\n        };\n\n        // Conditional components\n        if (isPlayer)\n        {\n            components.Add(ComponentType.ReadWrite&lt;PlayerInput&gt;());\n            components.Add(ComponentType.ReadWrite&lt;Inventory&gt;());\n        }\n        else\n        {\n            components.Add(ComponentType.ReadWrite&lt;AIController&gt;());\n        }\n\n        // Add all at once\n        var componentSet = new ComponentTypeSet(components);\n        em.AddComponent(entity, componentSet);\n\n        // Set initial values\n        em.SetComponentData(entity, new Health { Current = 100, Max = 100 });\n        em.SetComponentData(entity, new MovementSpeed { Value = 5f });\n    }\n}\n\n// Usage\nEntity player = entityManager.CreateEntity();\nCharacterUtility.AddCharacterComponents(player, entityManager, isPlayer: true);\n\n// Unity.Entities.Graphics example\npublic static class RenderMeshUtility\n{\n    public static void AddComponents(\n        Entity entity,\n        EntityManager em,\n        RenderMeshDescription desc)\n    {\n        var components = new FixedList128Bytes&lt;ComponentType&gt;\n        {\n            ComponentType.ReadWrite&lt;WorldRenderBounds&gt;(),\n            ComponentType.ReadWrite&lt;LocalToWorld&gt;(),\n            ComponentType.ReadWrite&lt;MaterialMeshInfo&gt;(),\n        };\n\n        // Conditional rendering features\n        if (desc.ShadowCastingMode != ShadowCastingMode.Off)\n            components.Add(ComponentType.ReadWrite&lt;CastShadows&gt;());\n\n        if (desc.LightProbeUsage != LightProbeUsage.Off)\n            components.Add(ComponentType.ReadWrite&lt;LightProbes&gt;());\n\n        em.AddComponent(entity, new ComponentTypeSet(components));\n    }\n}\n</code></pre> <p>Pattern structure: 1. Static utility class with helper methods 2. Method takes entity + parameters 3. Build <code>FixedList128Bytes&lt;ComponentType&gt;</code> 4. Convert to <code>ComponentTypeSet</code> 5. Call <code>AddComponent(entity, componentSet)</code> 6. Set initial component values</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#pros","title":"Pros","text":"<ul> <li> <p>Prevents errors - guarantees all required components added together</p> </li> <li> <p>Consistent setup - all entities created with same helper get same components</p> </li> <li> <p>Centralized logic - change component requirements in one place</p> </li> <li> <p>Performance - batch add faster than multiple individual AddComponent calls</p> </li> <li> <p>Conditional logic - can add different components based on parameters</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#cons","title":"Cons","text":"<ul> <li> <p>Not type-safe - using <code>ComponentType.ReadWrite&lt;T&gt;()</code> loses compile-time type checking</p> </li> <li> <p>Initialization separate - must set initial values separately from adding components</p> </li> <li> <p>Runtime overhead - building FixedList has small cost vs compile-time archetype</p> </li> <li> <p>Limited flexibility - harder to vary component combinations than with archetypes</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#best-use","title":"Best use","text":"<ul> <li> <p>Complex entity types - entities requiring many interdependent components (rendering, physics, AI)</p> </li> <li> <p>Conditional composition - when component set varies based on parameters (player vs enemy)</p> </li> <li> <p>Framework APIs - packages providing entity creation utilities (Unity.Entities.Graphics)</p> </li> <li> <p>Consistency critical - when forgetting a component causes bugs</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Simple entities - 1-2 components easier to add directly</p> </li> <li> <p>Fixed composition - if components never vary, use Reusable Archetype Groups instead</p> </li> <li> <p>Performance critical - creating FixedList adds overhead vs direct archetype creation</p> </li> <li> <p>Type safety required - pattern loses compile-time type checking</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Helper%20Methods%20for%20Component%20Sets/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Unity.Entities.Graphics example: <code>RenderMeshUtility.AddComponents()</code> is production example</p> </li> <li> <p>Combine with archetypes: Can use helper method to add components to entity created from archetype</p> </li> <li> <p>FixedList capacity: <code>FixedList128Bytes</code> holds ~16 ComponentTypes, use <code>FixedList512Bytes</code> for more</p> </li> <li> <p>ECB support: Can use ComponentTypeSet with EntityCommandBuffer:   <pre><code>var components = new ComponentTypeSet(/* ... */);\necb.AddComponent(entity, components);\n</code></pre></p> </li> <li> <p>Naming convention: Suffix utility class with <code>Utility</code> (CharacterUtility, RenderUtility)</p> </li> <li> <p>Initialization pattern: Set component values immediately after adding:   <pre><code>em.AddComponent(entity, componentSet);\nem.SetComponentData(entity, new Health { Max = 100 });\n</code></pre></p> </li> <li> <p>Alternative - extension methods: Can implement as extension methods on EntityManager:   <pre><code>public static void AddCharacterComponents(this EntityManager em, Entity entity) { }\n</code></pre></p> </li> <li> <p>Combining patterns: Use with Auto-Add System Pattern - helper adds base components, system auto-adds supporting ones</p> </li> <li> <p>Testing: Helper methods make tests cleaner by encapsulating entity creation</p> </li> <li> <p>Best practices: Document which components are added and why, include parameter validation, set sensible defaults</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/","title":"Hybrid Entity GameObject Sync","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#description","title":"Description","text":"<ul> <li> <p>Bidirectional lifecycle management pattern synchronizing Entity and GameObject destruction to prevent dangling references in hybrid workflows</p> </li> <li> <p>MonoBehaviour tracks its corresponding Entity and World references, automatically destroying Entity when GameObject is destroyed</p> </li> <li> <p>Prevents \"entity does not exist\" errors in systems that reference GameObjects via managed components</p> </li> <li> <p>Essential for hybrid architectures mixing ECS logic with MonoBehaviour-based systems (UI, animation, legacy code)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#example","title":"Example","text":"<pre><code>// Core MonoBehaviour tracking Entity lifecycle\npublic class EntityGameObject : MonoBehaviour\n{\n    public Entity Entity;\n    public World World;\n\n    public void AssignEntity(Entity e, World world)\n    {\n        Entity = e;\n        World = world;\n    }\n\n    // Bidirectional sync: GameObject destroyed \u2192 destroy Entity\n    private void OnDestroy()\n    {\n        if (World != null &amp;&amp; World.IsCreated &amp;&amp;\n            World.EntityManager.Exists(Entity))\n        {\n            World.EntityManager.DestroyEntity(Entity);\n        }\n    }\n}\n\n// Creating hybrid entity\nvar entity = ecb.CreateEntity();\nvar go = new GameObject(\"HybridEntity\");\nvar tracker = go.AddComponent&lt;EntityGameObject&gt;();\ntracker.AssignEntity(entity, state.World);\n\n// Store GameObject reference in managed component\necb.AddComponent(entity, new GameObjectReference { Value = go });\n\n// System syncing ECS to GameObject\nEntities\n    .WithoutBurst()\n    .ForEach((in LocalTransform transform, in GameObjectReference goRef) =&gt;\n    {\n        if (goRef.Value != null)\n        {\n            goRef.Value.transform.position = transform.Position;\n        }\n    }).Run();\n</code></pre> <p>Lifecycle flow: 1. Create ECS Entity 2. Create GameObject and add EntityGameObject MonoBehaviour 3. Call <code>AssignEntity()</code> to establish link 4. Store GameObject reference in managed component 5. OnDestroy automatically cleans up Entity when GameObject destroyed</p> <p>Validation checks: - Always check <code>World.IsCreated</code> before accessing EntityManager - Always check <code>goRef.Value != null</code> before using GameObject - Always check <code>EntityManager.Exists(entity)</code> before destroying</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#pros","title":"Pros","text":"<ul> <li> <p>Lifecycle consistency - prevents dangling references when GameObject destroyed unexpectedly (scene unload, user deletion)</p> </li> <li> <p>Error prevention - automatic Entity cleanup eliminates \"entity does not exist\" errors in systems</p> </li> <li> <p>Bidirectional safety - handles destruction from either side (GameObject.Destroy or EntityManager.DestroyEntity)</p> </li> <li> <p>Simple API - single AssignEntity call establishes sync, OnDestroy handles cleanup automatically</p> </li> <li> <p>Debugging friendly - clear ownership relationship visible in inspector and hierarchy</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#cons","title":"Cons","text":"<ul> <li> <p>Main thread only - GameObject operations not Burst-compatible, managed components break parallelism</p> </li> <li> <p>Performance overhead - managed components and GameObject references add CPU cost vs pure ECS</p> </li> <li> <p>Memory overhead - GameObject allocation much heavier than pure Entity (KB vs bytes)</p> </li> <li> <p>Complexity - hybrid architecture harder to reason about than pure ECS or pure GameObject</p> </li> <li> <p>World transition issues - requires careful handling when switching worlds or during domain reload</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#best-use","title":"Best use","text":"<ul> <li> <p>UI integration - ECS gameplay logic driving MonoBehaviour UI (health bars, tooltips, menus)</p> </li> <li> <p>Animation systems - ECS controlling Animator/Animation components on GameObjects</p> </li> <li> <p>Legacy code integration - gradual ECS migration while maintaining MonoBehaviour systems</p> </li> <li> <p>Third-party assets - integrating asset store plugins requiring GameObjects with ECS logic</p> </li> <li> <p>Visual debugging - attaching debug GameObjects to ECS entities for scene view visualization</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Pure ECS possible - if gameplay logic can be 100% ECS, avoid GameObject overhead entirely</p> </li> <li> <p>Performance-critical - hybrid sync adds frame cost, pure ECS 10-100x faster for most operations</p> </li> <li> <p>Large entity counts - thousands of hybrid entities create garbage and slow down systems</p> </li> <li> <p>Burst-critical code - managed components prevent Burst compilation, eliminating main ECS performance benefit</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Hybrid%20Entity-GameObject%20Sync/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Null checks essential: Always validate GameObject exists before use - destroyed GameObjects = null reference</p> </li> <li> <p>World validation: Check <code>World.IsCreated</code> before accessing EntityManager to avoid crashes</p> </li> <li> <p>Alternative: CompanionLink: Unity provides built-in <code>CompanionGameObjectSystemGroup</code> for official hybrid support</p> </li> <li> <p>Minimize hybrid entities: Use hybrid only where necessary (visuals, audio), keep logic pure ECS - aim for 10 hybrid vs 1000 pure ECS</p> </li> <li> <p>Cleanup component pattern: Use Cleanup Component Pattern for automatic GameObject destruction when Entity destroyed</p> </li> <li> <p>Pooling for performance: Reuse GameObjects to avoid allocation cost - 1000 spawns/sec: pooling ~5ms/frame vs new ~50ms/frame + GC</p> </li> <li> <p>Presentation layer only: Keep hybrid systems in PresentationSystemGroup, simulation systems pure ECS</p> </li> <li> <p>Entity.Null pattern: Reset Entity reference when pooling/despawning to prevent OnDestroy from destroying invalid entity</p> </li> <li> <p>Domain reload handling: Clear static references on domain reload to avoid errors: <code>[RuntimeInitializeOnLoadMethod]</code></p> </li> <li> <p>Performance comparison: Pure ECS 10,000 entities @ 0.1ms vs Hybrid @ 5ms (50x slower)</p> </li> <li> <p>Memory comparison: Pure ECS entity ~100 bytes vs Hybrid ~5KB (50x larger)</p> </li> <li> <p>Best practices: Hybrid sparingly, validate existence, presentation layer only, pool GameObjects, pure ECS alternatives first</p> </li> <li> <p>Migration strategy: GameObject \u2192 Hybrid Entity (logic in ECS) \u2192 Pure Entity + visual GameObject \u2192 Pure Entity + Entities Graphics</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/ICustomBootstrap/","title":"ICustomBootstrap","text":"","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#description","title":"Description","text":"<ul> <li> <p>Custom world initialization interface that replaces Unity's default world creation - implement Initialize() method to control which worlds are created and which systems are added</p> </li> <li> <p>Overrides default behavior - when ICustomBootstrap implementation exists, Unity calls it instead of creating default world with all systems automatically</p> </li> <li> <p>Full control over worlds - create multiple worlds (client/server, simulation/presentation), choose specific systems, customize system groups and ordering</p> </li> <li> <p>Must return true - Initialize() must return true to indicate custom bootstrap succeeded and prevent default world creation (return false for default behavior)</p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#example","title":"Example","text":"<pre><code>using Unity.Entities;\nusing UnityEngine;\n\n// Basic custom bootstrap - create custom world manually\npublic class MyCustomBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n        // Create custom world\n        var world = new World(\"My Custom World\");\n\n        // Add systems manually\n        var simulationGroup = world.GetOrCreateSystemManaged&lt;SimulationSystemGroup&gt;();\n        var movementSystem = world.GetOrCreateSystemManaged&lt;MovementSystem&gt;();\n        var renderingSystem = world.GetOrCreateSystemManaged&lt;RenderingSystem&gt;();\n\n        // Add systems to system group\n        simulationGroup.AddSystemToUpdateList(movementSystem);\n        simulationGroup.AddSystemToUpdateList(renderingSystem);\n\n        // Sort system update order\n        simulationGroup.SortSystems();\n\n        // Set as default world (used by SceneSystem, etc.)\n        World.DefaultGameObjectInjectionWorld = world;\n\n        // Return true to indicate success (prevents default world creation)\n        return true;\n    }\n}\n\n// Advanced: Creating multiple worlds (client/server)\npublic class ClientServerBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n        // Create server world\n        var serverWorld = new World(\"Server World\", WorldFlags.GameServer);\n\n        // Add server-specific systems\n        var serverSim = serverWorld.GetOrCreateSystemManaged&lt;SimulationSystemGroup&gt;();\n        serverSim.AddSystemToUpdateList(serverWorld.GetOrCreateSystemManaged&lt;ServerGameLogicSystem&gt;());\n        serverSim.AddSystemToUpdateList(serverWorld.GetOrCreateSystemManaged&lt;ServerNetworkSystem&gt;());\n        serverSim.SortSystems();\n\n        // Create client world\n        var clientWorld = new World(\"Client World\", WorldFlags.GameClient);\n\n        // Add client-specific systems\n        var clientSim = clientWorld.GetOrCreateSystemManaged&lt;SimulationSystemGroup&gt;();\n        clientSim.AddSystemToUpdateList(clientWorld.GetOrCreateSystemManaged&lt;ClientInputSystem&gt;());\n        clientSim.AddSystemToUpdateList(clientWorld.GetOrCreateSystemManaged&lt;ClientRenderingSystem&gt;());\n        clientSim.SortSystemsAndUpdateList();\n\n        // Set client as default world\n        World.DefaultGameObjectInjectionWorld = clientWorld;\n\n        return true;\n    }\n}\n\n// Using DefaultWorldInitialization helpers (recommended approach)\npublic class RecommendedBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n        // Create world with default system groups (Initialization, Simulation, Presentation)\n        var world = new World(defaultWorldName);\n\n        // Get all system types from assemblies\n        var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default);\n\n        // Filter systems (example: exclude specific systems)\n        var filteredSystems = new List&lt;Type&gt;();\n        foreach (var system in systems)\n        {\n            // Skip unwanted systems\n            if (system == typeof(UnwantedSystem))\n                continue;\n\n            filteredSystems.Add(system);\n        }\n\n        // Add filtered systems to world\n        DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, filteredSystems);\n\n        // Set as default world\n        World.DefaultGameObjectInjectionWorld = world;\n\n        return true;\n    }\n}\n\n// Conditional worlds based on defines or configuration\npublic class ConditionalBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n#if UNITY_SERVER\n        // Server build: create server world only\n        var world = new World(\"Server World\", WorldFlags.GameServer);\n\n        var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.ServerSimulation);\n        DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n#else\n        // Client build: create client world only\n        var world = new World(\"Client World\", WorldFlags.GameClient);\n\n        var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.ClientSimulation);\n        DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n#endif\n\n        World.DefaultGameObjectInjectionWorld = world;\n        return true;\n    }\n}\n\n// Custom bootstrap with logging and error handling\npublic class RobustBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n        try\n        {\n            Debug.Log($\"Custom bootstrap: Creating world '{defaultWorldName}'\");\n\n            var world = new World(defaultWorldName);\n\n            // Get systems\n            var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default);\n            Debug.Log($\"Found {systems.Count} systems to initialize\");\n\n            // Add systems\n            DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n\n            // Set default world\n            World.DefaultGameObjectInjectionWorld = world;\n\n            Debug.Log(\"Custom bootstrap: Success\");\n            return true;\n        }\n        catch (System.Exception e)\n        {\n            Debug.LogError($\"Custom bootstrap failed: {e.Message}\");\n\n            // Return false to fall back to default world creation\n            return false;\n        }\n    }\n}\n\n// Editor-only custom bootstrap (different behavior in editor vs builds)\npublic class EditorAwareBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n#if UNITY_EDITOR\n        // Editor: Create world with editor-specific systems\n        var world = new World(defaultWorldName);\n\n        var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default | WorldSystemFilterFlags.Editor);\n        DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n\n        Debug.Log(\"[Editor] Custom bootstrap with editor systems\");\n#else\n        // Build: Create optimized world without editor systems\n        var world = new World(defaultWorldName);\n\n        var systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default);\n        DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n#endif\n\n        World.DefaultGameObjectInjectionWorld = world;\n        return true;\n    }\n}\n</code></pre>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#pros","title":"Pros","text":"<ul> <li> <p>Full initialization control - decide exactly which worlds exist and which systems run in each</p> </li> <li> <p>Multiple world support - easily create client/server, simulation/rendering, or other world separation patterns</p> </li> <li> <p>System filtering - exclude specific systems from initialization (testing, optimization, feature flags)</p> </li> <li> <p>Custom execution order - manually control system update order beyond [UpdateBefore]/[UpdateAfter] attributes</p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#cons","title":"Cons","text":"<ul> <li> <p>All or nothing - disables default world creation, must manually create all needed worlds and systems</p> </li> <li> <p>Easy to forget systems - manually adding systems risks missing critical Unity systems (rendering, transforms, etc.)</p> </li> <li> <p>Maintenance burden - custom bootstrap code needs updates when adding new systems or Unity versions change</p> </li> <li> <p>Complexity - harder to debug issues with world initialization compared to default setup</p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#best-use","title":"Best use","text":"<ul> <li> <p>Client/server architecture - separate worlds for client simulation and server simulation</p> </li> <li> <p>Multiple simulation contexts - gameplay world, UI world, background processing world</p> </li> <li> <p>System filtering - exclude specific systems based on platform, configuration, or feature flags</p> </li> <li> <p>Custom world lifetime - worlds that need non-standard creation/destruction timing</p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Default setup sufficient - most projects work fine with Unity's default world creation</p> </li> <li> <p>Simple system ordering - use [UpdateInGroup], [UpdateBefore], [UpdateAfter] attributes instead</p> </li> <li> <p>Prototyping - custom bootstrap adds complexity during early development</p> </li> <li> <p>Single world projects - unnecessary overhead if only one world needed with all systems</p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/ICustomBootstrap/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ICustomBootstrap discovery: <pre><code>// Unity automatically finds ICustomBootstrap implementations\n// Place in any assembly - no registration needed\n// First implementation found is used (only one allowed)\n\npublic class MyBootstrap : ICustomBootstrap\n{\n    public bool Initialize(string defaultWorldName)\n    {\n        // Called automatically at startup\n        return true;\n    }\n}\n</code></pre></p> </li> <li> <p>DefaultWorldInitialization helpers (recommended): <pre><code>// Get all system types from assemblies\nList&lt;Type&gt; systems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default);\n\n// Filter flags\nWorldSystemFilterFlags.Default           // Normal gameplay systems\nWorldSystemFilterFlags.Editor            // Editor-only systems\nWorldSystemFilterFlags.Streaming         // Scene streaming systems\nWorldSystemFilterFlags.ClientSimulation  // Client-side systems\nWorldSystemFilterFlags.ServerSimulation  // Server-side systems\nWorldSystemFilterFlags.ThinClientSimulation  // Thin client systems\n\n// Add systems to world with default groups\nDefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, systems);\n\n// Or create default world entirely\nWorld world = DefaultWorldInitialization.Initialize(defaultWorldName);\n</code></pre></p> </li> <li> <p>World.DefaultGameObjectInjectionWorld: <pre><code>// Set which world GameObject conversion uses\nWorld.DefaultGameObjectInjectionWorld = myWorld;\n\n// Many Unity systems use this world:\n// - SceneSystem loads SubScenes into this world\n// - Baking adds entities to this world\n// - ConvertToEntity uses this world\n</code></pre></p> </li> <li> <p>WorldFlags options: <pre><code>// Game worlds\nnew World(\"Client\", WorldFlags.GameClient)\nnew World(\"Server\", WorldFlags.GameServer)\nnew World(\"Thin Client\", WorldFlags.GameThinClient)\n\n// Editor worlds\nnew World(\"Editor\", WorldFlags.Editor)\n\n// Streaming\nnew World(\"Streaming\", WorldFlags.Streaming)\n\n// Live conversion\nnew World(\"Shadow\", WorldFlags.Shadow)\n\n// No flags (custom world)\nnew World(\"Custom\")\n</code></pre></p> </li> <li> <p>Manually adding systems to groups: <pre><code>var world = new World(\"My World\");\n\n// Get or create system groups\nvar initGroup = world.GetOrCreateSystemManaged&lt;InitializationSystemGroup&gt;();\nvar simGroup = world.GetOrCreateSystemManaged&lt;SimulationSystemGroup&gt;();\nvar presGroup = world.GetOrCreateSystemManaged&lt;PresentationSystemGroup&gt;();\n\n// Create and add systems\nvar mySystem = world.GetOrCreateSystemManaged&lt;MySystem&gt;();\nsimGroup.AddSystemToUpdateList(mySystem);\n\n// Sort systems (respects [UpdateBefore]/[UpdateAfter] attributes)\nsimGroup.SortSystems();\n\n// Or sort all systems in world\nworld.GetOrCreateSystemManaged&lt;SimulationSystemGroup&gt;().SortSystems();\n</code></pre></p> </li> <li> <p>Return value semantics: <pre><code>public bool Initialize(string defaultWorldName)\n{\n    // Return true: Custom bootstrap succeeded, don't create default world\n    return true;\n\n    // Return false: Custom bootstrap failed, create default world as fallback\n    return false;\n}\n</code></pre></p> </li> <li> <p>Disposing worlds: <pre><code>// Worlds don't automatically dispose\n// Manual cleanup needed:\n\nvoid OnApplicationQuit()\n{\n    // Dispose all worlds\n    foreach (var world in World.All)\n    {\n        world.Dispose();\n    }\n}\n\n// Or dispose specific world\nmyWorld.Dispose();\n</code></pre></p> </li> <li> <p>Accessing all worlds: <pre><code>// Iterate all created worlds\nforeach (var world in World.All)\n{\n    Debug.Log($\"World: {world.Name}, Flags: {world.Flags}\");\n}\n\n// Find specific world by name\nforeach (var world in World.All)\n{\n    if (world.Name == \"Server World\")\n    {\n        // Found server world\n    }\n}\n</code></pre></p> </li> <li> <p>System filtering example: <pre><code>public bool Initialize(string defaultWorldName)\n{\n    var world = new World(defaultWorldName);\n\n    // Get all systems\n    var allSystems = DefaultWorldInitialization.GetAllSystems(WorldSystemFilterFlags.Default);\n\n    // Filter out specific systems\n    var filteredSystems = new List&lt;Type&gt;();\n    foreach (var systemType in allSystems)\n    {\n        // Skip systems by type\n        if (systemType == typeof(UnwantedSystem))\n            continue;\n\n        // Skip systems by namespace\n        if (systemType.Namespace?.StartsWith(\"UnityEngine.Rendering\") == true)\n            continue;\n\n        // Skip systems by attribute\n        if (systemType.GetCustomAttribute&lt;DebugOnlyAttribute&gt;() != null)\n            continue;\n\n        filteredSystems.Add(systemType);\n    }\n\n    DefaultWorldInitialization.AddSystemsToRootLevelSystemGroups(world, filteredSystems);\n    World.DefaultGameObjectInjectionWorld = world;\n\n    return true;\n}\n</code></pre></p> </li> <li> <p>Script execution order: <pre><code>// ICustomBootstrap.Initialize() called very early:\n// 1. Assemblies loaded\n// 2. ICustomBootstrap.Initialize() called\n// 3. Worlds created (either custom or default)\n// 4. Systems initialized\n// 5. MonoBehaviour Awake() called\n// 6. First system updates\n\n// Can access worlds in MonoBehaviour.Awake():\nvoid Awake()\n{\n    var world = World.DefaultGameObjectInjectionWorld;\n    // World already exists\n}\n</code></pre></p> </li> <li> <p>Common gotchas: <pre><code>// WRONG: Forgetting to set DefaultGameObjectInjectionWorld\npublic bool Initialize(string defaultWorldName)\n{\n    var world = new World(defaultWorldName);\n    // ... add systems ...\n    return true;  // Missing: World.DefaultGameObjectInjectionWorld = world;\n}\n// Result: SubScene loading, baking, etc. won't work\n\n// WRONG: Forgetting to sort systems\nsimGroup.AddSystemToUpdateList(mySystem);\n// Missing: simGroup.SortSystems();\n// Result: Systems run in random order, [UpdateBefore] ignored\n\n// WRONG: Multiple ICustomBootstrap implementations\n// Only one ICustomBootstrap allowed per project\n// Unity uses first one found (undefined which one)\n</code></pre></p> </li> <li> <p>Testing with custom bootstrap: <pre><code>// Option 1: Disable in tests\n#if !UNITY_TESTS\npublic class MyBootstrap : ICustomBootstrap { ... }\n#endif\n\n// Option 2: Conditional return\npublic bool Initialize(string defaultWorldName)\n{\n    #if UNITY_TESTS\n    return false;  // Use default in tests\n    #else\n    // Custom initialization\n    return true;\n    #endif\n}\n\n// Option 3: Manual world setup in tests\n[Test]\npublic void MyTest()\n{\n    var world = new World(\"Test World\");\n    // Add only systems needed for test\n    // Dispose after test\n}\n</code></pre></p> </li> </ul>","tags":["pattern","advanced","initialization"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/","title":"IEnableableComponent Flow Control","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#description","title":"Description","text":"<ul> <li> <p>Zero-cost state management pattern using IEnableableComponent to control system execution flow without Structural changes</p> </li> <li> <p>Enables/disables components to gate systems and orchestrate multi-system workflows, eliminating need for bool flags</p> </li> <li> <p>Unlike traditional component add/remove (which triggers structural changes), enable/disable is a fast, Cache-friendly bit flag operation</p> </li> <li> <p>Common use cases: cooldown timers, permission gates (CanShoot), readiness flags (ReadyToCollectTargets), request flow control (BossStateChangeRequest)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#example","title":"Example","text":"<pre><code>// Permission gate - control when entity can perform action\npublic struct CanShoot : IComponentData, IEnableableComponent { }\n\n// Cooldown with data\npublic struct Cooldown : IComponentData, IEnableableComponent\n{\n    public float TimeToNextShoot;\n    public float ShootRate;\n}\n\n// Readiness flag - coordinate multi-system workflows\npublic struct ReadyToCollectTargets : IComponentData, IEnableableComponent { }\n\n// Request flow control\npublic struct BossStateChangeRequest : IComponentData, IEnableableComponent { }\n\n// Query only enabled components\nSystemAPI.Query&lt;RefRO&lt;Weapon&gt;&gt;()\n    .WithAll&lt;CanShoot&gt;()  // Only entities with CanShoot enabled\n\n// Query only disabled components\nSystemAPI.Query&lt;RefRW&lt;Cooldown&gt;&gt;()\n    .WithDisabled&lt;CanShoot&gt;()\n\n// Toggle without structural changes\nSystemAPI.SetComponentEnabled&lt;CanShoot&gt;(entity, false);\necb.SetComponentEnabled&lt;ReadyToCollectTargets&gt;(entity, true);\n</code></pre>","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#pros","title":"Pros","text":"<ul> <li> <p>No Structural changes - enable/disable is instant bit flag operation, doesn't trigger archetype changes or Sync points</p> </li> <li> <p>Cache-friendly queries - systems only iterate enabled components, skipping disabled entities improves cache utilization</p> </li> <li> <p>Clean flow control - enables declarative system gating (WithAll/WithDisabled) vs imperative bool checks in loops</p> </li> <li> <p>Query optimization - RequireMatchingQueriesForUpdate with enableable components prevents system execution when no work needed</p> </li> <li> <p>Composition friendly - can combine multiple enableable components for complex flow control (e.g., CanShoot + ReadyToFire)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#cons","title":"Cons","text":"<ul> <li> <p>Limited to existing entities - can't use to dynamically add/remove components, entity must already have the component in its Archetype</p> </li> <li> <p>Authoring overhead - must pre-add all potentially needed IEnableableComponents during entity creation, even if initially disabled</p> </li> <li> <p>Memory always allocated - disabled components still occupy memory in Chunk, unlike removed components</p> </li> <li> <p>Debugging visibility - enabled/disabled state not as visible in Entity Inspector compared to component presence/absence</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#best-use","title":"Best use","text":"<ul> <li> <p>Cooldown systems - disable CanShoot during cooldown, re-enable when ready (avoids structural changes every shot)</p> </li> <li> <p>Multi-stage workflows - enable ReadyToCollect flag to signal between interval system and collection system</p> </li> <li> <p>State machine control - enable StateChangeRequest to coordinate transition evaluation and action execution systems</p> </li> <li> <p>Processed tracking - disable Processed flag for new entities, enable after processing (cleaner than destroy-on-process)</p> </li> <li> <p>Permission gates - CanMove, CanShoot, CanJump tags that systems check with WithAll()","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Need to change Archetype - if component truly needs to be added/removed (not just toggled), use structural changes with EntityCommandBuffer</p> </li> <li> <p>One-time initialization - if component is set once and never toggled, regular IComponentData is simpler</p> </li> <li> <p>Very large components - since disabled components still occupy chunk memory, large data structures waste space when disabled (use Request Component Pattern instead)</p> </li> <li> <p>Entity lifetime management - for entities that should be destroyed after processing, use DestroyEntity instead of Processed flag</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/IEnableableComponent%20Flow%20Control/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Query syntax: Use <code>.WithAll&lt;CanShoot&gt;()</code> for enabled, <code>.WithDisabled&lt;CanShoot&gt;()</code> for disabled, <code>.WithPresent&lt;CanShoot&gt;()</code> for both</p> </li> <li> <p>Query optimization: Use <code>[RequireMatchingQueriesForUpdate]</code> to skip system when no enabled components exist</p> </li> <li> <p>Default state: Components are enabled by default, disable explicitly if needed: <code>entityManager.SetComponentEnabled&lt;Cooldown&gt;(entity, false)</code></p> </li> <li> <p>ECB support: Can enable/disable via ECB for deferred execution: <code>ecb.SetComponentEnabled&lt;CanShoot&gt;(entity, false)</code></p> </li> <li> <p>Authoring pattern: Pre-add enableable components in Baker even if initially disabled, then control enabled state</p> </li> <li> <p>Performance: IEnableableComponent toggle ~100x faster than add/remove component (no structural change)</p> </li> <li> <p>State machines: Combine multiple enableable flags for exclusive states - enable only one at a time</p> </li> <li> <p>Alternative to Request Component Pattern: For frequent toggling operations, use IEnableableComponent instead of add/remove</p> </li> <li> <p>Common pattern: Interval system sets ReadyToCollect flag, collection system processes and clears flag - clean coordination without structural changes</p> </li> <li> <p>Combining patterns: Works well with Cleanup Component Pattern to detect when enableable component changes state</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/","title":"NativeParallelMultiHashMap for Entity Collections","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#description","title":"Description","text":"<ul> <li> <p>Collection storage pattern using <code>NativeParallelMultiHashMap&lt;TKey, TValue&gt;</code> to store one-to-many relationships between entities, most commonly parent-to-children mappings</p> </li> <li> <p>Allows multiple values (children) per key (parent) with efficient parallel-safe access, perfect for hierarchies and groupings</p> </li> <li> <p>Standard iteration uses <code>TryGetFirstValue()</code> followed by <code>do-while</code> loop with <code>TryGetNextValue()</code> to iterate all values for key</p> </li> <li> <p>Thread-safe parallel writes and reads make it ideal for jobs building or querying entity relationships</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#example","title":"Example","text":"<pre><code>// Build parent-to-children mapping\n[BurstCompile]\npublic partial struct BuildParentChildMapJob : IJobEntity\n{\n    public NativeParallelMultiHashMap&lt;Entity, Entity&gt;.ParallelWriter ChildMap;\n\n    public void Execute(Entity entity, in Parent parent)\n    {\n        ChildMap.Add(parent.Value, entity);\n    }\n}\n\n[BurstCompile]\npublic partial struct ParentChildSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Create map with estimated capacity\n        var childMap = new NativeParallelMultiHashMap&lt;Entity, Entity&gt;(\n            100,  // Estimated capacity\n            Allocator.TempJob);\n\n        // Build map in parallel\n        new BuildParentChildMapJob\n        {\n            ChildMap = childMap.AsParallelWriter()\n        }.ScheduleParallel();\n\n        state.Dependency.Complete();\n\n        // Iterate all children for each parent\n        foreach (var parentEntity in\n            SystemAPI.QueryBuilder().WithAll&lt;Parent&gt;().Build().ToEntityArray(Allocator.Temp))\n        {\n            // Check if parent has children\n            if (childMap.TryGetFirstValue(parentEntity, out Entity child, out var iterator))\n            {\n                ProcessChild(child);\n\n                // Iterate remaining children\n                while (childMap.TryGetNextValue(out child, ref iterator))\n                {\n                    ProcessChild(child);\n                }\n            }\n        }\n\n        childMap.Dispose();\n    }\n}\n</code></pre> <p>Standard iteration pattern: <pre><code>if (map.TryGetFirstValue(key, out TValue value, out var iterator))\n{\n    // Process first value\n    DoSomething(value);\n\n    // Process remaining values\n    while (map.TryGetNextValue(out value, ref iterator))\n    {\n        DoSomething(value);\n    }\n}\n</code></pre></p> <p>Common use cases: - Parent-to-children entity mappings - Group entities by type/category - Spatial partitioning (grid cell \u2192 entities) - Tag-based collections (faction \u2192 members)</p>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#pros","title":"Pros","text":"<ul> <li> <p>Thread-safe - parallel reads and writes via <code>ParallelWriter</code></p> </li> <li> <p>Multiple values per key - perfect for one-to-many relationships</p> </li> <li> <p>Job compatible - works in Burst-compiled jobs</p> </li> <li> <p>Dynamic sizing - grows automatically as values added</p> </li> <li> <p>Fast lookups - O(1) average case for key lookup</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#cons","title":"Cons","text":"<ul> <li> <p>Unordered - no guarantee on value iteration order</p> </li> <li> <p>Memory overhead - hash table structure adds memory cost</p> </li> <li> <p>Must dispose - manual memory management required</p> </li> <li> <p>Duplicates allowed - can add same value multiple times for same key</p> </li> <li> <p>No value removal - can only clear entire map, not individual values</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#best-use","title":"Best use","text":"<ul> <li> <p>Parent-child hierarchies - building temporary parent\u2192children maps</p> </li> <li> <p>Entity grouping - group entities by type, faction, or category</p> </li> <li> <p>Spatial queries - map grid cells to entities for proximity queries</p> </li> <li> <p>Relationship tracking - any one-to-many entity relationships</p> </li> <li> <p>Parallel collection - when multiple jobs need to build collection simultaneously</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Ordered iteration needed - use NativeList or DynamicBuffer instead</p> </li> <li> <p>Single value per key - use <code>NativeHashMap&lt;TKey, TValue&gt;</code> instead</p> </li> <li> <p>Persistent storage - multimap is temporary, use buffers for persistent relationships</p> </li> <li> <p>Value removal needed - can't remove individual values, only clear all</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/NativeParallelMultiHashMap%20for%20Entity%20Collections/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Capacity estimation: Pre-allocate with estimated size to avoid reallocation: <code>new NativeParallelMultiHashMap&lt;K, V&gt;(estimatedSize, Allocator)</code></p> </li> <li> <p>Count values per key: Use <code>CountValuesForKey(key)</code> to check how many values before iterating</p> </li> <li> <p>Parallel writer: Call <code>.AsParallelWriter()</code> for thread-safe adds in parallel jobs</p> </li> <li> <p>Disposal: Always dispose in same system that creates it, or use try-finally</p> </li> <li> <p>Alternative - buffers: For persistent relationships, use DynamicBuffer on parent entity instead</p> </li> <li> <p>Duplicate prevention: Check <code>ContainsKey</code> before adding to avoid duplicates:   <pre><code>if (!map.ContainsKey(key))\n    map.Add(key, value);\n</code></pre></p> </li> <li> <p>Empty check: Use <code>IsEmpty</code> or <code>Count()</code> to check if map has any entries</p> </li> <li> <p>Allocator choice: Use <code>Allocator.TempJob</code> for jobs, <code>Allocator.Temp</code> for single-frame main thread</p> </li> <li> <p>Performance tip: Pre-size map capacity to avoid dynamic growth overhead</p> </li> <li> <p>Combining patterns: Use with ComponentLookup and BufferLookup to efficiently process grouped entities</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/","title":"Request Component Pattern","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#description","title":"Description","text":"<ul> <li> <p>Reversible operation pattern where adding request Component triggers work, removing it reverses the operation - allows repeatable on/off control</p> </li> <li> <p>Request components persist on entities and can be added/removed multiple times, unlike one-time request entities</p> </li> <li> <p>Unity's <code>Unity.Scenes</code> uses <code>RequestSceneLoaded</code> - adding loads scene, removing unloads</p> </li> <li> <p>Enables declarative control: \"this entity should have scene loaded\" vs imperative \"load this scene now\"</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#example","title":"Example","text":"<pre><code>// Request component\npublic struct RequestSceneLoaded : IComponentData\n{\n    public Hash128 SceneGUID;\n}\n\n// State tracking component\npublic struct SceneLoaded : IComponentData { }\n\n// System processes requests\n[BurstCompile]\npublic partial struct ProcessSceneLoadRequestSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Load when request added\n        foreach (var (request, entity) in\n            SystemAPI.Query&lt;RefRO&lt;RequestSceneLoaded&gt;&gt;()\n                .WithNone&lt;SceneLoaded&gt;()\n                .WithEntityAccess())\n        {\n            LoadScene(request.ValueRO.SceneGUID);\n            state.EntityManager.AddComponent&lt;SceneLoaded&gt;(entity);\n        }\n\n        // Unload when request removed\n        foreach (var (loaded, entity) in\n            SystemAPI.Query&lt;RefRO&lt;SceneLoaded&gt;&gt;()\n                .WithNone&lt;RequestSceneLoaded&gt;()  // Request removed\n                .WithEntityAccess())\n        {\n            UnloadScene(loaded.ValueRO.SceneGUID);\n            state.EntityManager.RemoveComponent&lt;SceneLoaded&gt;(entity);\n        }\n    }\n}\n\n// Usage\nentityManager.AddComponent(entity, new RequestSceneLoaded { SceneGUID = guid });  // Load\nentityManager.RemoveComponent&lt;RequestSceneLoaded&gt;(entity);  // Unload\n</code></pre> <p>Pattern structure: 1. Request component - added by user code 2. State component - added by system when operation completes 3. Two queries - <code>.WithAll&lt;Request&gt;().WithNone&lt;State&gt;()</code> for new requests, <code>.WithAll&lt;State&gt;().WithNone&lt;Request&gt;()</code> for removal</p> <p>Common use cases: - Scene loading/unloading - Network connect/disconnect - Resource load/unload - Audio play/stop - Subscriptions - Rendering enable/disable</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#pros","title":"Pros","text":"<ul> <li> <p>Reversible operations - easily undo by removing request component, natural on/off control</p> </li> <li> <p>Declarative state - presence of component declares desired state, system makes it happen</p> </li> <li> <p>Repeatable - can add/remove request multiple times for repeated operations</p> </li> <li> <p>Clean API - simple add/remove component API vs complex state machine</p> </li> <li> <p>Testable - easy to test by adding/removing component and verifying state changes</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#cons","title":"Cons","text":"<ul> <li> <p>Structural changes - adding/removing components expensive if frequent</p> </li> <li> <p>Requires state tracking - need additional component to track operation completion</p> </li> <li> <p>One-frame delay - system processes request on next update, not immediately</p> </li> <li> <p>Cleanup complexity - must handle cleanup when request removed</p> </li> <li> <p>Can be forgotten - developers might add request but forget to remove, causing resource leaks</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#best-use","title":"Best use","text":"<ul> <li> <p>Scene loading/unloading - Unity.Scenes canonical example</p> </li> <li> <p>Network connections - connect when requested, disconnect when removed</p> </li> <li> <p>Resource loading - load assets when needed, unload when no longer requested</p> </li> <li> <p>Audio playback - start audio on request, stop when removed</p> </li> <li> <p>Subscriptions - subscribe to data feeds, unsubscribe when removed</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>One-time operations - for fire-and-forget, use request entities destroyed after processing</p> </li> <li> <p>Frequent toggling - if toggling every frame, IEnableableComponent avoids structural changes</p> </li> <li> <p>Immediate execution needed - request pattern has one-frame delay</p> </li> <li> <p>Complex state machines - if operation has many states beyond on/off, use proper state machine</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Request%20Component%20Pattern/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Pair with state component: Use separate component for state (Loading, Loaded, Failed) beyond just presence/absence</p> </li> <li> <p>Unity.Scenes example: <code>RequestSceneLoaded</code> is real component from Unity packages - check source</p> </li> <li> <p>Cleanup pattern integration: Combine with Cleanup Component Pattern to detect removal via cleanup components</p> </li> <li> <p>Async operations: Request pattern works well for async - add request, add \"in progress\" component, poll completion, remove request to cleanup</p> </li> <li> <p>Multiple requests: Can have multiple request types on same entity simultaneously</p> </li> <li> <p>Request parameters: Include operation parameters in request component struct</p> </li> <li> <p>Reference counting: For shared resources, track reference count - only unload when count reaches 0</p> </li> <li> <p>Disable without removing: Combine with Disable Tag Pattern - <code>.WithAll&lt;Request&gt;().WithNone&lt;DisableProcessing&gt;()</code></p> </li> <li> <p>ECB usage: Always use EntityCommandBuffer for structural changes in request systems</p> </li> <li> <p>Performance tip: Use <code>[RequireMatchingQueriesForUpdate]</code> to skip system when no requests</p> </li> <li> <p>IEnableableComponent alternative: For frequent toggling, use IEnableableComponent to avoid structural changes:   <pre><code>public struct RequestRendering : IComponentData, IEnableableComponent { }\nSystemAPI.SetComponentEnabled&lt;RequestRendering&gt;(entity, true);  // No structural change\n</code></pre></p> </li> <li> <p>Naming conventions: Prefix with <code>Request</code>, suffix state with <code>State</code>/<code>Active</code>/<code>InProgress</code>/<code>Loaded</code></p> </li> <li> <p>Documentation critical: Clearly document what happens when request added vs removed</p> </li> <li> <p>Testing both paths: Test request addition and removal in unit tests</p> </li> <li> <p>Request vs request entities:</p> </li> <li>Request components: Persist on entity, reversible, repeatable</li> <li> <p>Request entities: Destroyed after processing, one-time, fire-and-forget</p> </li> <li> <p>Architectural context: See ECS Design Decisions for command component pattern and when to choose request patterns vs immediate execution</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/","title":"Reusable Archetype Groups","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#description","title":"Description","text":"<ul> <li> <p>Archetype caching pattern defining reusable component combinations in struct, allowing multiple systems to reference same archetype definitions</p> </li> <li> <p>Implemented as static helper returning archetype collections, centralizing archetype definitions in one location</p> </li> <li> <p>Useful when multiple systems create entities with same component combinations or query similar archetypes</p> </li> <li> <p>Unity's <code>Unity.Scenes</code> uses this with <code>CreateResolveSceneSectionArchetypes()</code> to share definitions across scene loading systems</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#example","title":"Example","text":"<pre><code>// Define reusable archetype group\npublic struct SceneArchetypes\n{\n    public EntityArchetype ResolvedSection;\n    public EntityArchetype RequestLoaded;\n    public EntityArchetype MetaData;\n\n    public static SceneArchetypes Create(EntityManager em)\n    {\n        return new SceneArchetypes\n        {\n            ResolvedSection = em.CreateArchetype(\n                ComponentType.ReadWrite&lt;SceneSectionData&gt;(),\n                ComponentType.ReadWrite&lt;LinkedEntityGroup&gt;()),\n\n            RequestLoaded = em.CreateArchetype(\n                ComponentType.ReadWrite&lt;RequestSceneLoaded&gt;(),\n                ComponentType.ReadWrite&lt;SceneReference&gt;()),\n\n            MetaData = em.CreateArchetype(\n                ComponentType.ReadWrite&lt;SceneMetaData&gt;())\n        };\n    }\n}\n\n// Usage in systems\n[BurstCompile]\npublic partial struct SceneLoadingSystem : ISystem\n{\n    private SceneArchetypes _archetypes;\n\n    public void OnCreate(ref SystemState state)\n    {\n        _archetypes = SceneArchetypes.Create(state.EntityManager);\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        // Reuse archetype for entity creation\n        Entity scene = state.EntityManager.CreateEntity(_archetypes.RequestLoaded);\n    }\n}\n</code></pre> <p>Pattern structure: 1. Define struct with <code>EntityArchetype</code> fields 2. Static <code>Create()</code> method builds all archetypes 3. Systems call <code>Create()</code> in <code>OnCreate()</code>, store in field 4. Use stored archetypes for entity creation</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#pros","title":"Pros","text":"<ul> <li> <p>No duplication - archetype definitions centralized, avoiding copy-paste errors</p> </li> <li> <p>Performance - archetypes created once and reused, avoiding repeated lookup</p> </li> <li> <p>Consistency - guarantees all systems use same component combinations</p> </li> <li> <p>Maintainability - change archetype in one place, all systems automatically updated</p> </li> <li> <p>Type safety - named fields prevent using wrong archetype</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#cons","title":"Cons","text":"<ul> <li> <p>Memory overhead - each system stores archetype references</p> </li> <li> <p>Initialization requirement - must call <code>Create()</code> in OnCreate</p> </li> <li> <p>Not dynamic - archetype definitions static, can't vary at runtime</p> </li> <li> <p>Overhead for simple cases - overkill for 1-2 archetypes used once</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#best-use","title":"Best use","text":"<ul> <li> <p>Shared entity types - multiple systems create same entity types (scenes, projectiles, effects)</p> </li> <li> <p>Complex archetypes - entities with many components where duplication error-prone</p> </li> <li> <p>Framework systems - packages providing reusable systems (like Unity.Scenes)</p> </li> <li> <p>Large projects - consistency important across many systems</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Single use - archetype only used in one system, no need to share</p> </li> <li> <p>Simple archetypes - 1-2 components easier to define inline</p> </li> <li> <p>Dynamic archetypes - if composition varies at runtime, pattern doesn't fit</p> </li> <li> <p>Small projects - overhead not justified for few systems</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Reusable%20Archetype%20Groups/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Unity.Scenes example: Check Unity.Scenes package source for production implementation</p> </li> <li> <p>ComponentTypeSet alternative: Can return <code>ComponentTypeSet</code> instead of <code>EntityArchetype</code> for more flexibility</p> </li> <li> <p>Combine with factories: Use with Entity Factory with Archetype pattern for complete entity creation encapsulation</p> </li> <li> <p>Partial application: Can define some archetypes in struct, others inline in systems</p> </li> <li> <p>Naming convention: Suffix struct with <code>Archetypes</code> for clarity (SceneArchetypes, CharacterArchetypes)</p> </li> <li> <p>Capacity hint: When creating archetypes, can provide initial capacity hint for buffers</p> </li> <li> <p>Burst compatibility: Archetype references are Burst-compatible, entire pattern works in Burst</p> </li> <li> <p>Testing: In tests, can create archetypes struct to ensure test entities match production</p> </li> <li> <p>Documentation: Document each archetype field's purpose and when to use</p> </li> <li> <p>Incremental adoption: Can start with most commonly duplicated archetypes, add others gradually</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/","title":"Singleton entities and components","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#description","title":"Description","text":"<ul> <li> <p>Single instance pattern for components or entities existing exactly once in world, accessed globally across systems</p> </li> <li> <p>Accessed via <code>SystemAPI.GetSingleton&lt;T&gt;()</code> (read-only) or <code>SystemAPI.GetSingletonRW&lt;T&gt;()</code> (read-write), throws error if zero or multiple instances</p> </li> <li> <p>Systems use <code>state.RequireForUpdate&lt;T&gt;()</code> in OnCreate to ensure system only runs when singleton exists</p> </li> <li> <p>Common for game state, configuration, physics world, EntityCommandBuffer systems, and global resources</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#example","title":"Example","text":"<pre><code>// Define singleton component\npublic struct GameConfig : IComponentData\n{\n    public int MaxEnemies;\n    public float SpawnRate;\n}\n\n// Create singleton entity\n[BurstCompile]\npublic partial struct GameInitSystem : ISystem\n{\n    public void OnCreate(ref SystemState state)\n    {\n        Entity configEntity = state.EntityManager.CreateEntity();\n        state.EntityManager.AddComponentData(configEntity, new GameConfig\n        {\n            MaxEnemies = 100,\n            SpawnRate = 2.0f\n        });\n    }\n}\n\n// Read singleton\n[BurstCompile]\npublic partial struct EnemySpawnSystem : ISystem\n{\n    public void OnCreate(ref SystemState state)\n    {\n        state.RequireForUpdate&lt;GameConfig&gt;();  // System won't run without singleton\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        GameConfig config = SystemAPI.GetSingleton&lt;GameConfig&gt;();  // Read-only\n        // Use config.MaxEnemies...\n    }\n}\n\n// Modify singleton\n[BurstCompile]\npublic partial struct GameStateSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        RefRW&lt;GameConfig&gt; config = SystemAPI.GetSingletonRW&lt;GameConfig&gt;();  // Read-write\n        config.ValueRW.MaxEnemies = 150;\n    }\n}\n\n// EntityCommandBuffer singleton pattern\nvar ecb = SystemAPI.GetSingleton&lt;BeginSimulationEntityCommandBufferSystem.Singleton&gt;()\n    .CreateCommandBuffer(state.WorldUnmanaged);\n</code></pre> <p>Common singletons: - Game state (score, level, time) - Configuration (difficulty, settings) - Physics world (<code>PhysicsWorldSingleton</code>) - ECB systems (<code>BeginSimulationEntityCommandBufferSystem.Singleton</code>) - Input state - Random seed</p>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#pros","title":"Pros","text":"<ul> <li> <p>Global access - any system can access singleton data without passing references</p> </li> <li> <p>Type-safe - compile-time error if component type wrong</p> </li> <li> <p>Performance - direct component access, no lookup overhead</p> </li> <li> <p>Clear intent - <code>GetSingleton</code> clearly communicates single instance requirement</p> </li> <li> <p>Automatic validation - runtime error if multiple instances exist</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#cons","title":"Cons","text":"<ul> <li> <p>Runtime error - throws if zero or multiple instances, no compile-time check</p> </li> <li> <p>Hidden dependencies - systems using singletons have implicit dependencies</p> </li> <li> <p>Testing complexity - tests must create singleton entities</p> </li> <li> <p>Shared mutable state - multiple systems modifying singleton can cause race conditions</p> </li> <li> <p>Not Job compatible - can't access singletons directly in jobs, must capture in job struct</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#best-use","title":"Best use","text":"<ul> <li> <p>Game configuration - settings, difficulty, constants that rarely change</p> </li> <li> <p>Game state - score, level, time, global counters</p> </li> <li> <p>Physics/input - Unity-provided singletons for physics world, input</p> </li> <li> <p>ECB systems - accessing EntityCommandBuffer system singletons</p> </li> <li> <p>Random seed - single random seed for deterministic gameplay</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Multiple instances - if might need multiple, use regular components</p> </li> <li> <p>Per-entity data - if data belongs to specific entity, not global</p> </li> <li> <p>Frequent creation/destruction - singleton should exist for entire session</p> </li> <li> <p>Job parallelism - if need to access in parallel jobs, use ComponentLookup instead</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Singleton%20entities%20and%20components/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>RequireForUpdate: Always use to prevent null reference when singleton doesn't exist yet</p> </li> <li> <p>Singleton entity: Use <code>EntityQuery.GetSingletonEntity()</code> to get entity holding singleton component</p> </li> <li> <p>ECB pattern: Access ECB via singleton for consistent timing:   <pre><code>var ecb = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;()\n    .CreateCommandBuffer(state.WorldUnmanaged);\n</code></pre></p> </li> <li> <p>HasSingleton: Check existence with <code>SystemAPI.HasSingleton&lt;T&gt;()</code> before accessing</p> </li> <li> <p>Multiple worlds: Each World has separate singletons - useful for client/server separation</p> </li> <li> <p>Burst compatibility: <code>GetSingleton&lt;T&gt;()</code> works in Burst, but ECB singleton requires <code>.CreateCommandBuffer()</code></p> </li> <li> <p>SubScene creation: Can create singleton in SubScene for designer-friendly configuration</p> </li> <li> <p>Naming convention: Suffix singleton components with <code>Config</code>, <code>State</code>, or <code>Singleton</code> for clarity</p> </li> <li> <p>Testing: Create singleton in test setup:   <pre><code>[SetUp]\npublic void Setup()\n{\n    var entity = entityManager.CreateEntity();\n    entityManager.AddComponentData(entity, new GameConfig { /* ... */ });\n}\n</code></pre></p> </li> <li> <p>Alternative - static: For truly global data, static variables simpler than singletons</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/","title":"State Machine Architecture","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#description","title":"Description","text":"<ul> <li> <p>Data-driven state machine pattern combining buffers, managed components, and registry pattern for complex AI behavior without enum-based state machines</p> </li> <li> <p>Separates state transition logic (condition evaluation) from state action execution (multi-frame operations) into distinct systems for clean separation of concerns</p> </li> <li> <p>Uses Condition Evaluators (registry pattern) for pluggable condition types and Action Executors (managed components) for multi-frame actions</p> </li> <li> <p>Supports multiple transition modes: Sequential (cycle through states), ConditionalRandom (weighted selection from valid states)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#example","title":"Example","text":"<pre><code>// State components\npublic struct BossCurrentState : IComponentData\n{\n    public int Value;  // Current state index\n}\n\npublic struct BossConfig : IComponentData\n{\n    public BossTransitionMode TransitionMode;  // Sequential or ConditionalRandom\n}\n\n// State definitions in buffers\n[InternalBufferCapacity(5)]\npublic struct BossStateSetup : IBufferElementData\n{\n    public float Weight;  // For weighted random selection\n}\n\n// Condition definitions\n[InternalBufferCapacity(10)]\npublic struct BossStateConditionSetup : IBufferElementData\n{\n    public BossConditionType Type;      // DistanceToPlayer, BossHealth\n    public BossConditionEvaluationType EvalType;  // Greater, Less, Equal\n    public float Parameter;\n    public int StateIndex;\n}\n\n// Flow control between systems\npublic struct BossStateChangeRequest : IComponentData, IEnableableComponent { }\n\n// Condition evaluator registry\npublic interface IBossConditionEvaluator\n{\n    bool Evaluate(ref BossSensorData sensorData,\n        BossConditionEvaluationType evalType, float parameter);\n}\n\npublic static class BossConditionRegistry\n{\n    private static readonly IBossConditionEvaluator[] _evaluators = new IBossConditionEvaluator[3];\n\n    static BossConditionRegistry()\n    {\n        _evaluators[(int)BossConditionType.DistanceToPlayer] = new PlayerDistanceEvaluator();\n        _evaluators[(int)BossConditionType.BossHealth] = new HealthConditionEvaluator();\n    }\n}\n\n// Action executor for multi-frame operations\n[System.Serializable]\npublic abstract class IBossActionExecutor\n{\n    public bool Completed { get; set; }\n    public abstract void Execute(Entity bossEntity, float deltaTime, ref BossSensorData sensorData);\n}\n\n// Example: Delay action takes multiple frames\npublic class DelayActionExecutor : IBossActionExecutor\n{\n    private float _duration;\n    private float _timeElapsed;\n\n    public override void Execute(Entity bossEntity, float deltaTime, ref BossSensorData sensorData)\n    {\n        _timeElapsed += deltaTime;\n        if (_timeElapsed &gt;= _duration)\n            Completed = true;\n    }\n}\n\n// Managed component stores executors\npublic class BossStateExecutors : IComponentData\n{\n    public List&lt;List&lt;IBossActionExecutor&gt;&gt; States = new();\n}\n</code></pre> <p>System Flow: 1. Sensor systems collect data (player distance, health) into <code>BossSensorData</code> 2. Action system executes current state actions until complete, then enables <code>BossStateChangeRequest</code> 3. Transition system evaluates conditions, selects next state, disables <code>BossStateChangeRequest</code></p>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#pros","title":"Pros","text":"<ul> <li> <p>Data-driven flexibility - states, conditions, and transitions configured via buffers, not hardcoded</p> </li> <li> <p>Extensible architecture - add new condition types by implementing interface and registering in registry, no system changes needed</p> </li> <li> <p>Multi-frame actions - managed component executors can span multiple frames (delays, animations, complex sequences)</p> </li> <li> <p>Clean separation - transition logic isolated from action execution, each system has single responsibility</p> </li> <li> <p>Weighted randomness - ConditionalRandom mode supports weighted state selection for varied AI behavior</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#cons","title":"Cons","text":"<ul> <li> <p>Managed components - BossStateExecutors uses managed List, breaks Burst compatibility and adds GC pressure</p> </li> <li> <p>Complexity - requires understanding of registry pattern, managed components, and multi-system coordination</p> </li> <li> <p>Structural changes - adding conditions via buffers can trigger structural changes if buffer exceeds [[InternalBufferCapacity]]</p> </li> <li> <p>Debugging difficulty - state machine flow spread across multiple systems, conditions, and executors harder to trace</p> </li> <li> <p>Memory overhead - buffers, managed components, and evaluator registry consume more memory than simple enum state machine</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#best-use","title":"Best use","text":"<ul> <li> <p>Complex boss AI - multi-phase bosses with conditional state transitions based on health, distance, or other metrics</p> </li> <li> <p>Dynamic behavior trees - configurable AI behavior that changes based on runtime conditions without code changes</p> </li> <li> <p>Data-driven game design - designers can configure states and conditions in editor without programmer intervention</p> </li> <li> <p>Multi-frame sequences - actions that span multiple frames (play animation, wait, spawn enemies, repeat)</p> </li> <li> <p>Pluggable systems - registry pattern allows adding new condition/action types without modifying existing systems</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Simple state machines - 2-3 states with straightforward transitions better served by enum + switch statement</p> </li> <li> <p>Burst-critical code - managed components prevent Burst compilation, use unmanaged alternatives for performance-critical AI</p> </li> <li> <p>Memory-constrained - buffers and managed components add significant overhead vs simple state enum</p> </li> <li> <p>Single-frame actions - if all actions complete in one frame, complexity not justified (use Tag-Based Behavior Selection instead)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/State%20Machine%20Architecture/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Sensor data pattern: Collect all required data (player position, health) in separate sensor systems before transition system runs</p> </li> <li> <p>IEnableableComponent for flow control: Use BossStateChangeRequest to coordinate between transition and action systems without structural changes</p> </li> <li> <p>Buffer capacity hints: Set <code>[InternalBufferCapacity(5)]</code> for states, <code>[InternalBufferCapacity(10)]</code> for conditions to avoid heap allocation</p> </li> <li> <p>Registry pattern performance: Static array lookup by enum index is O(1), faster than Dictionary</p> </li> <li> <p>Managed component alternatives: For Burst compatibility, use NativeList or blob assets instead of managed List</p> </li> <li> <p>Transition modes: Sequential cycles through states in order, ConditionalRandom picks from valid states based on weights</p> </li> <li> <p>Condition logic: Current implementation uses AND (all conditions must be met), can change to OR (any condition met)</p> </li> <li> <p>State cooldowns: Prevent rapid state changes by adding cooldown component after transition</p> </li> <li> <p>Debugging: Add logging to track state transitions: <code>Debug.Log($\"Boss: {currentState} -&gt; {nextState}\")</code></p> </li> <li> <p>Authoring workflow: Create MonoBehaviour authoring with ScriptableObject configs, bake into buffers</p> </li> <li> <p>Burst alternatives: For performance-critical AI, use Tag-Based Behavior Selection with IEnableableComponent states instead of managed components</p> </li> <li> <p>Combining patterns: Can integrate with Entity Factory with Archetype to spawn entities from action executors</p> </li> <li> <p>Visualization: Create Unity Editor custom inspector to visualize state graph with conditions for designers</p> </li> <li> <p>Immediate vs deferred transitions: See ECS Design Decisions for guidance on when to execute state changes immediately vs deferring to systems</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/","title":"SystemAPI.Query","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#description","title":"Description","text":"<ul> <li> <p>Main iteration pattern for accessing entities and components in ISystem OnUpdate methods</p> </li> <li> <p>Provides foreach-compatible query results with RefRO/RefRW component access, entity access, and query builder methods</p> </li> <li> <p>Type-safe and ergonomic - components specified as generic parameters, automatically generates underlying EntityQuery</p> </li> <li> <p>Supports filtering with <code>.WithAll&lt;T&gt;()</code>, <code>.WithNone&lt;T&gt;()</code>, <code>.WithAny&lt;T&gt;()</code>, and entity access with <code>.WithEntityAccess()</code></p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#example","title":"Example","text":"<pre><code>// Basic query - RefRW for read-write, RefRO for read-only\n[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        float dt = SystemAPI.Time.DeltaTime;\n\n        foreach (var (health, regen) in\n            SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;HealthRegen&gt;&gt;())\n        {\n            health.ValueRW.Current += regen.ValueRO.PointPerSec * dt;\n        }\n    }\n}\n\n// Query with filters\nforeach (var (transform, velocity) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;()\n        .WithAll&lt;Active&gt;()      // Only entities with Active\n        .WithNone&lt;Frozen&gt;())    // Exclude Frozen\n{\n    transform.ValueRW.Position += velocity.ValueRO.Value * dt;\n}\n\n// Query with entity access\nforeach (var (health, entity) in\n    SystemAPI.Query&lt;RefRO&lt;Health&gt;&gt;()\n        .WithEntityAccess())  // Adds Entity to tuple\n{\n    if (health.ValueRO.Current &lt;= 0)\n        ecb.DestroyEntity(entity);\n}\n\n// Query with aspect\nforeach (var projectile in SystemAPI.Query&lt;ProjectileAspect&gt;())\n{\n    projectile.Move(deltaTime);\n}\n\n// Query with DynamicBuffer\nforeach (var (transform, waypoints, pathIndex) in\n    SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, DynamicBuffer&lt;Waypoint&gt;, RefRW&lt;PathIndex&gt;&gt;())\n{\n    // Access waypoints buffer...\n}\n\n// Multiple filters\nforeach (var (health, damage) in\n    SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;Damage&gt;&gt;()\n        .WithAll&lt;Enemy&gt;()           // Has Enemy\n        .WithNone&lt;Dead, Invincible&gt;()  // Not Dead or Invincible\n        .WithAny&lt;Burning, Poisoned&gt;()) // Has Burning or Poisoned\n{\n    // Process...\n}\n\n// Change filter\nforeach (var (health, healthBar) in\n    SystemAPI.Query&lt;RefRO&lt;Health&gt;, HealthBarUI&gt;()\n        .WithChangeFilter&lt;Health&gt;())  // Only when Health changed\n{\n    healthBar.UpdateBar(health.ValueRO.Current);\n}\n</code></pre> <p>Query syntax: - <code>RefRW&lt;T&gt;</code> - read-write component access - <code>RefRO&lt;T&gt;</code> - read-only component access - <code>DynamicBuffer&lt;T&gt;</code> - buffer access - <code>IAspect</code> - aspect access - <code>.WithEntityAccess()</code> - adds Entity to tuple - <code>.WithAll&lt;T&gt;()</code> - require component - <code>.WithNone&lt;T&gt;()</code> - exclude component - <code>.WithAny&lt;T&gt;()</code> - require any of components - <code>.WithChangeFilter&lt;T&gt;()</code> - only changed</p>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#pros","title":"Pros","text":"<ul> <li> <p>Ergonomic - clean foreach syntax, no boilerplate</p> </li> <li> <p>Type-safe - components as generic parameters, compile-time checked</p> </li> <li> <p>Fast - generates efficient EntityQuery, Burst compatible</p> </li> <li> <p>Automatic dependencies - registers component access for System Dependencies</p> </li> <li> <p>Flexible - supports components, buffers, aspects, entity access</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#cons","title":"Cons","text":"<ul> <li> <p>Creates query each call - not cached, overhead for hot paths</p> </li> <li> <p>Limited to foreach - can't use LINQ or other patterns</p> </li> <li> <p>No manual batching - less control than IJobChunk</p> </li> <li> <p>Tuple limit - max ~7-8 components in query (compiler limit)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#best-use","title":"Best use","text":"<ul> <li> <p>Standard iteration - most common system pattern</p> </li> <li> <p>Prototype/development - quick iteration without boilerplate</p> </li> <li> <p>Simple systems - straightforward component processing</p> </li> <li> <p>Component updates - reading/writing component data</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Hot paths - cache EntityQuery manually for performance-critical loops</p> </li> <li> <p>Complex iteration - if need manual batching, use IJobChunk</p> </li> <li> <p>Many components - if querying 8+ components, restructure or use aspects</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI.Query/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Cache for performance: For hot paths, cache query manually:   <pre><code>private EntityQuery _query;\npublic void OnCreate(ref SystemState state)\n{\n    _query = SystemAPI.QueryBuilder().WithAll&lt;Health&gt;().Build();\n}\n</code></pre></p> </li> <li> <p>Tuple deconstruction: Can use <code>var (a, b)</code> or explicit types <code>(RefRW&lt;Health&gt; health, Entity entity)</code></p> </li> <li> <p>Managed components: Use managed component types directly (not RefRW/RefRO):   <pre><code>SystemAPI.Query&lt;Transform, ManagedData&gt;()\n</code></pre></p> </li> <li> <p>Options parameter: Advanced options like <code>EntityQueryOptions.FilterWriteGroup</code></p> </li> <li> <p>Combining filters: Multiple <code>.WithAll()</code> calls are AND logic</p> </li> <li> <p>WithAny vs WithAll: <code>WithAny&lt;A, B&gt;()</code> = has A OR B, <code>WithAll&lt;A, B&gt;()</code> = has A AND B</p> </li> <li> <p>Order matters: Filter order doesn't affect results, but entity access must be last in tuple</p> </li> <li> <p>Best practices: Use RefRO for read-only, RefRW for write; cache queries for hot paths; use aspects for related components</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/SystemAPI/","title":"SystemAPI","text":"","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#description","title":"Description","text":"<ul> <li> <p>Convenience API with static methods covering functionality from World, EntityManager, and SystemState - unified interface for common ECS operations</p> </li> <li> <p>Source-generated - methods work in ISystem and IJobEntity through compile-time code generation for optimal performance</p> </li> <li> <p>Preferred entry point - check SystemAPI first before EntityManager or SystemState for most operations</p> </li> <li> <p>Automatic dependency tracking - methods automatically register component access for dependency management</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct MovementSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Time access\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        // Query iteration\n        foreach (var (transform, velocity) in\n            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;Velocity&gt;&gt;())\n        {\n            transform.ValueRW.Position += velocity.ValueRO.Value * deltaTime;\n        }\n\n        // Singleton access\n        var config = SystemAPI.GetSingleton&lt;GameConfig&gt;();\n        SystemAPI.SetSingleton(new GameConfig { Speed = 10f });\n\n        if (SystemAPI.HasSingleton&lt;PlayerInput&gt;())\n        {\n            Entity entity = SystemAPI.GetSingletonEntity&lt;GameConfig&gt;();\n        }\n\n        // Component lookup\n        var healthLookup = SystemAPI.GetComponentLookup&lt;Health&gt;(isReadOnly: true);\n\n        // Buffer lookup\n        var waypointLookup = SystemAPI.GetBufferLookup&lt;Waypoint&gt;(isReadOnly: false);\n\n        // Query builder\n        var query = SystemAPI.QueryBuilder()\n            .WithAll&lt;Health&gt;()\n            .WithNone&lt;Dead&gt;()\n            .Build();\n    }\n}\n</code></pre> <p>Common methods: - <code>SystemAPI.Time.DeltaTime</code> - frame delta time - <code>SystemAPI.Query&lt;T&gt;()</code> - iterate entities - <code>SystemAPI.GetSingleton&lt;T&gt;()</code> - read singleton - <code>SystemAPI.GetSingletonRW&lt;T&gt;()</code> - write singleton - <code>SystemAPI.GetComponentLookup&lt;T&gt;()</code> - random access - <code>SystemAPI.QueryBuilder()</code> - build custom queries</p>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#pros","title":"Pros","text":"<ul> <li> <p>Unified API - same methods work in systems and jobs, easy code sharing</p> </li> <li> <p>Auto dependency tracking - automatically registers component access</p> </li> <li> <p>Cleaner code - reduces boilerplate vs manual SystemState/EntityManager</p> </li> <li> <p>Type-safe - compile-time checking through source generation</p> </li> <li> <p>Consistent - uniform API across different contexts</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#cons","title":"Cons","text":"<ul> <li> <p>Limited contexts - doesn't work in IJobChunk, must use ComponentTypeHandle</p> </li> <li> <p>Source generation requirement - relies on compile-time codegen, IDE issues possible</p> </li> <li> <p>Less explicit - hides underlying mechanisms vs direct EntityManager</p> </li> <li> <p>Learning curve - need to learn which methods available</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#best-use","title":"Best use","text":"<ul> <li> <p>ISystem implementations - primary API for OnUpdate methods</p> </li> <li> <p>IJobEntity jobs - consistent API between systems and jobs</p> </li> <li> <p>Quick prototyping - fast iteration without boilerplate</p> </li> <li> <p>Standard operations - queries, singletons, lookups</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>IJobChunk - SystemAPI not available, use ComponentTypeHandle</p> </li> <li> <p>Need explicit control - if need fine-grained EntityManager control</p> </li> <li> <p>Source gen issues - if IDE/build having code generation problems</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/SystemAPI/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Works in jobs: SystemAPI methods work identically in IJobEntity jobs</p> </li> <li> <p>Dependency tracking: SystemAPI automatically adds dependencies, EntityManager doesn't</p> </li> <li> <p>Fallback to state: If SystemAPI doesn't have method, use <code>ref SystemState state</code> parameter</p> </li> <li> <p>Burst compatible: All SystemAPI methods Burst-compatible</p> </li> <li> <p>Query caching: SystemAPI.Query creates new query each call, cache manually for hot paths</p> </li> <li> <p>Time access: <code>SystemAPI.Time</code> provides DeltaTime, ElapsedTime, frameCount</p> </li> <li> <p>Best practices: Prefer SystemAPI over EntityManager for standard operations, use EntityManager for advanced scenarios</p> </li> </ul>","tags":["pattern","system"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/","title":"Tag Based Behavior Selection","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#description","title":"Description","text":"<ul> <li> <p>Component-based polymorphism pattern using separate component types for each behavior instead of enum-based behavior selection</p> </li> <li> <p>Systems query specific behavior components directly (e.g., <code>Query&lt;WanderBehavior&gt;()</code>) enabling Cache-friendly iteration and automatic Archetype separation</p> </li> <li> <p>Each behavior type stores its own state data inline, eliminating need for generic \"AI state\" component with union/switch logic</p> </li> <li> <p>Enables composition of behaviors on same entity (e.g., entity can have both ChasePlayerBehavior and AttackBehavior simultaneously)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#example","title":"Example","text":"<pre><code>// \u274c BAD: Enum-based behavior (traditional approach)\npublic enum AIBehaviorType { Idle, Wander, ChasePlayer, Patrol }\n\npublic struct AIBehavior : IComponentData\n{\n    public AIBehaviorType Type;\n    // Union of all possible state data - wasteful\n    public float3 WanderDirection;\n    public float StopDistance;\n    public int CurrentWaypointIndex;\n}\n\n// System must switch for every entity\nforeach (var behavior in SystemAPI.Query&lt;RefRW&lt;AIBehavior&gt;&gt;())\n{\n    switch (behavior.ValueRO.Type)\n    {\n        case AIBehaviorType.Wander: /* ... */ break;\n        case AIBehaviorType.ChasePlayer: /* ... */ break;\n    }\n}\n\n// \u2705 GOOD: Tag-based behavior (ECS approach)\npublic struct WanderBehavior : IComponentData\n{\n    public float3 Direction;\n    public float TimeUntilDirectionChange;\n    public float DirectionChangeInterval;\n}\n\npublic struct ChasePlayerBehavior : IComponentData\n{\n    public float StopDistance;\n}\n\npublic struct PatrolBehavior : IComponentData\n{\n    public int CurrentWaypointIndex;\n    public bool Loop;\n}\n\n// Separate systems for each behavior - clean, cache-friendly\n[BurstCompile]\npublic partial struct WanderBehaviorSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // Only iterates entities with WanderBehavior\n        foreach (var wander in SystemAPI.Query&lt;RefRW&lt;WanderBehavior&gt;&gt;())\n        {\n            // Wander logic...\n        }\n    }\n}\n\n// Behavior transitions - add/remove components\necb.RemoveComponent&lt;WanderBehavior&gt;(entity);\necb.AddComponent(entity, new ChasePlayerBehavior { StopDistance = 2f });\n\n// Composite behaviors - multiple on same entity\n// Entity can have ChasePlayerBehavior + AttackBehavior simultaneously\n\n// Combining with IEnableableComponent for efficient toggling\npublic struct WanderBehavior : IComponentData, IEnableableComponent { /* ... */ }\npublic struct ChasePlayerBehavior : IComponentData, IEnableableComponent { /* ... */ }\n\n// Pre-add all behaviors, toggle enabled state (no structural changes)\nSystemAPI.SetComponentEnabled&lt;WanderBehavior&gt;(entity, false);\nSystemAPI.SetComponentEnabled&lt;ChasePlayerBehavior&gt;(entity, true);\n</code></pre>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#pros","title":"Pros","text":"<ul> <li> <p>Cache-friendly - entities with same behavior stored together in Chunk, better cache locality than enum switch</p> </li> <li> <p>Burst friendly - no switch statements or polymorphism, each system processes single behavior type</p> </li> <li> <p>Type safety - compiler catches missing behavior data at compile time, impossible to forget required state</p> </li> <li> <p>Composable - entities can have multiple behaviors simultaneously (Chase + Attack + Defensive)</p> </li> <li> <p>Query optimization - systems only iterate relevant entities, <code>Query&lt;WanderBehavior&gt;()</code> skips all non-wanderers</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#cons","title":"Cons","text":"<ul> <li> <p>Structural changes - behavior transitions require add/remove components, triggering structural changes</p> </li> <li> <p>Archetype fragmentation - each behavior combination creates new archetype, can reduce cache efficiency</p> </li> <li> <p>More code - separate system per behavior vs single switch statement (though more maintainable)</p> </li> <li> <p>Transition complexity - managing behavior changes requires EntityCommandBuffer and careful state initialization</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#best-use","title":"Best use","text":"<ul> <li> <p>Distinct AI behaviors - enemies with clearly separate behaviors (patrol, chase, flee, attack)</p> </li> <li> <p>Composable systems - behaviors that can combine (Chase + Attack, Patrol + Defensive)</p> </li> <li> <p>Performance-critical AI - hundreds/thousands of entities benefit from cache locality and Burst compilation</p> </li> <li> <p>Data-driven design - behaviors configured per-entity in authoring, not hardcoded state machines</p> </li> <li> <p>Infrequent transitions - behavior changes happen rarely (enter combat, exit combat) so structural change cost acceptable</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Frequent behavior changes - switching every frame causes expensive structural changes (use IEnableableComponent instead)</p> </li> <li> <p>Simple state machine - 2-3 states with simple transitions better served by enum + switch</p> </li> <li> <p>Highly dynamic behavior - if entity behavior changes based on many runtime conditions, State Machine Architecture may be cleaner</p> </li> <li> <p>Memory-constrained - separate components per behavior use more memory than single enum component</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/Tag-Based%20Behavior%20Selection/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Shared behavior data: Use AIAgent component for properties shared across all behaviors (DetectionRange, MoveSpeed)</p> </li> <li> <p>Combine with IEnableableComponent: Pre-add all behaviors in authoring, toggle enabled state to avoid structural changes on frequent transitions</p> </li> <li> <p>Behavior priority: Use system execution order to control behavior precedence with <code>[UpdateBefore]</code>/<code>[UpdateAfter]</code></p> </li> <li> <p>Cleanup on transition: Reset behavior state when transitioning - initialize new behavior with proper starting values</p> </li> <li> <p>Behavior categories: Use zero-size tags for grouping (AggressiveBehavior, PassiveBehavior) to query all aggressive enemies</p> </li> <li> <p>Disable Tag Pattern: Use StunnedTag with <code>.WithNone&lt;StunnedTag&gt;()</code> to temporarily suppress all AI behaviors</p> </li> <li> <p>Hybrid approach: Combine tags for major behaviors with enums for minor variations (ChasePlayerBehavior with ChaseMode enum)</p> </li> <li> <p>Performance comparison: Tag-based ~1.2ms for 10k entities vs enum-based ~3.5ms (cache misses, branch prediction failures)</p> </li> <li> <p>Naming convention: Suffix behavior components with \"Behavior\" for clarity (WanderBehavior, ChasePlayerBehavior)</p> </li> <li> <p>Testing: Behaviors easier to test in isolation without other AI complexity</p> </li> <li> <p>Alternative to State Machine Architecture: For simple AI, tag-based behaviors cleaner than full state machine</p> </li> <li> <p>Archetype optimization: Minimize behavior combinations to reduce archetype count (3 behaviors = 3 archetypes good, 8 combinations = 8 archetypes bad)</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/","title":"WithChangeFilter (reactive updates)","text":"","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#description","title":"Description","text":"<ul> <li> <p>Change detection pattern filtering queries to only include entities where specific components changed since last query execution</p> </li> <li> <p>Applied via <code>.WithChangeFilter&lt;T&gt;()</code> on SystemAPI.Query or <code>EntityQuery.SetChangedVersionFilter()</code> for reactive systems processing only modified data</p> </li> <li> <p>Unity tracks change versions per Chunk - when component data written via <code>.ValueRW</code>, <code>RefRW&lt;T&gt;</code>, or <code>EntityManager.SetComponentData</code>, chunk version increments</p> </li> <li> <p>Massive performance optimization for UI, synchronization, or expensive operations needing to run only on data changes</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#example","title":"Example","text":"<pre><code>// Health bar UI - only update when health changes\npublic partial struct DisplayLifeSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        // WithChangeFilter ensures this only runs for changed Health\n        foreach (var (health, healthBar) in\n            SystemAPI.Query&lt;RefRO&lt;Health&gt;, HealthBarController&gt;()\n                .WithChangeFilter&lt;Health&gt;())  // Only when Health changed\n        {\n            healthBar.UpdateHealthBar(health.ValueRO.Current, health.ValueRO.Max);\n        }\n    }\n}\n\n// Multiple change filters - triggers if ANY component changed\n[BurstCompile]\npublic partial struct SyncTransformSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        foreach (var (transform, prevPos) in\n            SystemAPI.Query&lt;RefRO&lt;LocalTransform&gt;, RefRW&lt;PreviousPosition&gt;&gt;()\n                .WithChangeFilter&lt;LocalTransform&gt;())\n        {\n            prevPos.ValueRW.Value = transform.ValueRO.Position;\n        }\n    }\n}\n\n// Manual EntityQuery with change filter\n[BurstCompile]\npublic partial struct SpawnSystem : ISystem\n{\n    private EntityQuery _query;\n\n    public void OnCreate(ref SystemState state)\n    {\n        _query = SystemAPI.QueryBuilder()\n            .WithAll&lt;SpawnPoint, Active&gt;()\n            .Build();\n        _query.SetChangedVersionFilter(typeof(SpawnPoint));\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        // Only processes entities with changed SpawnPoint\n        foreach (var spawnPoint in _query.ToComponentDataArray&lt;SpawnPoint&gt;(Allocator.Temp))\n        {\n            // Expensive spawning logic only when spawn points change\n        }\n    }\n}\n</code></pre> <p>How it works: - Each chunk stores change version number - Writing to component increments chunk's version - Change filter compares chunk version to last query execution - Only chunks with newer version are processed</p>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#pros","title":"Pros","text":"<ul> <li> <p>Massive performance gains - skip processing unchanged data, can be 10-100x faster for reactive systems</p> </li> <li> <p>Simple API - single <code>.WithChangeFilter&lt;T&gt;()</code> call enables optimization</p> </li> <li> <p>Chunk-level tracking - efficient granularity, not per-entity overhead</p> </li> <li> <p>Multiple filters - can combine multiple change filters, triggers if ANY changed</p> </li> <li> <p>Automatic - no manual tracking required, Unity handles version management</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#cons","title":"Cons","text":"<ul> <li> <p>Chunk-level granularity - if one entity in chunk changes, entire chunk reprocessed</p> </li> <li> <p>Write-only detection - reading component doesn't mark as changed, only writes</p> </li> <li> <p>Not immediate - changes tracked per-chunk, not per-entity</p> </li> <li> <p>Version overflow - after ~4 billion changes, versions wrap (extremely rare in practice)</p> </li> <li> <p>Combining filters - multiple filters use OR logic, can't specify AND requirement</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#best-use","title":"Best use","text":"<ul> <li> <p>UI updates - health bars, nameplates, minimaps only update when values change</p> </li> <li> <p>Synchronization - network sync, physics sync only when transforms/velocities change</p> </li> <li> <p>Expensive operations - pathfinding recalculation, LOD updates only when needed</p> </li> <li> <p>Event systems - damage events, state changes that trigger reactions</p> </li> <li> <p>Optimization - any system where most entities don't change most frames</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Always process all - if system must run on all entities every frame, change filter adds overhead</p> </li> <li> <p>Frequent changes - if component changes every frame, filter provides no benefit</p> </li> <li> <p>Need per-entity detection - change filter is chunk-level, not entity-level</p> </li> <li> <p>Complex change logic - if need to detect specific field changes, manual tracking clearer</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Patterns/WithChangeFilter%20%28reactive%20updates%29/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Read vs write: Only writing marks changed - reading via <code>RefRO</code> doesn't increment version</p> </li> <li> <p>Multiple filters OR logic: <code>.WithChangeFilter&lt;A&gt;().WithChangeFilter&lt;B&gt;()</code> triggers if A or B changed</p> </li> <li> <p>Combining with other filters: Can combine with <code>.WithAll</code>, <code>.WithNone</code>, etc</p> </li> <li> <p>Manual version comparison: Can check versions manually with <code>EntityQuery.CalculateChunkCount()</code> and chunk iteration</p> </li> <li> <p>Testing: Create entities, modify component, verify system processes them</p> </li> <li> <p>Performance measurement: Profile system with/without change filter to quantify benefit</p> </li> <li> <p>False positives: If any entity in chunk changes, all entities in that chunk reprocessed</p> </li> <li> <p>Structural changes reset: Adding/removing components resets change versions</p> </li> <li> <p>Burst compatible: Change filters work in Burst-compiled systems</p> </li> <li> <p>Best practices: Use for UI, sync, expensive operations; don't use for every-frame processing</p> </li> </ul>","tags":["pattern"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/","title":"ComponentLookup and BufferLookup","text":"","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#description","title":"Description","text":"<ul> <li> <p>Random access containers providing access to component/buffer data of arbitrary entities, similar to dictionary lookup by Entity ID</p> </li> <li> <p><code>ComponentLookup&lt;T&gt;</code> provides random access to IComponentData, <code>BufferLookup&lt;T&gt;</code> provides random access to DynamicBuffer</p> </li> <li> <p>Created in <code>OnCreate</code> with <code>SystemAPI.GetComponentLookup&lt;T&gt;(isReadOnly)</code> and must be updated with <code>lookup.Update(ref state)</code> before each use</p> </li> <li> <p>Involves random memory access so less performant than sequential iteration with SystemAPI.Query or IJobEntity, but necessary for entity references and relationships</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct ProjectileMoveSystem : ISystem\n{\n    // Store lookup as system field\n    private ComponentLookup&lt;LocalToWorld&gt; _positions;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Create read-only lookup (true = read-only)\n        _positions = SystemAPI.GetComponentLookup&lt;LocalToWorld&gt;(true);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // CRITICAL: Update before use - entity storage may have moved\n        _positions.Update(ref state);\n\n        new ProjectileMoveJob()\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime,\n            Positions = _positions\n        }.ScheduleParallel();\n    }\n\n    public partial struct ProjectileMoveJob : IJobEntity\n    {\n        public float DeltaTime;\n        [ReadOnly] public ComponentLookup&lt;LocalToWorld&gt; Positions;\n\n        private void Execute(ref LocalTransform transform, in Target target)\n        {\n            // Check if target entity still has the component\n            if (Positions.HasComponent(target.Entity))\n            {\n                // Random access to target's position\n                float3 targetPos = Positions[target.Entity].Position;\n                transform.Position = math.lerp(transform.Position, targetPos, DeltaTime);\n            }\n        }\n    }\n}\n\n// BufferLookup example\n[BurstCompile]\npublic partial struct EnemyCollisionSystem : ISystem\n{\n    BufferLookup&lt;Waypoints&gt; _waypointLookup;\n    ComponentLookup&lt;Player&gt; _playerLookup;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Read-only buffer lookup\n        _waypointLookup = SystemAPI.GetBufferLookup&lt;Waypoints&gt;(true);\n        // Read-write component lookup (false = read-write)\n        _playerLookup = SystemAPI.GetComponentLookup&lt;Player&gt;(false);\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        _waypointLookup.Update(ref state);\n        _playerLookup.Update(ref state);\n\n        foreach (var (triggerEvent) in SystemAPI.Query&lt;TriggerEvent&gt;())\n        {\n            // Check which entity has which component\n            if (_playerLookup.HasComponent(triggerEvent.EntityA) &amp;&amp;\n                _waypointLookup.HasBuffer(triggerEvent.EntityB))\n            {\n                // Read-write access to player data\n                Player player = _playerLookup[triggerEvent.EntityA];\n                player.LifeCount -= 1;\n                _playerLookup[triggerEvent.EntityA] = player;\n\n                // Read-only access to waypoints\n                DynamicBuffer&lt;Waypoints&gt; waypoints = _waypointLookup[triggerEvent.EntityB];\n                // ... use waypoints data\n            }\n        }\n    }\n}\n</code></pre>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#pros","title":"Pros","text":"<ul> <li> <p>Random entity access - can access any entity's component data by Entity reference</p> </li> <li> <p>Burst compatible - works in Burst-compiled jobs unlike managed lookups</p> </li> <li> <p>Entity relationships - enables parent-child, target, or other entity reference patterns</p> </li> <li> <p>Thread-safe with [ReadOnly] - read-only lookups can be used safely in parallel jobs</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#cons","title":"Cons","text":"<ul> <li> <p>Poor cache performance - random access causes Cache miss, much slower than sequential iteration</p> </li> <li> <p>Must update before use - forgetting <code>lookup.Update(ref state)</code> causes stale data or crashes</p> </li> <li> <p>Less efficient than queries - if you can use SystemAPI.Query or IJobEntity instead, do so for better performance</p> </li> <li> <p>No safety for write - read-write lookups can't be used in parallel jobs without careful synchronization</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#best-use","title":"Best use","text":"<ul> <li> <p>Entity references - following target entity, parent-child relationships, linked entities</p> </li> <li> <p>Physics jobs - ITriggerEventsJob provides entity pairs, must use lookups to access their components</p> </li> <li> <p>Cross-archetype relationships - when entities in different archetypes need to communicate</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Sequential iteration - if processing all entities with component T, use SystemAPI.Query or IJobEntity for better performance</p> </li> <li> <p>Same-chunk access - if accessing components on same entity being processed, use direct component access</p> </li> <li> <p>No entity references - if you don't have Entity IDs to look up, you don't need lookups</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ComponentLookup%20and%20BufferLookup/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Always update - call <code>lookup.Update(ref state)</code> at start of every <code>OnUpdate</code> before scheduling jobs - entity data locations can change between frames</p> </li> <li> <p>Read-only flag - pass <code>true</code> for read-only access (<code>GetComponentLookup&lt;T&gt;(true)</code>), <code>false</code> for read-write (<code>GetComponentLookup&lt;T&gt;(false)</code>)</p> </li> <li> <p>[ReadOnly] attribute - mark read-only lookups in jobs with <code>[ReadOnly]</code> attribute for parallel job safety and documentation</p> </li> <li> <p>HasComponent/HasBuffer checks - always check <code>lookup.HasComponent(entity)</code> before accessing to avoid errors when entity doesn't have component</p> </li> <li> <p>TryGetComponent pattern - use <code>lookup.TryGetComponent(entity, out T component)</code> for safe access that returns bool instead of throwing</p> </li> <li> <p>TryGetRefRW / TryGetRefRO (Unity Entities 6.5+) - safer alternative to deprecated <code>GetRefRWOptional</code>/<code>GetRefROOptional</code>:   <pre><code>// Old (deprecated):\nvar healthRef = lookup.GetRefRWOptional(entity);\nif (healthRef.IsValid)\n    healthRef.ValueRW.Current = 100;\n\n// New (recommended):\nif (lookup.TryGetRefRW(entity, out RefRW&lt;Health&gt; healthRef))\n    healthRef.ValueRW.Current = 100;\n</code></pre></p> </li> <li> <p>IsComponentEnabled - for enableable components, check <code>lookup.IsComponentEnabled(entity)</code> to see if component is enabled</p> </li> <li> <p>SetComponentEnabled - for enableable components, use <code>lookup.SetComponentEnabled(entity, true/false)</code> to toggle without Structural changes</p> </li> <li> <p>Performance consideration - lookups are ~10-100x slower than sequential iteration due to random memory access, use sparingly</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/","title":"EntityCommandBuffer","text":"","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#description","title":"Description","text":"<ul> <li> <p>Deferred command recording system that queues Structural changes (create entity, add/remove components, destroy entity) for later playback on main thread</p> </li> <li> <p>Necessary because Structural changes cannot happen during job execution - ECB records commands during parallel jobs, plays back on main thread at specific Sync points</p> </li> <li> <p>Multiple ECB system types available (BeginInitialization, BeginSimulation, EndSimulation, etc.) that control when commands are played back</p> </li> <li> <p>Supports ParallelWriter for thread-safe command recording across parallel jobs with deterministic playback ordering</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct SpawnerSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Get ECB singleton - commands play back at beginning of simulation\n        var ecbSingleton = SystemAPI.GetSingleton&lt;BeginSimulationEntityCommandBufferSystem.Singleton&gt;();\n        EntityCommandBuffer ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);\n\n        foreach (var spawner in SystemAPI.Query&lt;RefRW&lt;SpawnerData&gt;&gt;())\n        {\n            spawner.ValueRW.Timer -= SystemAPI.Time.DeltaTime;\n\n            if (spawner.ValueRO.Timer &lt;= 0)\n            {\n                // Queue entity creation - executes later\n                Entity newEntity = ecb.Instantiate(spawner.ValueRO.Prefab);\n                ecb.SetComponent(newEntity, LocalTransform.FromPosition(spawner.ValueRO.SpawnPosition));\n\n                spawner.ValueRW.Timer = spawner.ValueRO.SpawnRate;\n            }\n        }\n    }\n}\n\n// ParallelWriter example for jobs\npublic partial struct KillSystem : ISystem\n{\n    public void OnUpdate(ref SystemState state)\n    {\n        var ecbSingleton = SystemAPI.GetSingleton&lt;EndSimulationEntityCommandBufferSystem.Singleton&gt;();\n        EntityCommandBuffer ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);\n\n        new KillJob\n        {\n            Ecb = ecb.AsParallelWriter()\n        }.ScheduleParallel();\n    }\n}\n\npublic partial struct KillJob : IJobEntity\n{\n    public EntityCommandBuffer.ParallelWriter Ecb;\n\n    // [ChunkIndexInQuery] provides sort key for deterministic playback\n    private void Execute(Entity entity, [ChunkIndexInQuery] int sortKey, in Health health)\n    {\n        if (health.Current &lt;= 0)\n        {\n            // Sort key ensures deterministic command order\n            Ecb.DestroyEntity(sortKey, entity);\n        }\n    }\n}\n\n// Manual ECB creation (less common)\npublic void OnUpdate(ref SystemState state)\n{\n    var ecb = new EntityCommandBuffer(Allocator.Temp);\n\n    // Record commands\n    Entity e = ecb.CreateEntity();\n    ecb.AddComponent&lt;MyComponent&gt;(e);\n\n    // Manual playback - happens immediately\n    ecb.Playback(state.EntityManager);\n    ecb.Dispose();\n}\n</code></pre>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#pros","title":"Pros","text":"<ul> <li> <p>Enables parallel Structural changes - jobs can queue changes that would otherwise require main thread</p> </li> <li> <p>Deferred execution - commands recorded during iteration don't invalidate iterators</p> </li> <li> <p>Deterministic playback - ParallelWriter with sort keys ensures same command order every run</p> </li> <li> <p>Burst compatible - can be used in Burst-compiled jobs</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#cons","title":"Cons","text":"<ul> <li> <p>Memory overhead - commands stored in memory until playback, large batches can allocate significantly</p> </li> <li> <p>Delayed effect - changes don't apply until playback, can't query new entities immediately</p> </li> <li> <p>Requires sort keys - ParallelWriter needs <code>[ChunkIndexInQuery]</code> for deterministic ordering, easy to forget</p> </li> <li> <p>Manual disposal - manually created ECBs must be disposed, forgetting causes memory leaks</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#best-use","title":"Best use","text":"<ul> <li> <p>Parallel structural changes - spawning, destroying, or modifying entities from within parallel jobs</p> </li> <li> <p>Job-based entity creation - spawning enemies, projectiles, effects from IJobEntity</p> </li> <li> <p>Collision response - destroying entities or adding components based on physics events in ITriggerEventsJob</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Main thread with immediate effect - if on main thread and need immediate changes, use <code>EntityManager</code> directly instead of ECB</p> </li> <li> <p>Simple queries - for reading/writing components without structural changes, use SystemAPI.Query or IJobEntity without ECB</p> </li> <li> <p>Singleton data updates - for updating singleton components, direct access is simpler than ECB</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/EntityCommandBuffer/#extra-tip","title":"Extra tip","text":"<ul> <li>ECB system types and playback timing:</li> <li><code>BeginInitializationEntityCommandBufferSystem</code> - plays back before transform system, good for creating entities</li> <li><code>BeginSimulationEntityCommandBufferSystem</code> - plays back early in simulation frame, good for destroying entities</li> <li><code>EndSimulationEntityCommandBufferSystem</code> - plays back at end of simulation, after all gameplay systems</li> <li> <p><code>BeginPresentationEntityCommandBufferSystem</code> - plays back before rendering</p> </li> <li> <p>Singleton pattern - <code>SystemAPI.GetSingleton&lt;ECBSystem.Singleton&gt;().CreateCommandBuffer(state.WorldUnmanaged)</code> is preferred way to get ECB</p> </li> <li> <p>PlaybackPolicy - use <code>EntityCommandBuffer.PlaybackPolicy.SinglePlayback</code> for manual ECBs that should only play once</p> </li> <li> <p>Multiple ECBs strategy - common pattern: use BeginInitializationECB for creation/adding components, BeginSimulationECB for destruction to ensure proper execution order</p> </li> <li> <p>Sorting determinism - <code>[ChunkIndexInQuery] int sortKey</code> parameter in jobs provides sort index - pass to ParallelWriter methods as first parameter</p> </li> <li> <p>Parallel vs regular - use <code>.AsParallelWriter()</code> only for jobs scheduled with <code>ScheduleParallel()</code>, not for <code>Schedule()</code> or main thread execution</p> </li> <li> <p>Temporary entity IDs - entities created via ECB return placeholder Entity that can be referenced in subsequent commands before playback:   <pre><code>// Create entity via ECB (returns temporary Entity ID)\nEntity newEntity = ecb.CreateEntity();\n\n// Use temporary ID to add components BEFORE playback\necb.AddComponent(newEntity, new Health { Current = 100 });\necb.SetComponent(newEntity, LocalTransform.FromPosition(float3.zero));\n\n// Set as parent of another entity\nEntity child = ecb.CreateEntity();\necb.AddComponent(child, new Parent { Value = newEntity });  // References temp ID\n\n// After playback, temporary IDs become real Entity IDs\n</code></pre></p> </li> <li> <p>Parallel temporary entities - ParallelWriter with temporary entities requires sort keys:   <pre><code>private void Execute([ChunkIndexInQuery] int sortKey, in SpawnRequest request)\n{\n    // Create with sort key\n    Entity tempEntity = Ecb.CreateEntity(sortKey);\n\n    // Reference temp entity with same sort key\n    Ecb.AddComponent(sortKey, tempEntity, new Health { Current = 100 });\n    Ecb.SetComponent(sortKey, tempEntity, LocalTransform.FromPosition(request.Position));\n}\n</code></pre></p> </li> <li> <p>Temporary entity limitations:   <pre><code>// CAN do with temporary entities:\n- AddComponent, RemoveComponent, SetComponent on temp entity\n- Use as Parent.Value for hierarchy\n- Store in components on other entities\n- DestroyEntity on temp entity (cancels creation)\n\n// CANNOT do with temporary entities:\n- Query for temp entities (don't exist in World yet)\n- Use with EntityManager operations (not real entities yet)\n- Access components via ComponentLookup (no backing data until playback)\n</code></pre></p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ISystem/","title":"ISystem","text":"","tags":["system"]},{"location":"DOTS/Systems/ISystem/#description","title":"Description","text":"<ul> <li> <p>Modern system interface for Unity ECS - lightweight, value-type system defined as <code>partial struct</code> instead of class</p> </li> <li> <p>Burst compatible - entire system can be Burst compiled for maximum performance, including OnCreate, OnUpdate, and OnDestroy</p> </li> <li> <p>Recommended system type for all new DOTS projects - replaces the older SystemBase (class-based systems)</p> </li> <li> <p>Requires manual state management via <code>ref SystemState</code> parameter but provides better performance and control</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ISystem/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem\n{\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Initialize system - runs once when system created\n        state.RequireForUpdate&lt;HealthRegen&gt;();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Main system logic - runs every frame\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        foreach (var (health, regen) in\n            SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;HealthRegen&gt;&gt;())\n        {\n            health.ValueRW.Current += regen.ValueRO.PointPerSec * deltaTime;\n        }\n    }\n}\n</code></pre>","tags":["system"]},{"location":"DOTS/Systems/ISystem/#pros","title":"Pros","text":"<ul> <li>Burst compatible - entire system compiles with Burst for maximum performance</li> <li>Zero GC allocations - struct-based, no managed allocations</li> <li>Better performance - no virtual calls, better cache locality</li> <li>Modern API - designed for SystemAPI.Query and IJobEntity</li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ISystem/#cons","title":"Cons","text":"<ul> <li>More boilerplate - requires <code>[BurstCompile]</code> on methods, <code>ref SystemState</code> parameter</li> <li>No managed access - can't directly use managed types without <code>SystemAPI.ManagedAPI</code></li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ISystem/#best-use","title":"Best use","text":"<ul> <li>All new DOTS projects - ISystem is the recommended system type</li> <li>Performance-critical systems - Burst compilation provides massive speedup</li> <li>Job-based processing - natural fit for IJobEntity</li> </ul>","tags":["system"]},{"location":"DOTS/Systems/ISystem/#extra-tip","title":"Extra tip","text":"<ul> <li>Always Burst compile - add <code>[BurstCompile]</code> to system struct and all methods</li> <li>SystemState.Dependency - use for job dependencies: <code>state.Dependency = job.Schedule(state.Dependency)</code></li> <li>RequireForUpdate - <code>state.RequireForUpdate&lt;T&gt;()</code> to conditionally run system</li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/","title":"RefRO and RefRW","text":"","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#description","title":"Description","text":"<ul> <li> <p>Type-safe reference wrappers for accessing component data with explicit read-only (<code>RefRO&lt;T&gt;</code>) or read-write (<code>RefRW&lt;T&gt;</code>) semantics</p> </li> <li> <p>Used in SystemAPI.Query, IJobEntity, and IAspect to access component data with compile-time access control</p> </li> <li> <p><code>RefRO&lt;T&gt;</code> provides read-only access via <code>.ValueRO</code> property (analogous to <code>ref readonly T</code> or <code>in T</code>)</p> </li> <li> <p><code>RefRW&lt;T&gt;</code> provides read-write access via <code>.ValueRW</code> property (analogous to <code>ref T</code>)</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        float deltaTime = SystemAPI.Time.DeltaTime;\n\n        // RefRW for read-write, RefRO for read-only\n        foreach (var (health, regen) in\n            SystemAPI.Query&lt;RefRW&lt;Health&gt;, RefRO&lt;HealthRegen&gt;&gt;())\n        {\n            // Read-only access with .ValueRO\n            float regenAmount = regen.ValueRO.PointPerSec * deltaTime;\n\n            // Read-write access with .ValueRW\n            health.ValueRW.Current = math.min(\n                health.ValueRW.Current + regenAmount,\n                health.ValueRO.Max  // Can use .ValueRO even on RefRW\n            );\n        }\n    }\n}\n\n// IAspect example\npublic readonly partial struct ProjectileAspect : IAspect\n{\n    // Readonly fields in aspect\n    readonly RefRO&lt;Guided&gt; _guided;\n    readonly RefRO&lt;Speed&gt; _speed;\n\n    // Read-write field\n    readonly RefRW&lt;LocalTransform&gt; _transform;\n\n    public void Move(float deltaTime)\n    {\n        // Read with .ValueRO\n        if (_guided.ValueRO.Enabled)\n        {\n            // Write with .ValueRW\n            _transform.ValueRW.Position += _speed.ValueRO.Value * deltaTime;\n        }\n    }\n}\n\n// IJobEntity with ref/in alternative syntax\npublic partial struct DamageJob : IJobEntity\n{\n    // ref = read-write (equivalent to RefRW)\n    // in = read-only (equivalent to RefRO)\n    private void Execute(ref Health health, in Damage damage)\n    {\n        // ref gives direct access, no .ValueRW needed\n        health.Current -= damage.Amount;\n    }\n}\n</code></pre>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#pros","title":"Pros","text":"<ul> <li> <p>Type safety - compile-time enforcement of read-only vs read-write access intent</p> </li> <li> <p>Performance hints - read-only access enables better job scheduling and parallelization</p> </li> <li> <p>Clear intent - code clearly shows which data is modified vs just read</p> </li> <li> <p>Burst compatible - works in all Burst-compiled contexts (systems, jobs, aspects)</p> </li> <li> <p>Flexible access - <code>RefRW&lt;T&gt;.ValueRO</code> allows reading from read-write reference</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#cons","title":"Cons","text":"<ul> <li> <p>Extra syntax - requires <code>.ValueRO</code> or <code>.ValueRW</code> property access instead of direct field access</p> </li> <li> <p>Learning curve - new developers must understand when to use RefRO vs RefRW vs ref vs in</p> </li> <li> <p>Verbosity - adds more characters compared to plain <code>ref</code> / <code>in</code> parameters</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#best-use","title":"Best use","text":"<ul> <li> <p>SystemAPI.Query - use <code>RefRW&lt;T&gt;</code> and <code>RefRO&lt;T&gt;</code> for explicit access control in queries</p> </li> <li> <p>IAspect fields - use as field types in aspects to define component access patterns</p> </li> <li> <p>Read-mostly data - use <code>RefRO</code> when you only need to read, helps job system optimize parallel execution</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>IJobEntity Execute parameters - prefer <code>ref T</code> and <code>in T</code> syntax for cleaner code in job Execute methods</p> </li> <li> <p>Simple read access - if you're only reading one field once, <code>in T</code> may be clearer than <code>RefRO&lt;T&gt;</code></p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/RefRO%20and%20RefRW/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>ValueRO on RefRW - you can use <code>.ValueRO</code> on <code>RefRW&lt;T&gt;</code> for read-only access without triggering change tracking or preventing parallelization</p> </li> <li> <p>Equivalent syntax:</p> </li> <li><code>RefRO&lt;T&gt;</code> \u2248 <code>in T</code> \u2248 <code>ref readonly T</code></li> <li> <p><code>RefRW&lt;T&gt;</code> \u2248 <code>ref T</code></p> </li> <li> <p>Change detection optimization - Unity can detect when you only use <code>.ValueRO</code> on <code>RefRW</code> and optimize accordingly (e.g., allowing more parallelization)</p> </li> <li> <p>SystemAPI.Query requires Ref types - can't use <code>ref</code> / <code>in</code> in foreach patterns, must use <code>RefRW</code> / <code>RefRO</code></p> </li> <li> <p>IJobEntity flexibility - in IJobEntity.Execute, you can mix: <code>RefRW&lt;Health&gt; health</code>, <code>ref Health health</code>, and <code>in Health health</code> - all valid, choose based on preference</p> </li> <li> <p>EnabledRefRO / EnabledRefRW - similar concept for enableable components, used to access enabled state instead of component data</p> </li> <li> <p>Performance consideration - <code>RefRO</code> allows Unity to run multiple jobs in parallel that read same component, <code>RefRW</code> requires exclusive access</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemBase/","title":"SystemBase","text":"<p>\u26a0\ufe0f LEGACY SYSTEM TYPE</p> <p><code>SystemBase</code> is the legacy class-based system type. For all new projects, use ISystem instead. SystemBase remains supported but ISystem offers better performance through Burst compilation and zero GC allocations.</p> <p>Modern alternative: ISystem (partial struct with Burst support)</p>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#description","title":"Description","text":"<ul> <li> <p>Legacy class-based system type for Unity ECS - defined as <code>class</code> instead of struct</p> </li> <li> <p>Cannot be Burst compiled - OnUpdate and other methods run as managed C# code, missing major performance benefits</p> </li> <li> <p>Easier managed API access - can directly use managed types, LINQ, and C# features not available in Burst</p> </li> <li> <p>Entities.ForEach - originally designed for now-deprecated <code>Entities.ForEach</code> pattern (replaced by IJobEntity)</p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#example","title":"Example","text":"<pre><code>// Legacy SystemBase approach\npublic partial class HealthRegenSystem : SystemBase\n{\n    protected override void OnUpdate()\n    {\n        float deltaTime = Time.DeltaTime;\n\n        // Old Entities.ForEach (deprecated in Unity Entities 6.5+)\n        Entities\n            .ForEach((ref Health health, in HealthRegen regen) =&gt;\n            {\n                health.Current += regen.PointPerSec * deltaTime;\n            })\n            .ScheduleParallel();\n    }\n}\n\n// Modern ISystem equivalent (RECOMMENDED)\n[BurstCompile]\npublic partial struct HealthRegenSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        new RegenJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        }.ScheduleParallel();\n    }\n\n    [BurstCompile]\n    public partial struct RegenJob : IJobEntity\n    {\n        public float DeltaTime;\n        private void Execute(ref Health health, in HealthRegen regen)\n        {\n            health.Current += regen.PointPerSec * DeltaTime;\n        }\n    }\n}\n</code></pre>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#pros","title":"Pros","text":"<ul> <li> <p>Managed C# access - can use LINQ, strings, managed collections, exceptions</p> </li> <li> <p>Easier for beginners - familiar class-based OOP pattern</p> </li> <li> <p>Direct managed component access - no need for <code>SystemAPI.ManagedAPI</code></p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#cons","title":"Cons","text":"<ul> <li> <p>No Burst compilation - misses 10-100x performance improvements from Burst</p> </li> <li> <p>GC allocations - class-based systems create garbage, causing GC pauses</p> </li> <li> <p>Slower - virtual method calls, poor cache locality compared to ISystem</p> </li> <li> <p>Deprecated patterns - designed for <code>Entities.ForEach</code> which is now deprecated</p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#best-use","title":"Best use","text":"<ul> <li> <p>Legacy codebase migration - temporary use while migrating to ISystem</p> </li> <li> <p>Heavy managed API usage - if system must use lots of managed Unity APIs (rare)</p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>New project - always use ISystem for new DOTS projects</p> </li> <li> <p>Performance matters - SystemBase is significantly slower than ISystem</p> </li> <li> <p>Can use ISystem - in 99% of cases, ISystem is the better choice</p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemBase/#extra-tip","title":"Extra tip","text":"<ul> <li>Migration path - when migrating to ISystem:</li> <li>Change <code>class</code> to <code>partial struct</code></li> <li>Add <code>[BurstCompile]</code> attribute</li> <li>Add <code>ref SystemState state</code> parameter to OnUpdate</li> <li>Replace <code>Entities.ForEach</code> with IJobEntity</li> <li> <p>Replace direct property access with <code>state.Property</code></p> </li> <li> <p>Property differences: <pre><code>// SystemBase\nEntityManager em = EntityManager;\nfloat dt = Time.DeltaTime;\nJobHandle dep = Dependency;\n\n// ISystem\nEntityManager em = state.EntityManager;\nfloat dt = SystemAPI.Time.DeltaTime;\nJobHandle dep = state.Dependency;\n</code></pre></p> </li> <li> <p>Still supported - SystemBase will continue to work, but is not recommended for new code</p> </li> </ul>","tags":["system","legacy"]},{"location":"DOTS/Systems/SystemState/","title":"SystemState","text":"","tags":["system"]},{"location":"DOTS/Systems/SystemState/#description","title":"Description","text":"<ul> <li> <p>System instance state parameter passed to OnUpdate(), OnCreate(), and OnDestroy() methods of ISystem - provides access to system properties and ECS operations</p> </li> <li> <p>Central access point for EntityManager, World, job dependencies, and queries within system context</p> </li> <li> <p>Tracks component access - operations through SystemState register which components system uses, essential for automatic dependency management</p> </li> <li> <p>Replaces direct EntityManager access - prefer SystemState methods to ensure proper dependency tracking</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#example","title":"Example","text":"<pre><code>[BurstCompile]\npublic partial struct ExampleSystem : ISystem\n{\n    // Store query as system field\n    private EntityQuery _query;\n    private ComponentLookup&lt;Health&gt; _healthLookup;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        // Access World\n        Debug.Log($\"System created in world: {state.WorldUnmanaged.Name}\");\n\n        // Create query through SystemState (registers component access)\n        _query = state.GetEntityQuery(typeof(Health), typeof(Transform));\n\n        // Get component lookup through SystemState\n        _healthLookup = state.GetComponentLookup&lt;Health&gt;(isReadOnly: true);\n\n        // Require specific components for system to update\n        state.RequireForUpdate&lt;GameConfig&gt;();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Access time\n        float deltaTime = state.WorldUnmanaged.Time.DeltaTime;\n\n        // Update lookups before use\n        _healthLookup.Update(ref state);\n\n        // Access EntityManager\n        Entity entity = state.EntityManager.CreateEntity(typeof(Health));\n\n        // Job dependency management\n        JobHandle inputDeps = state.Dependency;\n\n        JobHandle outputDeps = new MyJob\n        {\n            DeltaTime = deltaTime\n        }.Schedule(_query, inputDeps);\n\n        // Write back new dependency for next system\n        state.Dependency = outputDeps;\n\n        // Enable/disable system\n        if (someCondition)\n        {\n            state.Enabled = false;  // Skip updates until re-enabled\n        }\n    }\n\n    [BurstCompile]\n    public void OnDestroy(ref SystemState state)\n    {\n        // Cleanup if needed\n    }\n}\n</code></pre>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#pros","title":"Pros","text":"<ul> <li> <p>Automatic dependency tracking - registers component access for System Dependencies, unlike direct EntityManager usage</p> </li> <li> <p>Burst compatible - operations through SystemState work in Burst-compiled systems</p> </li> <li> <p>Centralized state - single parameter provides access to all system needs (world, entities, queries, dependencies)</p> </li> <li> <p>Type-safe - compile-time checking ensures correct usage patterns</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#cons","title":"Cons","text":"<ul> <li> <p>Must be passed by ref - always <code>ref SystemState state</code>, forgetting <code>ref</code> causes compilation error</p> </li> <li> <p>Not available outside systems - only works within ISystem lifecycle methods, not in regular classes</p> </li> <li> <p>Requires understanding - developers must learn which operations should go through SystemState vs EntityManager</p> </li> <li> <p>Boilerplate - every system method needs the SystemState parameter even if not used</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#best-use","title":"Best use","text":"<ul> <li> <p>All ISystem operations - always use SystemState in OnCreate/OnUpdate/OnDestroy for proper dependency tracking</p> </li> <li> <p>Query creation - use <code>state.GetEntityQuery()</code> or <code>state.GetComponentLookup()</code> to register component access</p> </li> <li> <p>Job scheduling - read <code>state.Dependency</code> before scheduling, write new JobHandle back after scheduling</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Outside system context - SystemState only available in ISystem, use EntityManager or World directly elsewhere</p> </li> <li> <p>Static methods - cannot use SystemState in static methods, must be instance methods of ISystem</p> </li> </ul>","tags":["system"]},{"location":"DOTS/Systems/SystemState/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Key SystemState properties and methods: <pre><code>// World access\nWorld world = state.World;  // Managed world\nWorldUnmanaged worldUnmanaged = state.WorldUnmanaged;  // Unmanaged (Burst-compatible)\n\n// EntityManager access\nEntityManager em = state.EntityManager;\n\n// Job dependency management\nJobHandle deps = state.Dependency;  // Read before scheduling\nstate.Dependency = newJobHandle;    // Write after scheduling\n\n// Enable/disable system\nstate.Enabled = false;  // Disable system updates\n\n// Query creation (registers component access)\nEntityQuery query = state.GetEntityQuery(typeof(Health));\n\n// Component lookup creation (registers component access)\nComponentLookup&lt;Health&gt; lookup = state.GetComponentLookup&lt;Health&gt;(isReadOnly: true);\n\n// Component type handle (for IJobChunk)\nComponentTypeHandle&lt;Health&gt; handle = state.GetComponentTypeHandle&lt;Health&gt;(isReadOnly: true);\n\n// Require components for update\nstate.RequireForUpdate&lt;GameConfig&gt;();  // System won't update without this component\n\n// Last system version (for change detection)\nuint lastVersion = state.LastSystemVersion;\n\n// Global system version (current frame)\nuint globalVersion = state.GlobalSystemVersion;\n</code></pre></p> </li> <li> <p>Dependency property usage pattern: <pre><code>public void OnUpdate(ref SystemState state)\n{\n    // 1. Read input dependencies\n    JobHandle inputDeps = state.Dependency;\n\n    // 2. Schedule your jobs\n    JobHandle job1 = new Job1().Schedule(inputDeps);\n    JobHandle job2 = new Job2().Schedule(job1);\n\n    // 3. Write output dependencies\n    state.Dependency = job2;\n}\n</code></pre></p> </li> <li> <p>RequireForUpdate patterns: <pre><code>// Require singleton component\nstate.RequireForUpdate&lt;GameConfig&gt;();\n\n// Require query to have matching entities\nEntityQuery query = state.GetEntityQuery(typeof(Player));\nstate.RequireForUpdate(query);\n</code></pre></p> </li> <li> <p>SystemState vs EntityManager:</p> </li> <li>Use SystemState when in ISystem methods (OnCreate/OnUpdate/OnDestroy)</li> <li>Use EntityManager when outside system context or need operations not in SystemState</li> <li> <p>SystemState operations register component access for dependency tracking</p> </li> <li> <p>WorldUnmanaged vs World:</p> </li> <li><code>state.World</code> - managed World reference (not Burst-compatible)</li> <li><code>state.WorldUnmanaged</code> - unmanaged WorldUnmanaged (Burst-compatible)</li> <li> <p>Use WorldUnmanaged in Burst-compiled code</p> </li> <li> <p>Complete dependency manually: <pre><code>// Force wait for all dependencies (creates sync point)\nstate.Dependency.Complete();  // or\nstate.CompleteDependency();   // Clearer intent\n</code></pre></p> </li> </ul>","tags":["system"]},{"location":"DOTS/Testing/","title":"Testing","text":"<p>Testing in Unity DOTS ensures system correctness, prevents regressions, and tracks performance across code changes. The ECS architecture's deterministic nature makes it highly testable.</p>"},{"location":"DOTS/Testing/#testing-types","title":"Testing Types","text":""},{"location":"DOTS/Testing/#unit-testing","title":"Unit Testing","text":"<ul> <li>Unit Testing - Isolated system validation with test worlds, entity setup, and state assertions</li> </ul>"},{"location":"DOTS/Testing/#performance-testing","title":"Performance Testing","text":"<ul> <li>Performance Testing - Automated benchmarking to compare APIs, measure job overhead, and track performance regressions</li> </ul>"},{"location":"DOTS/Testing/#quick-reference","title":"Quick Reference","text":"Test Type Purpose Tools Best For Unit Testing System logic validation NUnit, ECSTestsFixture Calculation systems, edge cases, refactoring Performance Testing Execution time measurement Unity Performance Testing API comparison, job overhead, CI/CD gates"},{"location":"DOTS/Testing/#testing-workflow","title":"Testing Workflow","text":""},{"location":"DOTS/Testing/#unit-testing-workflow","title":"Unit Testing Workflow","text":"<ol> <li>Setup - Create test World, EntityManager, and entities</li> <li>Arrange - Populate entities with test components</li> <li>Act - Execute system update</li> <li>Assert - Verify component state changes</li> <li>Teardown - Dispose test world</li> </ol>"},{"location":"DOTS/Testing/#performance-testing-workflow","title":"Performance Testing Workflow","text":"<ol> <li>Setup - Create test fixture with warmup/measurement configuration</li> <li>Arrange - Create entities at target scale (100, 1K, 10K, 100K)</li> <li>Measure - Run system with Performance Testing API</li> <li>Compare - Analyze results across multiple approaches</li> <li>Validate - Test on target hardware, not editor</li> </ol>"},{"location":"DOTS/Testing/#best-practices","title":"Best Practices","text":""},{"location":"DOTS/Testing/#unit-testing_1","title":"Unit Testing","text":"<ol> <li>Use custom test fixtures - extend <code>ECSTestsFixture</code> with simplified APIs</li> <li>Test edge cases - verify empty queries, zero values, boundary conditions</li> <li>Mark systems with [BurstCompile] - test production code paths</li> <li>Separate test assemblies - use <code>UNITY_INCLUDE_TESTS</code> define constraint</li> </ol>"},{"location":"DOTS/Testing/#performance-testing_1","title":"Performance Testing","text":"<ol> <li>Test on target hardware - editor performance misleading</li> <li>Account for variance - Job tests show high standard deviation</li> <li>Test multiple scales - small datasets favor main thread, large datasets favor jobs</li> <li>Isolate systems - strip unnecessary code for accurate measurements</li> </ol>"},{"location":"DOTS/Testing/#key-findings","title":"Key Findings","text":""},{"location":"DOTS/Testing/#entitymanager-vs-systemapi","title":"EntityManager vs SystemAPI","text":"<ul> <li><code>SystemAPI.HasComponent&lt;T&gt;()</code> ~23% slower than <code>EntityManager.HasComponent&lt;T&gt;()</code></li> <li>Both remain microsecond-range operations</li> <li>Choose based on code clarity</li> </ul>"},{"location":"DOTS/Testing/#job-scheduling-1000-entities","title":"Job Scheduling (1,000 entities)","text":"<ul> <li>Main thread: ~10.75 \u03bcs (fastest)</li> <li>Job.Run(): ~16.35 \u03bcs (52% slower)</li> <li>Job.Schedule(): ~17.70 \u03bcs (65% slower)</li> <li>Job.ScheduleParallel(): ~30.70 \u03bcs (185% slower)</li> <li>Jobs show overhead below ~10,000 entities</li> </ul>"},{"location":"DOTS/Testing/#common-patterns","title":"Common Patterns","text":""},{"location":"DOTS/Testing/#custom-test-fixture","title":"Custom Test Fixture","text":"<pre><code>public class CustomEcsTestsFixture\n{\n    protected World World;\n    protected EntityManager EntityManager;\n\n    [SetUp]\n    public void SetUp()\n    {\n        World = new World(\"Test World\");\n        EntityManager = World.EntityManager;\n    }\n\n    [TearDown]\n    public void TearDown()\n    {\n        if (World != null &amp;&amp; World.IsCreated)\n            World.Dispose();\n    }\n\n    protected void UpdateSystem&lt;T&gt;() where T : unmanaged, ISystem\n    {\n        ref var system = ref World.GetOrCreateSystemManaged&lt;T&gt;();\n        system.Update(World.Unmanaged);\n    }\n}\n</code></pre>"},{"location":"DOTS/Testing/#performance-measurement","title":"Performance Measurement","text":"<pre><code>Measure.Method(() =&gt;\n{\n    system.Update(World.Unmanaged);\n})\n.WarmupCount(5)\n.MeasurementCount(10)\n.IterationsPerMeasurement(5)\n.Run();\n</code></pre>"},{"location":"DOTS/Testing/Performance%20Testing/","title":"Performance Testing","text":"","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#description","title":"Description","text":"<ul> <li> <p>Automated performance benchmarking - measure system execution time using Unity's Performance Testing package to track performance across code changes</p> </li> <li> <p>Critical for DOTS optimization - helps compare multiple API approaches (EntityManager vs SystemAPI), determine when jobs provide benefit, and track performance regressions in CI/CD</p> </li> <li> <p>Reveals job overhead - benchmarking shows parallelization isn't always faster - main thread can outperform jobs for small entity counts (&lt;10,000)</p> </li> <li> <p>Hardware-specific testing - performance varies significantly between editor and target devices; always test on actual hardware</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#example","title":"Example","text":"<pre><code>using NUnit.Framework;\nusing Unity.PerformanceTesting;\nusing Unity.Entities;\nusing Unity.Entities.Tests;  // ECSTestsFixture\nusing Unity.Collections;\n\n// Custom performance test fixture extending ECSTestsFixture\npublic class PerformanceTestFixture : ECSTestsFixture\n{\n    // World and m_Manager inherited from base class\n    // Base handles setup/teardown automatically\n\n    protected void MeasureSystemUpdate&lt;T&gt;() where T : unmanaged, ISystem\n    {\n        ref var systemState = ref World.Unmanaged.GetExistingSystemState&lt;T&gt;();\n\n        Measure.Method(() =&gt;\n        {\n            systemState.Update(World.Unmanaged);\n        })\n        .WarmupCount(5)\n        .MeasurementCount(10)\n        .IterationsPerMeasurement(5)\n        .SampleGroup(\"SystemUpdate\")\n        .Run();\n    }\n}\n\n// Example: Comparing EntityManager vs SystemAPI\n[TestFixture]\npublic class ComponentAccessPerformanceTests : PerformanceTestFixture\n{\n    private const int EntityCount = 1000;\n\n    [Test, Performance]\n    public void EntityManager_HasComponent_Performance()\n    {\n        // Arrange - create entities\n        var archetype = m_Manager.CreateArchetype(typeof(Health));\n        m_Manager.CreateEntity(archetype, EntityCount, Allocator.Temp);\n\n        var entities = m_Manager.GetAllEntities(Allocator.Temp);\n\n        // Act &amp; Measure\n        Measure.Method(() =&gt;\n        {\n            foreach (var entity in entities)\n            {\n                bool hasHealth = m_Manager.HasComponent&lt;Health&gt;(entity);\n            }\n        })\n        .WarmupCount(5)\n        .MeasurementCount(10)\n        .IterationsPerMeasurement(5)\n        .SampleGroup(\"EntityManager.HasComponent\")\n        .Run();\n\n        entities.Dispose();\n    }\n\n    [Test, Performance]\n    public void SystemAPI_HasComponent_Performance()\n    {\n        // Arrange\n        var archetype = m_Manager.CreateArchetype(typeof(Health));\n        m_Manager.CreateEntity(archetype, EntityCount, Allocator.Temp);\n\n        World.CreateSystem&lt;TestSystem&gt;();\n        ref var system = ref World.Unmanaged.GetExistingSystemState&lt;TestSystem&gt;();\n\n        // Act &amp; Measure\n        Measure.Method(() =&gt;\n        {\n            system.Update(World.Unmanaged);\n        })\n        .WarmupCount(5)\n        .MeasurementCount(10)\n        .IterationsPerMeasurement(5)\n        .SampleGroup(\"SystemAPI.HasComponent\")\n        .Run();\n    }\n}\n\n// Example: Job scheduling comparison\n[TestFixture]\npublic class JobSchedulingPerformanceTests : PerformanceTestFixture\n{\n    private const int EntityCount = 1000;\n\n    [Test, Performance]\n    public void MainThread_Execution()\n    {\n        CreateTestEntities(EntityCount);\n        World.CreateSystem&lt;MainThreadSystem&gt;();\n        MeasureSystemUpdate&lt;MainThreadSystem&gt;();\n    }\n\n    [Test, Performance]\n    public void JobRun_Execution()\n    {\n        CreateTestEntities(EntityCount);\n        World.CreateSystem&lt;JobRunSystem&gt;();\n        MeasureSystemUpdate&lt;JobRunSystem&gt;();\n    }\n\n    [Test, Performance]\n    public void JobSchedule_Execution()\n    {\n        CreateTestEntities(EntityCount);\n        World.CreateSystem&lt;JobScheduleSystem&gt;();\n        MeasureSystemUpdate&lt;JobScheduleSystem&gt;();\n    }\n\n    [Test, Performance]\n    public void JobScheduleParallel_Execution()\n    {\n        CreateTestEntities(EntityCount);\n        World.CreateSystem&lt;JobScheduleParallelSystem&gt;();\n        MeasureSystemUpdate&lt;JobScheduleParallelSystem&gt;();\n    }\n\n    private void CreateTestEntities(int count)\n    {\n        var archetype = m_Manager.CreateArchetype(\n            typeof(LocalTransform),\n            typeof(Velocity));\n        m_Manager.CreateEntity(archetype, count, Allocator.Temp);\n    }\n}\n</code></pre>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#why-performance-testing-matters","title":"Why Performance Testing Matters","text":"<p>API Clarity - Multiple Unity ECS APIs provide identical functionality (EntityManager vs SystemAPI) - Benchmarking reveals which approach is faster for your specific use case</p> <p>Job Overhead Analysis - Job parallelization has overhead - not always beneficial for small datasets - Testing reveals breakeven point where jobs outperform main thread execution</p> <p>CI/CD Integration - Automated performance tests catch regressions before deployment - Track performance trends across versions without manual profiling</p> <p>Unity Version Optimization - Minor Unity updates improve code generation and performance - Automated tests quickly validate if your code benefits from updates</p>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#configuration","title":"Configuration","text":"<p>Recommended Settings <pre><code>Measure.Method(() =&gt; { /* code */ })\n    .WarmupCount(5)              // Warmup iterations\n    .MeasurementCount(10)         // Number of samples\n    .IterationsPerMeasurement(5)  // Iterations per sample\n    .SampleGroup(\"GroupName\")     // Category/label\n    .Run();\n</code></pre></p> <p>Package Requirements - Unity Performance Testing Package 3.0.3+ - Target device testing (not editor) for accurate results - Custom test fixture for simplified system measurement</p>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#pros","title":"Pros","text":"<ul> <li> <p>Automated regression detection - CI/CD integration catches performance degradation before production</p> </li> <li> <p>API comparison - objectively compare EntityManager, SystemAPI, ComponentLookup performance for your use cases</p> </li> <li> <p>Job overhead visibility - reveals when Job parallelization helps vs hurts performance</p> </li> <li> <p>Version upgrade confidence - validate Unity updates improve (or don't regress) your specific systems</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#cons","title":"Cons","text":"<ul> <li> <p>High variance - Job system tests show significant standard deviation, making small differences hard to measure</p> </li> <li> <p>Editor inaccuracy - editor performance doesn't match target device; requires device builds for reliable data</p> </li> <li> <p>Isolated measurement - tests stripped-down systems, may not reflect real-world performance with full game context</p> </li> <li> <p>Setup complexity - requires understanding Performance Testing API, custom fixtures, and statistical interpretation</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#best-use","title":"Best use","text":"<ul> <li> <p>API decision making - when choosing between equivalent APIs (EntityManager.HasComponent vs SystemAPI.HasComponent)</p> </li> <li> <p>Job parallelization decisions - determine entity count threshold where jobs become beneficial</p> </li> <li> <p>CI/CD performance gates - fail builds if systems regress beyond acceptable thresholds</p> </li> <li> <p>Unity version validation - test if upgrading Unity improves your specific systems</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Profiling hot paths - use Unity Profiler for detailed frame analysis and optimization of critical systems</p> </li> <li> <p>Small sample size (&lt;1000 entities) - high variance makes results unreliable; use profiling instead</p> </li> <li> <p>Integration testing - performance tests measure isolated systems; not suitable for multi-system interaction testing</p> </li> <li> <p>Initial development - focus on correctness first, add performance tests after systems stabilize</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#key-findings-from-research","title":"Key Findings from Research","text":"<p>EntityManager vs SystemAPI (HasComponent checks) - <code>SystemAPI.HasComponent&lt;T&gt;()</code> ~23% slower than <code>EntityManager.HasComponent&lt;T&gt;()</code> - Both operations remain in microsecond range - rarely a bottleneck - Choose based on code clarity, not performance</p> <p>Job Scheduling Comparison (1,000 entities) - Main thread: ~10.75 \u03bcs (fastest) - Job.Run(): ~16.35 \u03bcs (52% slower) - Job.Schedule(): ~17.70 \u03bcs (65% slower) - Job.ScheduleParallel(): ~30.70 \u03bcs (185% slower)</p> <p>Parallelization Breakeven - Jobs show overhead for &lt;10,000 entities - Main thread often faster for small datasets - Test your specific system to find breakeven point</p>","tags":["testing","performance"]},{"location":"DOTS/Testing/Performance%20Testing/#extra-tip","title":"Extra tip","text":"<ul> <li> <p>Strip test systems - remove unnecessary code from systems under test for accurate isolated measurement</p> </li> <li> <p>Account for variance - job testing shows high standard deviation; interpret results conservatively and look for large differences (&gt;20%)</p> </li> <li> <p>Test real scenarios - use actual game systems or stripped versions matching production code, not synthetic benchmarks</p> </li> <li> <p>Target device required - editor performance misleading; always validate on actual hardware (mobile, console, PC)</p> </li> <li> <p>Sample unit choice - use microseconds for system-level tests; milliseconds for frame-time measurements</p> </li> <li> <p>Comparative testing - test multiple approaches side-by-side with identical entity counts and conditions</p> </li> <li> <p>Statistical significance - look for consistent differences across multiple runs; single measurements can be misleading</p> </li> <li> <p>Profiler correlation - use Unity Profiler to validate performance test findings in real game context</p> </li> <li> <p>Entity count scaling - test at multiple scales (100, 1K, 10K, 100K entities) to understand performance characteristics</p> </li> <li> <p>Measure.Scope alternative - for non-system code, use <code>Measure.Scope()</code> for simplified measurement blocks:   <pre><code>using (Measure.Scope(\"MyOperation\"))\n{\n    // Code to measure\n}\n</code></pre></p> </li> <li> <p>Burst compilation - ensure [BurstCompile] attribute present on systems to match production performance</p> </li> <li> <p>Caching queries - pre-create EntityQuery objects in OnCreate to avoid query creation overhead in measurements</p> </li> </ul>","tags":["testing","performance"]},{"location":"DOTS/Testing/Unit%20Testing/","title":"Unit Testing","text":"","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#description","title":"Description","text":"<ul> <li> <p>Isolated system validation - create test worlds, populate with entities and components, execute systems, and assert expected state changes</p> </li> <li> <p>Two main fixture approaches - reference Unity's built-in test fixtures via <code>testables</code> in manifest.json, or create custom copies for isolated control</p> </li> <li> <p>Recommended pattern - extend <code>ECSTestsFixture</code> (or custom version) with simplified APIs like <code>UpdateSystem&lt;T&gt;()</code>, <code>CreateEntity()</code>, and <code>CreateEntities()</code> to reduce boilerplate</p> </li> <li> <p>Tests follow Arrange-Act-Assert pattern - set up entities (arrange), execute system (act), verify component state (assert)</p> </li> </ul>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#example","title":"Example","text":"<pre><code>using NUnit.Framework;\nusing Unity.Entities;\nusing Unity.Entities.Tests;  // ECSTestsFixture location\nusing Unity.Collections;\n\n// Custom test fixture extending Unity's ECSTestsFixture\n// Inherit from ECSTestsFixture to get World, EntityManager, and proper setup/teardown\npublic class CustomEcsTestsFixture : ECSTestsFixture\n{\n    // World and EntityManager already available from base class\n    // Base class handles setup/teardown automatically\n\n    // Add simplified helper methods\n    protected void UpdateSystem&lt;T&gt;() where T : unmanaged, ISystem\n    {\n        ref var system = ref World.GetOrCreateSystemManaged&lt;T&gt;();\n        system.Update(World.Unmanaged);\n    }\n\n    protected Entity CreateEntity(params ComponentType[] types)\n    {\n        return m_Manager.CreateEntity(types);  // m_Manager from base class\n    }\n\n    protected void CreateEntities(ComponentType[] types, int count)\n    {\n        var archetype = m_Manager.CreateArchetype(types);\n        m_Manager.CreateEntity(archetype, count, Allocator.Temp);\n    }\n}\n\n// Example test - testing movement system\npublic class MovementSystemTests : CustomEcsTestsFixture\n{\n    [Test]\n    public void MovementSystem_AppliesVelocity_WhenNoCollision()\n    {\n        // Arrange - create entity with velocity\n        var entity = CreateEntity(\n            ComponentType.ReadWrite&lt;LocalTransform&gt;(),\n            ComponentType.ReadWrite&lt;Velocity&gt;());\n\n        m_Manager.SetComponentData(entity, new LocalTransform { Position = float3.zero });\n        m_Manager.SetComponentData(entity, new Velocity { Value = new float3(1, 0, 0) });\n\n        // Act - run system\n        UpdateSystem&lt;MovementSystem&gt;();\n\n        // Assert - verify position changed\n        var transform = m_Manager.GetComponentData&lt;LocalTransform&gt;(entity);\n        Assert.Greater(transform.Position.x, 0, \"Entity should have moved\");\n    }\n\n    [Test]\n    public void MovementSystem_StopsMovement_WhenCollisionInDirection()\n    {\n        // Arrange - create entity with collision component\n        var entity = CreateEntity(\n            ComponentType.ReadWrite&lt;LocalTransform&gt;(),\n            ComponentType.ReadWrite&lt;Velocity&gt;(),\n            ComponentType.ReadWrite&lt;CollisionData&gt;());\n\n        m_Manager.SetComponentData(entity, new Velocity { Value = new float3(1, 0, 0) });\n        m_Manager.SetComponentData(entity, new CollisionData { Direction = new float3(1, 0, 0) });\n\n        // Act\n        UpdateSystem&lt;MovementSystem&gt;();\n\n        // Assert - velocity should be reset\n        var velocity = m_Manager.GetComponentData&lt;Velocity&gt;(entity);\n        Assert.AreEqual(float3.zero, velocity.Value, \"Movement should stop on collision\");\n    }\n}\n</code></pre>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#setup-options","title":"Setup Options","text":"<p>How to Access ECSTestsFixture</p> <p><code>ECSTestsFixture</code> is Unity's built-in base class located in <code>Unity.Entities.Tests</code> namespace. Two approaches to access it:</p> <p>Option 1: Reference Testables (Recommended)</p> <p>Add to <code>manifest.json</code> in your Packages folder: <pre><code>{\n  \"dependencies\": {\n    \"com.unity.entities\": \"1.3.0\"\n  },\n  \"testables\": [\"com.unity.entities\"]\n}\n</code></pre></p> <p>Then inherit from it: <pre><code>using Unity.Entities.Tests;  // Accessible via testables\n\npublic class CustomEcsTestsFixture : ECSTestsFixture\n{\n    // Your helper methods here\n}\n</code></pre></p> <p>Pros: - Automatic updates when Unity Entities package updates - Official Unity implementation with proper setup/teardown - Access to <code>World</code>, <code>m_Manager</code> (EntityManager), and other test utilities</p> <p>Cons: - Unity's internal tests appear in Test Runner (can be filtered) - Depends on Unity package internals</p> <p>Option 2: Custom Copy</p> <p>Copy <code>ECSTestsFixture.cs</code> from Unity Entities package into your test assembly: 1. Find file at: <code>Library/PackageCache/com.unity.entities@X.X.X/Unity.Entities.Tests/ECSTestsFixture.cs</code> 2. Copy to your test assembly folder 3. Create inheriting class:</p> <pre><code>public class CustomEcsTestsFixture : ECSTestsFixture\n{\n    // Your helper methods here\n}\n</code></pre> <p>Pros: - Clean Test Runner (no Unity internal tests) - Full control over fixture implementation - Can customize base setup/teardown logic</p> <p>Cons: - Manual maintenance when upgrading Unity Entities - Duplicate code from Unity package</p> <p>ECSTestsFixture Provides: - <code>World</code> - Test world instance - <code>m_Manager</code> - EntityManager for the test world - <code>EmptySystem</code> - Empty system for testing - Automatic setup/teardown of test world - Helper methods for entity/system creation</p>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#pros","title":"Pros","text":"<ul> <li> <p>Fast feedback - isolated tests run in milliseconds, catching bugs before runtime</p> </li> <li> <p>Regression prevention - automated tests prevent breaking existing functionality during refactors</p> </li> <li> <p>Burst validation - mark systems with <code>[BurstCompile]</code> to test production code paths and compilation errors</p> </li> <li> <p>Component state verification - easily verify component data changes using EntityManager queries</p> </li> </ul>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#cons","title":"Cons","text":"<ul> <li> <p>Boilerplate setup - each test needs World creation, entity setup, and teardown (mitigated by custom fixture)</p> </li> <li> <p>Limited to logic - can't test rendering, physics, or other Unity engine integrations in unit tests</p> </li> <li> <p>Manual maintenance - custom fixtures need updates when Unity ECS APIs change</p> </li> </ul>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#best-use","title":"Best use","text":"<ul> <li> <p>System logic validation - test calculation systems (damage, health regen, movement) with predictable inputs/outputs</p> </li> <li> <p>Edge case testing - verify systems handle empty queries, zero values, negative numbers, boundary conditions</p> </li> <li> <p>Refactoring safety - comprehensive test suite enables confident refactoring of system implementations</p> </li> </ul>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#avoid-if","title":"Avoid if","text":"<ul> <li> <p>Testing Unity engine integration - use PlayMode tests for rendering, physics, animation systems</p> </li> <li> <p>Testing performance - use Performance Testing with benchmarking tools for measuring system execution time</p> </li> <li> <p>Complex multi-system interactions - integration tests better suited for testing multiple systems working together</p> </li> </ul>","tags":["testing"]},{"location":"DOTS/Testing/Unit%20Testing/#extra-tip","title":"Extra tip","text":"<ul> <li>ECSTestsFixture base class members - when inheriting from <code>ECSTestsFixture</code>, you get access to:</li> <li><code>World</code> - the test world</li> <li><code>m_Manager</code> - the EntityManager (use this instead of <code>EntityManager</code>)</li> <li><code>EmptySystem</code> - empty system for dependency testing</li> <li> <p>Override <code>[SetUp]</code> and <code>[TearDown]</code> carefully - call <code>base.SetUp()</code> and <code>base.TearDown()</code> if you add custom logic</p> </li> <li> <p>Use <code>[BurstCompile]</code> consistently - annotate test systems same as production to ensure Burst compilation succeeds</p> </li> <li> <p>ComponentLookup for read-only access - in jobs, use <code>ComponentLookup&lt;T&gt;</code> for efficient random component access without write conflicts</p> </li> <li> <p>Define test assemblies properly - add <code>\"UNITY_INCLUDE_TESTS\"</code> constraint to test assembly definition to prevent build failures:   <pre><code>{\n  \"name\": \"MyGame.Tests\",\n  \"references\": [\"MyGame\", \"Unity.Entities\"],\n  \"optionalUnityReferences\": [\"TestAssemblies\"],\n  \"includePlatforms\": [],\n  \"excludePlatforms\": [],\n  \"allowUnsafeCode\": true,\n  \"defineConstraints\": [\"UNITY_INCLUDE_TESTS\"]\n}\n</code></pre></p> </li> <li> <p>Maintain infrastructure assemblies - separate reusable test utilities into dedicated assembly for use across EditMode and PlayMode tests</p> </li> <li> <p>Test multiple scenarios - for each system, test: nominal case, edge cases (empty, zero, max values), error conditions</p> </li> <li> <p>Entity archetype testing - verify systems correctly query entities with specific archetype combinations using <code>.WithAll&lt;T&gt;()</code>, <code>.WithNone&lt;T&gt;()</code></p> </li> <li> <p>Shared test data - create helper methods for common entity setups to reduce duplication across test classes</p> </li> </ul>","tags":["testing"]}]}